2019-12-30 00:00:20.095 [http-nio-8080-exec-6] INFO  com.lgq.controller.SiteController - FrancisBlog: getSiteInfo
2019-12-30 00:00:20.106 [http-nio-8080-exec-7] INFO  com.lgq.controller.MenuController - FrancisBlog: getAllParentMenu
2019-12-30 00:00:20.107 [http-nio-8080-exec-6] INFO  com.lgq.service.impl.SiteServiceImpl - DAY_PAGE_VIEW_PREFIX2019-12-30
2019-12-30 00:00:20.256 [http-nio-8080-exec-10] INFO  com.lgq.controller.SiteController - FrancisBlog: getSiteInfo
2019-12-30 00:00:20.260 [http-nio-8080-exec-10] INFO  com.lgq.service.impl.SiteServiceImpl - DAY_PAGE_VIEW_PREFIX2019-12-30
2019-12-30 00:04:03.384 [http-nio-8080-exec-10] INFO  com.lgq.controller.BlogController - FrancisBlog: getBlogListByCategory: categoryId:1
2019-12-30 00:04:14.886 [http-nio-8080-exec-1] INFO  com.lgq.controller.BlogController - FrancisBlog: getBlogListByCategory: categoryId:1
2019-12-30 00:04:28.311 [http-nio-8080-exec-2] INFO  com.lgq.controller.CategoryController - FrancisBlog: getAllCategory
2019-12-30 00:04:55.672 [http-nio-8080-exec-3] INFO  com.lgq.controller.BlogController - FrancisBlog: getBlogListByCategory: categoryId:3
2019-12-30 00:09:51.091 [main] INFO  com.lgq.FrancisBlogApplication - Starting FrancisBlogApplication on DESKTOP-G6KT9CH with PID 22412 (I:\blog_for_feifeifei\blog-for-feifeifei\target\classes started by lin in I:\blog_for_feifeifei\blog-for-feifeifei)
2019-12-30 00:09:51.097 [main] INFO  com.lgq.FrancisBlogApplication - No active profile set, falling back to default profiles: default
2019-12-30 00:09:53.564 [main] INFO  o.s.d.r.config.RepositoryConfigurationDelegate - Multiple Spring Data modules found, entering strict repository configuration mode!
2019-12-30 00:09:53.568 [main] INFO  o.s.d.r.config.RepositoryConfigurationDelegate - Bootstrapping Spring Data repositories in DEFAULT mode.
2019-12-30 00:09:53.703 [main] INFO  o.s.d.r.config.RepositoryConfigurationDelegate - Finished Spring Data repository scanning in 110ms. Found 0 repository interfaces.
2019-12-30 00:09:54.307 [main] INFO  o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker - Bean 'org.springframework.transaction.annotation.ProxyTransactionManagementConfiguration' of type [org.springframework.transaction.annotation.ProxyTransactionManagementConfiguration$$EnhancerBySpringCGLIB$$3e24a26d] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2019-12-30 00:09:54.906 [main] INFO  o.s.boot.web.embedded.tomcat.TomcatWebServer - Tomcat initialized with port(s): 8080 (http)
2019-12-30 00:09:54.931 [main] INFO  org.apache.coyote.http11.Http11NioProtocol - Initializing ProtocolHandler ["http-nio-8080"]
2019-12-30 00:09:54.947 [main] INFO  org.apache.catalina.core.StandardService - Starting service [Tomcat]
2019-12-30 00:09:54.948 [main] INFO  org.apache.catalina.core.StandardEngine - Starting Servlet engine: [Apache Tomcat/9.0.17]
2019-12-30 00:09:54.959 [main] INFO  org.apache.catalina.core.AprLifecycleListener - An older version [1.2.17] of the APR based Apache Tomcat Native library is installed, while Tomcat recommends a minimum version of [1.2.21]
2019-12-30 00:09:54.960 [main] INFO  org.apache.catalina.core.AprLifecycleListener - Loaded APR based Apache Tomcat Native library [1.2.17] using APR version [1.6.3].
2019-12-30 00:09:54.960 [main] INFO  org.apache.catalina.core.AprLifecycleListener - APR capabilities: IPv6 [true], sendfile [true], accept filters [false], random [true].
2019-12-30 00:09:54.961 [main] INFO  org.apache.catalina.core.AprLifecycleListener - APR/OpenSSL configuration: useAprConnector [false], useOpenSSL [true]
2019-12-30 00:09:56.202 [main] INFO  org.apache.catalina.core.AprLifecycleListener - OpenSSL successfully initialized [OpenSSL 1.0.2o  27 Mar 2018]
2019-12-30 00:09:56.547 [main] INFO  o.a.c.c.C.[.[localhost].[/francisblog/api/v1] - Initializing Spring embedded WebApplicationContext
2019-12-30 00:09:56.548 [main] INFO  org.springframework.web.context.ContextLoader - Root WebApplicationContext: initialization completed in 5366 ms
2019-12-30 00:10:00.499 [main] INFO  s.d.s.w.PropertySourcedRequestMappingHandlerMapping - Mapped URL path [/v2/api-docs] onto method [public org.springframework.http.ResponseEntity<springfox.documentation.spring.web.json.Json> springfox.documentation.swagger2.web.Swagger2Controller.getDocumentation(java.lang.String,javax.servlet.http.HttpServletRequest)]
2019-12-30 00:10:01.008 [main] INFO  o.s.scheduling.concurrent.ThreadPoolTaskExecutor - Initializing ExecutorService 'applicationTaskExecutor'
2019-12-30 00:10:02.800 [main] INFO  s.d.s.web.plugins.DocumentationPluginsBootstrapper - Context refreshed
2019-12-30 00:10:02.855 [main] INFO  s.d.s.web.plugins.DocumentationPluginsBootstrapper - Found 1 custom documentation plugin(s)
2019-12-30 00:10:03.023 [main] INFO  s.d.spring.web.scanners.ApiListingReferenceScanner - Scanning for api listing references
2019-12-30 00:10:03.480 [main] INFO  s.d.s.w.r.operation.CachingOperationNameGenerator - Generating unique operation named: getAllAlbumUsingGET_1
2019-12-30 00:10:03.831 [main] INFO  org.apache.coyote.http11.Http11NioProtocol - Starting ProtocolHandler ["http-nio-8080"]
2019-12-30 00:10:03.898 [main] INFO  o.s.boot.web.embedded.tomcat.TomcatWebServer - Tomcat started on port(s): 8080 (http) with context path '/francisblog/api/v1'
2019-12-30 00:10:03.904 [main] INFO  com.lgq.FrancisBlogApplication - Started FrancisBlogApplication in 14.334 seconds (JVM running for 18.364)
2019-12-30 00:10:50.455 [http-nio-8080-exec-2] INFO  o.a.c.c.C.[.[localhost].[/francisblog/api/v1] - Initializing Spring DispatcherServlet 'dispatcherServlet'
2019-12-30 00:10:50.467 [http-nio-8080-exec-2] INFO  org.springframework.web.servlet.DispatcherServlet - Initializing Servlet 'dispatcherServlet'
2019-12-30 00:10:50.487 [http-nio-8080-exec-2] INFO  org.springframework.web.servlet.DispatcherServlet - Completed initialization in 19 ms
2019-12-30 00:11:47.574 [http-nio-8080-exec-5] INFO  com.lgq.controller.BlogController - FrancisBlog: addBlog -> {"blogCategoryId":1,"blogContent":"vcsdfsds","blogCover":"sadasa","blogSummary":"asdazcz","blogTitle":"胜多负少的胜多负少","tags":[1,2]}
2019-12-30 00:11:47.659 [http-nio-8080-exec-5] INFO  com.alibaba.druid.pool.DruidDataSource - {dataSource-1} inited
2019-12-30 00:12:34.587 [http-nio-8080-exec-6] INFO  com.lgq.controller.MenuController - FrancisBlog: getAllParentMenu
2019-12-30 00:12:36.535 [http-nio-8080-exec-9] INFO  com.lgq.controller.SiteIconController - FrancisBlog: getAllSiteIcon
2019-12-30 00:12:36.537 [http-nio-8080-exec-8] INFO  com.lgq.controller.CategoryController - FrancisBlog: getAllCategory
2019-12-30 00:12:36.595 [http-nio-8080-exec-1] INFO  com.lgq.controller.SiteController - FrancisBlog: getSiteInfo
2019-12-30 00:12:36.637 [http-nio-8080-exec-3] INFO  com.lgq.controller.SiteFriendLinkController - FrancisBlog: getAllSiteFriendLink
2019-12-30 00:12:36.660 [http-nio-8080-exec-4] INFO  com.lgq.controller.SiteTagController - FrancisBlog: getAllSiteTag
2019-12-30 00:12:36.876 [http-nio-8080-exec-1] INFO  io.lettuce.core.EpollProvider - Starting without optional epoll library
2019-12-30 00:12:36.880 [http-nio-8080-exec-1] INFO  io.lettuce.core.KqueueProvider - Starting without optional kqueue library
2019-12-30 00:12:37.834 [http-nio-8080-exec-5] INFO  com.lgq.controller.AdvertisementController - FrancisBlog: getAllAdvertisement
2019-12-30 00:12:43.100 [http-nio-8080-exec-1] INFO  com.lgq.service.impl.SiteServiceImpl - DAY_PAGE_VIEW_PREFIX2019-12-30
2019-12-30 00:12:45.864 [http-nio-8080-exec-7] INFO  com.lgq.controller.SiteController - FrancisBlog: getSiteInfo
2019-12-30 00:12:45.924 [http-nio-8080-exec-7] INFO  com.lgq.service.impl.SiteServiceImpl - DAY_PAGE_VIEW_PREFIX2019-12-30
2019-12-30 00:12:46.587 [http-nio-8080-exec-9] INFO  com.lgq.controller.SiteController - FrancisBlog: getSiteInfo
2019-12-30 00:12:46.592 [http-nio-8080-exec-9] INFO  com.lgq.service.impl.SiteServiceImpl - DAY_PAGE_VIEW_PREFIX2019-12-30
2019-12-30 00:13:12.565 [main] INFO  com.lgq.FrancisBlogApplication - Starting FrancisBlogApplication on DESKTOP-G6KT9CH with PID 18300 (I:\blog_for_feifeifei\blog-for-feifeifei\target\classes started by lin in I:\blog_for_feifeifei\blog-for-feifeifei)
2019-12-30 00:13:12.572 [main] INFO  com.lgq.FrancisBlogApplication - No active profile set, falling back to default profiles: default
2019-12-30 00:13:15.691 [main] INFO  o.s.d.r.config.RepositoryConfigurationDelegate - Multiple Spring Data modules found, entering strict repository configuration mode!
2019-12-30 00:13:15.696 [main] INFO  o.s.d.r.config.RepositoryConfigurationDelegate - Bootstrapping Spring Data repositories in DEFAULT mode.
2019-12-30 00:13:15.851 [main] INFO  o.s.d.r.config.RepositoryConfigurationDelegate - Finished Spring Data repository scanning in 127ms. Found 0 repository interfaces.
2019-12-30 00:13:16.486 [main] INFO  o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker - Bean 'org.springframework.transaction.annotation.ProxyTransactionManagementConfiguration' of type [org.springframework.transaction.annotation.ProxyTransactionManagementConfiguration$$EnhancerBySpringCGLIB$$51c588f9] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2019-12-30 00:13:17.133 [main] INFO  o.s.boot.web.embedded.tomcat.TomcatWebServer - Tomcat initialized with port(s): 8080 (http)
2019-12-30 00:13:17.160 [main] INFO  org.apache.coyote.http11.Http11NioProtocol - Initializing ProtocolHandler ["http-nio-8080"]
2019-12-30 00:13:17.176 [main] INFO  org.apache.catalina.core.StandardService - Starting service [Tomcat]
2019-12-30 00:13:17.177 [main] INFO  org.apache.catalina.core.StandardEngine - Starting Servlet engine: [Apache Tomcat/9.0.17]
2019-12-30 00:13:17.190 [main] INFO  org.apache.catalina.core.AprLifecycleListener - An older version [1.2.17] of the APR based Apache Tomcat Native library is installed, while Tomcat recommends a minimum version of [1.2.21]
2019-12-30 00:13:17.191 [main] INFO  org.apache.catalina.core.AprLifecycleListener - Loaded APR based Apache Tomcat Native library [1.2.17] using APR version [1.6.3].
2019-12-30 00:13:17.191 [main] INFO  org.apache.catalina.core.AprLifecycleListener - APR capabilities: IPv6 [true], sendfile [true], accept filters [false], random [true].
2019-12-30 00:13:17.191 [main] INFO  org.apache.catalina.core.AprLifecycleListener - APR/OpenSSL configuration: useAprConnector [false], useOpenSSL [true]
2019-12-30 00:13:18.375 [main] INFO  org.apache.catalina.core.AprLifecycleListener - OpenSSL successfully initialized [OpenSSL 1.0.2o  27 Mar 2018]
2019-12-30 00:13:18.597 [main] INFO  o.a.c.c.C.[.[localhost].[/francisblog/api/v1] - Initializing Spring embedded WebApplicationContext
2019-12-30 00:13:18.598 [main] INFO  org.springframework.web.context.ContextLoader - Root WebApplicationContext: initialization completed in 5914 ms
2019-12-30 00:13:20.848 [main] INFO  s.d.s.w.PropertySourcedRequestMappingHandlerMapping - Mapped URL path [/v2/api-docs] onto method [public org.springframework.http.ResponseEntity<springfox.documentation.spring.web.json.Json> springfox.documentation.swagger2.web.Swagger2Controller.getDocumentation(java.lang.String,javax.servlet.http.HttpServletRequest)]
2019-12-30 00:13:21.105 [main] INFO  o.s.scheduling.concurrent.ThreadPoolTaskExecutor - Initializing ExecutorService 'applicationTaskExecutor'
2019-12-30 00:13:21.665 [main] INFO  s.d.s.web.plugins.DocumentationPluginsBootstrapper - Context refreshed
2019-12-30 00:13:21.700 [main] INFO  s.d.s.web.plugins.DocumentationPluginsBootstrapper - Found 1 custom documentation plugin(s)
2019-12-30 00:13:21.797 [main] INFO  s.d.spring.web.scanners.ApiListingReferenceScanner - Scanning for api listing references
2019-12-30 00:13:22.067 [main] INFO  s.d.s.w.r.operation.CachingOperationNameGenerator - Generating unique operation named: getAllAlbumUsingGET_1
2019-12-30 00:13:22.307 [main] INFO  org.apache.coyote.http11.Http11NioProtocol - Starting ProtocolHandler ["http-nio-8080"]
2019-12-30 00:13:22.352 [main] INFO  o.s.boot.web.embedded.tomcat.TomcatWebServer - Tomcat started on port(s): 8080 (http) with context path '/francisblog/api/v1'
2019-12-30 00:13:22.357 [main] INFO  com.lgq.FrancisBlogApplication - Started FrancisBlogApplication in 11.223 seconds (JVM running for 16.492)
2019-12-30 00:13:39.143 [http-nio-8080-exec-1] INFO  o.a.c.c.C.[.[localhost].[/francisblog/api/v1] - Initializing Spring DispatcherServlet 'dispatcherServlet'
2019-12-30 00:13:39.145 [http-nio-8080-exec-1] INFO  org.springframework.web.servlet.DispatcherServlet - Initializing Servlet 'dispatcherServlet'
2019-12-30 00:13:39.161 [http-nio-8080-exec-1] INFO  org.springframework.web.servlet.DispatcherServlet - Completed initialization in 15 ms
2019-12-30 00:13:39.449 [http-nio-8080-exec-1] INFO  com.lgq.controller.BlogController - FrancisBlog: addBlog -> {"blogCategoryId":1,"blogContent":"vcsdfsds","blogCover":"sadasa","blogSummary":"asdazcz","blogTitle":"胜多负少的胜多负少","tags":[1,2]}
2019-12-30 00:13:39.542 [http-nio-8080-exec-1] INFO  com.alibaba.druid.pool.DruidDataSource - {dataSource-1} inited
2019-12-30 00:15:33.432 [http-nio-8080-exec-5] INFO  com.lgq.controller.BlogController - FrancisBlog: getBlogListByCategory: categoryId:1
2019-12-30 00:16:11.014 [http-nio-8080-exec-4] INFO  com.lgq.controller.SiteController - FrancisBlog: getSiteInfo
2019-12-30 00:16:11.089 [http-nio-8080-exec-6] INFO  com.lgq.controller.MenuController - FrancisBlog: getAllParentMenu
2019-12-30 00:16:11.252 [http-nio-8080-exec-4] INFO  io.lettuce.core.EpollProvider - Starting without optional epoll library
2019-12-30 00:16:11.254 [http-nio-8080-exec-4] INFO  io.lettuce.core.KqueueProvider - Starting without optional kqueue library
2019-12-30 00:16:11.385 [http-nio-8080-exec-7] INFO  com.lgq.controller.BlogController - FrancisBlog: getBlogListByCategory: categoryId:1
2019-12-30 00:16:15.689 [http-nio-8080-exec-4] INFO  com.lgq.service.impl.SiteServiceImpl - DAY_PAGE_VIEW_PREFIX2019-12-30
2019-12-30 00:16:15.853 [http-nio-8080-exec-8] INFO  com.lgq.controller.SiteController - FrancisBlog: getSiteInfo
2019-12-30 00:16:15.859 [http-nio-8080-exec-8] INFO  com.lgq.service.impl.SiteServiceImpl - DAY_PAGE_VIEW_PREFIX2019-12-30
2019-12-30 00:16:23.968 [http-nio-8080-exec-9] INFO  com.lgq.controller.BlogController - FrancisBlog: getBlogById: blog_id:10
2019-12-30 00:16:23.968 [http-nio-8080-exec-10] INFO  com.lgq.controller.MenuController - FrancisBlog: getAllParentMenu
2019-12-30 00:16:23.985 [http-nio-8080-exec-2] INFO  com.lgq.controller.SiteController - FrancisBlog: getSiteInfo
2019-12-30 00:16:23.995 [http-nio-8080-exec-2] INFO  com.lgq.service.impl.SiteServiceImpl - DAY_PAGE_VIEW_PREFIX2019-12-30
2019-12-30 00:16:23.998 [http-nio-8080-exec-9] INFO  com.lgq.service.impl.BlogServiceImpl - null
2019-12-30 00:16:24.108 [http-nio-8080-exec-9] INFO  com.lgq.service.impl.BlogServiceImpl - 1
2019-12-30 00:16:24.124 [http-nio-8080-exec-1] INFO  com.lgq.controller.SiteController - FrancisBlog: getSiteInfo
2019-12-30 00:16:24.129 [http-nio-8080-exec-1] INFO  com.lgq.service.impl.SiteServiceImpl - DAY_PAGE_VIEW_PREFIX2019-12-30
2019-12-30 00:16:52.743 [http-nio-8080-exec-3] INFO  com.lgq.controller.BlogController - FrancisBlog: getBlogListByCategory: categoryId:3
2019-12-30 00:17:01.993 [http-nio-8080-exec-5] INFO  com.lgq.controller.SiteController - FrancisBlog: getSiteInfo
2019-12-30 00:17:02.001 [http-nio-8080-exec-4] INFO  com.lgq.controller.MenuController - FrancisBlog: getAllParentMenu
2019-12-30 00:17:02.002 [http-nio-8080-exec-5] INFO  com.lgq.service.impl.SiteServiceImpl - DAY_PAGE_VIEW_PREFIX2019-12-30
2019-12-30 00:17:02.003 [http-nio-8080-exec-6] INFO  com.lgq.controller.BlogController - FrancisBlog: getBlogListByCategory: categoryId:1
2019-12-30 00:17:02.152 [http-nio-8080-exec-8] INFO  com.lgq.controller.SiteController - FrancisBlog: getSiteInfo
2019-12-30 00:17:02.157 [http-nio-8080-exec-8] INFO  com.lgq.service.impl.SiteServiceImpl - DAY_PAGE_VIEW_PREFIX2019-12-30
2019-12-30 00:18:01.433 [main] INFO  com.lgq.FrancisBlogApplication - Starting FrancisBlogApplication on DESKTOP-G6KT9CH with PID 23524 (I:\blog_for_feifeifei\blog-for-feifeifei\target\classes started by lin in I:\blog_for_feifeifei\blog-for-feifeifei)
2019-12-30 00:18:01.441 [main] INFO  com.lgq.FrancisBlogApplication - No active profile set, falling back to default profiles: default
2019-12-30 00:18:03.708 [main] INFO  o.s.d.r.config.RepositoryConfigurationDelegate - Multiple Spring Data modules found, entering strict repository configuration mode!
2019-12-30 00:18:03.713 [main] INFO  o.s.d.r.config.RepositoryConfigurationDelegate - Bootstrapping Spring Data repositories in DEFAULT mode.
2019-12-30 00:18:03.847 [main] INFO  o.s.d.r.config.RepositoryConfigurationDelegate - Finished Spring Data repository scanning in 110ms. Found 0 repository interfaces.
2019-12-30 00:18:04.413 [main] INFO  o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker - Bean 'org.springframework.transaction.annotation.ProxyTransactionManagementConfiguration' of type [org.springframework.transaction.annotation.ProxyTransactionManagementConfiguration$$EnhancerBySpringCGLIB$$51c588f9] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2019-12-30 00:18:05.016 [main] INFO  o.s.boot.web.embedded.tomcat.TomcatWebServer - Tomcat initialized with port(s): 8080 (http)
2019-12-30 00:18:05.043 [main] INFO  org.apache.coyote.http11.Http11NioProtocol - Initializing ProtocolHandler ["http-nio-8080"]
2019-12-30 00:18:05.059 [main] INFO  org.apache.catalina.core.StandardService - Starting service [Tomcat]
2019-12-30 00:18:05.060 [main] INFO  org.apache.catalina.core.StandardEngine - Starting Servlet engine: [Apache Tomcat/9.0.17]
2019-12-30 00:18:05.073 [main] INFO  org.apache.catalina.core.AprLifecycleListener - An older version [1.2.17] of the APR based Apache Tomcat Native library is installed, while Tomcat recommends a minimum version of [1.2.21]
2019-12-30 00:18:05.074 [main] INFO  org.apache.catalina.core.AprLifecycleListener - Loaded APR based Apache Tomcat Native library [1.2.17] using APR version [1.6.3].
2019-12-30 00:18:05.075 [main] INFO  org.apache.catalina.core.AprLifecycleListener - APR capabilities: IPv6 [true], sendfile [true], accept filters [false], random [true].
2019-12-30 00:18:05.075 [main] INFO  org.apache.catalina.core.AprLifecycleListener - APR/OpenSSL configuration: useAprConnector [false], useOpenSSL [true]
2019-12-30 00:18:06.276 [main] INFO  org.apache.catalina.core.AprLifecycleListener - OpenSSL successfully initialized [OpenSSL 1.0.2o  27 Mar 2018]
2019-12-30 00:18:06.492 [main] INFO  o.a.c.c.C.[.[localhost].[/francisblog/api/v1] - Initializing Spring embedded WebApplicationContext
2019-12-30 00:18:06.493 [main] INFO  org.springframework.web.context.ContextLoader - Root WebApplicationContext: initialization completed in 4969 ms
2019-12-30 00:18:08.785 [main] INFO  s.d.s.w.PropertySourcedRequestMappingHandlerMapping - Mapped URL path [/v2/api-docs] onto method [public org.springframework.http.ResponseEntity<springfox.documentation.spring.web.json.Json> springfox.documentation.swagger2.web.Swagger2Controller.getDocumentation(java.lang.String,javax.servlet.http.HttpServletRequest)]
2019-12-30 00:18:09.314 [main] INFO  o.s.scheduling.concurrent.ThreadPoolTaskExecutor - Initializing ExecutorService 'applicationTaskExecutor'
2019-12-30 00:18:09.916 [main] INFO  s.d.s.web.plugins.DocumentationPluginsBootstrapper - Context refreshed
2019-12-30 00:18:09.952 [main] INFO  s.d.s.web.plugins.DocumentationPluginsBootstrapper - Found 1 custom documentation plugin(s)
2019-12-30 00:18:10.048 [main] INFO  s.d.spring.web.scanners.ApiListingReferenceScanner - Scanning for api listing references
2019-12-30 00:18:10.391 [main] INFO  s.d.s.w.r.operation.CachingOperationNameGenerator - Generating unique operation named: getAllAlbumUsingGET_1
2019-12-30 00:18:10.724 [main] INFO  org.apache.coyote.http11.Http11NioProtocol - Starting ProtocolHandler ["http-nio-8080"]
2019-12-30 00:18:10.798 [main] INFO  o.s.boot.web.embedded.tomcat.TomcatWebServer - Tomcat started on port(s): 8080 (http) with context path '/francisblog/api/v1'
2019-12-30 00:18:10.803 [main] INFO  com.lgq.FrancisBlogApplication - Started FrancisBlogApplication in 10.542 seconds (JVM running for 14.319)
2019-12-30 00:18:55.070 [http-nio-8080-exec-10] INFO  o.a.c.c.C.[.[localhost].[/francisblog/api/v1] - Initializing Spring DispatcherServlet 'dispatcherServlet'
2019-12-30 00:18:55.071 [http-nio-8080-exec-10] INFO  org.springframework.web.servlet.DispatcherServlet - Initializing Servlet 'dispatcherServlet'
2019-12-30 00:18:55.087 [http-nio-8080-exec-10] INFO  org.springframework.web.servlet.DispatcherServlet - Completed initialization in 16 ms
2019-12-30 00:18:55.354 [http-nio-8080-exec-10] INFO  com.lgq.controller.BlogController - FrancisBlog: addBlog -> {"blogCategoryId":1,"blogContent":"电饭锅地方","blogCover":"dsfsdds","blogSummary":"法国号风格和规范","blogTitle":"发给对方大范甘迪","tags":[1,2,3]}
2019-12-30 00:18:55.433 [http-nio-8080-exec-10] INFO  com.alibaba.druid.pool.DruidDataSource - {dataSource-1} inited
2019-12-30 00:19:19.812 [http-nio-8080-exec-9] INFO  com.lgq.controller.BlogController - FrancisBlog: addBlog -> {"blogCategoryId":1,"blogContent":"电饭锅地方","blogCover":"dsfsdds","blogSummary":"法国号风格和规范","blogTitle":"发给对方大范甘迪","tags":[1,2,3]}
2019-12-30 00:21:41.675 [http-nio-8080-exec-6] INFO  com.lgq.controller.BlogController - FrancisBlog: getBlogListByCategory: categoryId:1
2019-12-30 00:22:24.064 [http-nio-8080-exec-5] INFO  com.lgq.controller.BlogController - FrancisBlog: getBlogListByCategory: categoryId:1
2019-12-30 00:22:53.705 [http-nio-8080-exec-4] INFO  com.lgq.controller.TokenController - FrancisBlog: getToken
2019-12-30 00:22:53.753 [http-nio-8080-exec-2] INFO  com.lgq.controller.CategoryController - FrancisBlog: getAllCategory
2019-12-30 00:23:27.385 [http-nio-8080-exec-10] INFO  com.lgq.controller.TokenController - FrancisBlog: getToken
2019-12-30 00:23:27.408 [http-nio-8080-exec-9] INFO  com.lgq.controller.CategoryController - FrancisBlog: getAllCategory
2019-12-30 00:23:56.695 [http-nio-8080-exec-6] INFO  com.lgq.controller.TagController - FrancisBlog: addTag -> {}
2019-12-30 00:24:03.686 [http-nio-8080-exec-3] INFO  com.lgq.controller.TagController - FrancisBlog: getAllTag
2019-12-30 00:26:17.674 [http-nio-8080-exec-1] INFO  com.lgq.controller.TokenController - FrancisBlog: getToken
2019-12-30 00:26:17.694 [http-nio-8080-exec-9] INFO  com.lgq.controller.CategoryController - FrancisBlog: getAllCategory
2019-12-30 00:26:17.703 [http-nio-8080-exec-8] INFO  com.lgq.controller.TagController - FrancisBlog: getAllTag
2019-12-30 00:26:26.548 [http-nio-8080-exec-6] INFO  com.lgq.controller.SiteTagController - FrancisBlog: getAllSiteTag
2019-12-30 00:26:26.548 [http-nio-8080-exec-5] INFO  com.lgq.controller.MenuController - FrancisBlog: getAllParentMenu
2019-12-30 00:26:26.554 [http-nio-8080-exec-3] INFO  com.lgq.controller.SiteController - FrancisBlog: getSiteInfo
2019-12-30 00:26:26.564 [http-nio-8080-exec-2] INFO  com.lgq.controller.CategoryController - FrancisBlog: getAllCategory
2019-12-30 00:26:26.607 [http-nio-8080-exec-4] INFO  com.lgq.controller.SiteFriendLinkController - FrancisBlog: getAllSiteFriendLink
2019-12-30 00:26:26.611 [http-nio-8080-exec-9] INFO  com.lgq.controller.SiteIconController - FrancisBlog: getAllSiteIcon
2019-12-30 00:26:26.794 [http-nio-8080-exec-8] INFO  com.lgq.controller.AdvertisementController - FrancisBlog: getAllAdvertisement
2019-12-30 00:26:27.072 [http-nio-8080-exec-3] INFO  io.lettuce.core.EpollProvider - Starting without optional epoll library
2019-12-30 00:26:27.075 [http-nio-8080-exec-3] INFO  io.lettuce.core.KqueueProvider - Starting without optional kqueue library
2019-12-30 00:26:29.814 [http-nio-8080-exec-7] INFO  com.lgq.controller.MenuController - FrancisBlog: getAllParentMenu
2019-12-30 00:26:29.826 [http-nio-8080-exec-2] INFO  com.lgq.controller.BlogController - FrancisBlog: getBlogListByCategory: categoryId:3
2019-12-30 00:26:29.828 [http-nio-8080-exec-6] INFO  com.lgq.controller.SiteController - FrancisBlog: getSiteInfo
2019-12-30 00:26:32.143 [http-nio-8080-exec-3] INFO  com.lgq.service.impl.SiteServiceImpl - DAY_PAGE_VIEW_PREFIX2019-12-30
2019-12-30 00:26:32.144 [http-nio-8080-exec-6] INFO  com.lgq.service.impl.SiteServiceImpl - DAY_PAGE_VIEW_PREFIX2019-12-30
2019-12-30 00:26:32.472 [http-nio-8080-exec-4] INFO  com.lgq.controller.SiteController - FrancisBlog: getSiteInfo
2019-12-30 00:26:32.477 [http-nio-8080-exec-4] INFO  com.lgq.service.impl.SiteServiceImpl - DAY_PAGE_VIEW_PREFIX2019-12-30
2019-12-30 00:26:33.744 [http-nio-8080-exec-9] INFO  com.lgq.controller.SiteController - FrancisBlog: getSiteInfo
2019-12-30 00:26:33.755 [http-nio-8080-exec-9] INFO  com.lgq.service.impl.SiteServiceImpl - DAY_PAGE_VIEW_PREFIX2019-12-30
2019-12-30 00:26:33.758 [http-nio-8080-exec-5] INFO  com.lgq.controller.BlogController - FrancisBlog: getBlogById: blog_id:5
2019-12-30 00:26:33.766 [http-nio-8080-exec-8] INFO  com.lgq.controller.MenuController - FrancisBlog: getAllParentMenu
2019-12-30 00:26:33.915 [http-nio-8080-exec-5] INFO  com.lgq.service.impl.BlogServiceImpl - null
2019-12-30 00:26:33.925 [http-nio-8080-exec-1] INFO  com.lgq.controller.SiteController - FrancisBlog: getSiteInfo
2019-12-30 00:26:33.931 [http-nio-8080-exec-1] INFO  com.lgq.service.impl.SiteServiceImpl - DAY_PAGE_VIEW_PREFIX2019-12-30
2019-12-30 00:26:33.952 [http-nio-8080-exec-5] INFO  com.lgq.service.impl.BlogServiceImpl - 4
2019-12-30 00:26:57.392 [http-nio-8080-exec-6] INFO  com.lgq.controller.MenuController - FrancisBlog: getAllParentMenu
2019-12-30 00:26:57.392 [http-nio-8080-exec-9] INFO  com.lgq.controller.SiteTagController - FrancisBlog: getAllSiteTag
2019-12-30 00:26:57.402 [http-nio-8080-exec-10] INFO  com.lgq.controller.BlogController - FrancisBlog: getBlogList:1
2019-12-30 00:26:57.407 [http-nio-8080-exec-8] INFO  com.lgq.controller.SiteIconController - FrancisBlog: getAllSiteIcon
2019-12-30 00:26:57.420 [http-nio-8080-exec-1] INFO  com.lgq.controller.SiteController - FrancisBlog: getSiteInfo
2019-12-30 00:26:57.426 [http-nio-8080-exec-1] INFO  com.lgq.service.impl.SiteServiceImpl - DAY_PAGE_VIEW_PREFIX2019-12-30
2019-12-30 00:26:57.472 [http-nio-8080-exec-3] INFO  com.lgq.controller.SiteFriendLinkController - FrancisBlog: getAllSiteFriendLink
2019-12-30 00:26:57.573 [http-nio-8080-exec-4] INFO  com.lgq.controller.AdvertisementController - FrancisBlog: getAllAdvertisement
2019-12-30 00:26:57.579 [http-nio-8080-exec-9] INFO  com.lgq.controller.SiteController - FrancisBlog: getSiteInfo
2019-12-30 00:26:57.586 [http-nio-8080-exec-9] INFO  com.lgq.service.impl.SiteServiceImpl - DAY_PAGE_VIEW_PREFIX2019-12-30
2019-12-30 00:26:57.741 [http-nio-8080-exec-6] INFO  com.lgq.controller.SiteController - FrancisBlog: getSiteInfo
2019-12-30 00:26:57.747 [http-nio-8080-exec-6] INFO  com.lgq.service.impl.SiteServiceImpl - DAY_PAGE_VIEW_PREFIX2019-12-30
2019-12-30 00:27:07.584 [http-nio-8080-exec-8] INFO  com.lgq.controller.BlogController - FrancisBlog: getBlogList:1
2019-12-30 00:27:07.584 [http-nio-8080-exec-1] INFO  com.lgq.controller.MenuController - FrancisBlog: getAllParentMenu
2019-12-30 00:27:07.600 [http-nio-8080-exec-3] INFO  com.lgq.controller.SiteController - FrancisBlog: getSiteInfo
2019-12-30 00:27:07.604 [http-nio-8080-exec-3] INFO  com.lgq.service.impl.SiteServiceImpl - DAY_PAGE_VIEW_PREFIX2019-12-30
2019-12-30 00:27:07.625 [http-nio-8080-exec-2] INFO  com.lgq.controller.SiteTagController - FrancisBlog: getAllSiteTag
2019-12-30 00:27:07.633 [http-nio-8080-exec-9] INFO  com.lgq.controller.SiteIconController - FrancisBlog: getAllSiteIcon
2019-12-30 00:27:07.640 [http-nio-8080-exec-7] INFO  com.lgq.controller.SiteFriendLinkController - FrancisBlog: getAllSiteFriendLink
2019-12-30 00:27:09.337 [http-nio-8080-exec-1] INFO  com.lgq.controller.SiteController - FrancisBlog: getSiteInfo
2019-12-30 00:27:09.337 [http-nio-8080-exec-5] INFO  com.lgq.controller.AdvertisementController - FrancisBlog: getAllAdvertisement
2019-12-30 00:27:09.342 [http-nio-8080-exec-1] INFO  com.lgq.service.impl.SiteServiceImpl - DAY_PAGE_VIEW_PREFIX2019-12-30
2019-12-30 00:27:11.236 [http-nio-8080-exec-8] INFO  com.lgq.controller.SiteController - FrancisBlog: getSiteInfo
2019-12-30 00:27:11.242 [http-nio-8080-exec-8] INFO  com.lgq.service.impl.SiteServiceImpl - DAY_PAGE_VIEW_PREFIX2019-12-30
2019-12-30 00:27:30.514 [http-nio-8080-exec-4] INFO  com.lgq.controller.MenuController - FrancisBlog: getAllParentMenu
2019-12-30 00:27:30.659 [http-nio-8080-exec-2] INFO  com.lgq.controller.AdvertisementController - FrancisBlog: getAllAdvertisement
2019-12-30 00:27:30.851 [http-nio-8080-exec-7] INFO  com.lgq.controller.SiteController - FrancisBlog: getSiteInfo
2019-12-30 00:27:30.856 [http-nio-8080-exec-7] INFO  com.lgq.service.impl.SiteServiceImpl - DAY_PAGE_VIEW_PREFIX2019-12-30
2019-12-30 00:27:30.859 [http-nio-8080-exec-5] INFO  com.lgq.controller.SiteTagController - FrancisBlog: getAllSiteTag
2019-12-30 00:27:30.868 [http-nio-8080-exec-8] INFO  com.lgq.controller.CategoryController - FrancisBlog: getAllCategory
2019-12-30 00:27:30.876 [http-nio-8080-exec-10] INFO  com.lgq.controller.SiteIconController - FrancisBlog: getAllSiteIcon
2019-12-30 00:27:30.884 [http-nio-8080-exec-4] INFO  com.lgq.controller.SiteFriendLinkController - FrancisBlog: getAllSiteFriendLink
2019-12-30 00:27:30.979 [http-nio-8080-exec-6] INFO  com.lgq.controller.SiteController - FrancisBlog: getSiteInfo
2019-12-30 00:27:30.983 [http-nio-8080-exec-6] INFO  com.lgq.service.impl.SiteServiceImpl - DAY_PAGE_VIEW_PREFIX2019-12-30
2019-12-30 00:27:31.111 [http-nio-8080-exec-9] INFO  com.lgq.controller.SiteController - FrancisBlog: getSiteInfo
2019-12-30 00:27:31.117 [http-nio-8080-exec-9] INFO  com.lgq.service.impl.SiteServiceImpl - DAY_PAGE_VIEW_PREFIX2019-12-30
2019-12-30 00:27:35.915 [http-nio-8080-exec-1] INFO  com.lgq.controller.SiteController - FrancisBlog: getSiteInfo
2019-12-30 00:27:35.920 [http-nio-8080-exec-1] INFO  com.lgq.service.impl.SiteServiceImpl - DAY_PAGE_VIEW_PREFIX2019-12-30
2019-12-30 00:27:42.459 [http-nio-8080-exec-3] INFO  com.lgq.controller.BlogController - FrancisBlog: getBlogList:1
2019-12-30 00:27:42.469 [http-nio-8080-exec-7] INFO  com.lgq.controller.SiteIconController - FrancisBlog: getAllSiteIcon
2019-12-30 00:27:42.469 [http-nio-8080-exec-9] INFO  com.lgq.controller.MenuController - FrancisBlog: getAllParentMenu
2019-12-30 00:27:42.484 [http-nio-8080-exec-5] INFO  com.lgq.controller.SiteTagController - FrancisBlog: getAllSiteTag
2019-12-30 00:27:42.485 [http-nio-8080-exec-1] INFO  com.lgq.controller.SiteController - FrancisBlog: getSiteInfo
2019-12-30 00:27:42.488 [http-nio-8080-exec-4] INFO  com.lgq.controller.SiteFriendLinkController - FrancisBlog: getAllSiteFriendLink
2019-12-30 00:27:42.497 [http-nio-8080-exec-1] INFO  com.lgq.service.impl.SiteServiceImpl - DAY_PAGE_VIEW_PREFIX2019-12-30
2019-12-30 00:27:42.602 [http-nio-8080-exec-2] INFO  com.lgq.controller.AdvertisementController - FrancisBlog: getAllAdvertisement
2019-12-30 00:27:42.659 [http-nio-8080-exec-6] INFO  com.lgq.controller.SiteController - FrancisBlog: getSiteInfo
2019-12-30 00:27:42.664 [http-nio-8080-exec-6] INFO  com.lgq.service.impl.SiteServiceImpl - DAY_PAGE_VIEW_PREFIX2019-12-30
2019-12-30 00:27:42.782 [http-nio-8080-exec-7] INFO  com.lgq.controller.SiteController - FrancisBlog: getSiteInfo
2019-12-30 00:27:42.787 [http-nio-8080-exec-7] INFO  com.lgq.service.impl.SiteServiceImpl - DAY_PAGE_VIEW_PREFIX2019-12-30
2019-12-30 00:27:46.357 [http-nio-8080-exec-3] INFO  com.lgq.controller.TokenController - FrancisBlog: getToken
2019-12-30 00:27:46.444 [http-nio-8080-exec-5] INFO  com.lgq.controller.CategoryController - FrancisBlog: getAllCategory
2019-12-30 00:27:46.461 [http-nio-8080-exec-4] INFO  com.lgq.controller.TagController - FrancisBlog: getAllTag
2019-12-30 00:29:00.117 [http-nio-8080-exec-4] INFO  com.lgq.controller.SiteController - FrancisBlog: getSiteInfo
2019-12-30 00:29:00.119 [http-nio-8080-exec-10] INFO  com.lgq.controller.MenuController - FrancisBlog: getAllParentMenu
2019-12-30 00:29:00.122 [http-nio-8080-exec-4] INFO  com.lgq.service.impl.SiteServiceImpl - DAY_PAGE_VIEW_PREFIX2019-12-30
2019-12-30 00:29:00.132 [http-nio-8080-exec-1] INFO  com.lgq.controller.BlogController - FrancisBlog: getBlogListByCategory: categoryId:1
2019-12-30 00:29:00.356 [http-nio-8080-exec-3] INFO  com.lgq.controller.SiteController - FrancisBlog: getSiteInfo
2019-12-30 00:29:00.360 [http-nio-8080-exec-3] INFO  com.lgq.service.impl.SiteServiceImpl - DAY_PAGE_VIEW_PREFIX2019-12-30
2019-12-30 00:29:00.889 [http-nio-8080-exec-6] INFO  com.lgq.controller.BlogController - FrancisBlog: getBlogList:2
2019-12-30 00:29:07.119 [http-nio-8080-exec-8] INFO  com.lgq.controller.BlogController - FrancisBlog: getBlogList:3
2019-12-30 00:29:08.266 [http-nio-8080-exec-4] INFO  com.lgq.controller.BlogController - FrancisBlog: getBlogList:4
2019-12-30 00:29:11.947 [http-nio-8080-exec-10] INFO  com.lgq.controller.BlogController - FrancisBlog: getBlogList:5
2019-12-30 00:29:54.632 [http-nio-8080-exec-6] INFO  com.lgq.controller.MenuController - FrancisBlog: getAllParentMenu
2019-12-30 00:29:54.639 [http-nio-8080-exec-7] INFO  com.lgq.controller.SiteController - FrancisBlog: getSiteInfo
2019-12-30 00:29:54.644 [http-nio-8080-exec-7] INFO  com.lgq.service.impl.SiteServiceImpl - DAY_PAGE_VIEW_PREFIX2019-12-30
2019-12-30 00:29:54.721 [http-nio-8080-exec-8] INFO  com.lgq.controller.SiteTagController - FrancisBlog: getAllSiteTag
2019-12-30 00:29:54.722 [http-nio-8080-exec-2] INFO  com.lgq.controller.AlbumController - FrancisBlog: getAllAlbum
2019-12-30 00:29:54.733 [http-nio-8080-exec-10] INFO  com.lgq.controller.SiteFriendLinkController - FrancisBlog: getAllSiteFriendLink
2019-12-30 00:29:54.768 [http-nio-8080-exec-3] INFO  com.lgq.controller.SiteController - FrancisBlog: getSiteInfo
2019-12-30 00:29:54.768 [http-nio-8080-exec-1] INFO  com.lgq.controller.AdvertisementController - FrancisBlog: getAllAdvertisement
2019-12-30 00:29:54.775 [http-nio-8080-exec-3] INFO  com.lgq.service.impl.SiteServiceImpl - DAY_PAGE_VIEW_PREFIX2019-12-30
2019-12-30 00:29:54.922 [http-nio-8080-exec-9] INFO  com.lgq.controller.SiteController - FrancisBlog: getSiteInfo
2019-12-30 00:29:54.926 [http-nio-8080-exec-9] INFO  com.lgq.service.impl.SiteServiceImpl - DAY_PAGE_VIEW_PREFIX2019-12-30
2019-12-30 00:29:55.025 [http-nio-8080-exec-6] INFO  com.lgq.controller.SiteIconController - FrancisBlog: getAllSiteIcon
2019-12-30 00:29:58.789 [http-nio-8080-exec-7] INFO  com.lgq.controller.SiteController - FrancisBlog: getSiteInfo
2019-12-30 00:29:58.792 [http-nio-8080-exec-7] INFO  com.lgq.service.impl.SiteServiceImpl - DAY_PAGE_VIEW_PREFIX2019-12-30
2019-12-30 00:29:58.798 [http-nio-8080-exec-10] INFO  com.lgq.controller.MenuController - FrancisBlog: getAllParentMenu
2019-12-30 00:29:58.800 [http-nio-8080-exec-4] INFO  com.lgq.controller.AlbumPictureController - FrancisBlog: getAlbumPictureByAlbumId: 7
2019-12-30 00:29:58.921 [http-nio-8080-exec-1] INFO  com.lgq.controller.SiteController - FrancisBlog: getSiteInfo
2019-12-30 00:29:58.927 [http-nio-8080-exec-1] INFO  com.lgq.service.impl.SiteServiceImpl - DAY_PAGE_VIEW_PREFIX2019-12-30
2019-12-30 00:30:11.701 [http-nio-8080-exec-1] INFO  com.lgq.controller.SiteController - FrancisBlog: getSiteInfo
2019-12-30 00:30:11.701 [http-nio-8080-exec-10] INFO  com.lgq.controller.AlbumPictureController - FrancisBlog: getAlbumPictureByAlbumId: 8
2019-12-30 00:30:11.701 [http-nio-8080-exec-4] INFO  com.lgq.controller.MenuController - FrancisBlog: getAllParentMenu
2019-12-30 00:30:11.705 [http-nio-8080-exec-1] INFO  com.lgq.service.impl.SiteServiceImpl - DAY_PAGE_VIEW_PREFIX2019-12-30
2019-12-30 00:30:11.823 [http-nio-8080-exec-3] INFO  com.lgq.controller.SiteController - FrancisBlog: getSiteInfo
2019-12-30 00:30:11.828 [http-nio-8080-exec-3] INFO  com.lgq.service.impl.SiteServiceImpl - DAY_PAGE_VIEW_PREFIX2019-12-30
2019-12-30 00:31:55.504 [http-nio-8080-exec-10] INFO  com.lgq.controller.TokenController - FrancisBlog: getToken
2019-12-30 00:31:55.517 [http-nio-8080-exec-2] INFO  com.lgq.controller.CategoryController - FrancisBlog: getAllCategory
2019-12-30 00:31:55.524 [http-nio-8080-exec-6] INFO  com.lgq.controller.TagController - FrancisBlog: getAllTag
2019-12-30 00:32:48.164 [http-nio-8080-exec-7] INFO  com.lgq.controller.BlogController - FrancisBlog: addBlog -> {"blogCategoryId":5,"blogContent":"<p>肥肥肥很爱瘦瘦瘦</p>\n","blogCover":"http://img.francisqiang.top/1577637116","blogSummary":"肥肥肥很肥肥肥","blogTitle":"我是肥肥肥","tags":[1,2]}
2019-12-30 00:32:48.609 [http-nio-8080-exec-8] INFO  com.lgq.controller.BlogController - FrancisBlog: getBlogList:1
2019-12-30 00:32:50.847 [http-nio-8080-exec-4] INFO  com.lgq.controller.BlogController - FrancisBlog: getBlogList:4
2019-12-30 00:33:44.791 [http-nio-8080-exec-2] INFO  com.lgq.controller.BlogController - FrancisBlog: getBlogById: blog_id:1
2019-12-30 00:33:44.917 [http-nio-8080-exec-2] INFO  com.lgq.service.impl.BlogServiceImpl - null
2019-12-30 00:33:44.933 [http-nio-8080-exec-2] INFO  com.lgq.service.impl.BlogServiceImpl - 121
2019-12-30 00:34:04.103 [http-nio-8080-exec-9] INFO  com.lgq.controller.TokenController - FrancisBlog: getToken
2019-12-30 00:34:04.118 [http-nio-8080-exec-5] INFO  com.lgq.controller.BlogController - FrancisBlog: getBlogById: blog_id:5
2019-12-30 00:34:04.128 [http-nio-8080-exec-5] INFO  com.lgq.service.impl.BlogServiceImpl - null
2019-12-30 00:34:04.138 [http-nio-8080-exec-7] INFO  com.lgq.controller.CategoryController - FrancisBlog: getAllCategory
2019-12-30 00:34:04.139 [http-nio-8080-exec-8] INFO  com.lgq.controller.TagController - FrancisBlog: getAllTag
2019-12-30 00:34:04.150 [http-nio-8080-exec-5] INFO  com.lgq.service.impl.BlogServiceImpl - 5
2019-12-30 00:34:06.685 [http-nio-8080-exec-4] INFO  com.lgq.controller.BlogController - FrancisBlog: getBlogList:1
2019-12-30 00:36:12.762 [http-nio-8080-exec-9] INFO  com.lgq.controller.TokenController - FrancisBlog: getToken
2019-12-30 00:36:12.771 [http-nio-8080-exec-7] INFO  com.lgq.controller.BlogController - FrancisBlog: getBlogById: blog_id:3
2019-12-30 00:36:12.772 [http-nio-8080-exec-8] INFO  com.lgq.controller.CategoryController - FrancisBlog: getAllCategory
2019-12-30 00:36:12.782 [http-nio-8080-exec-7] INFO  com.lgq.service.impl.BlogServiceImpl - null
2019-12-30 00:36:12.803 [http-nio-8080-exec-5] INFO  com.lgq.controller.TagController - FrancisBlog: getAllTag
2019-12-30 00:36:12.876 [http-nio-8080-exec-7] INFO  com.lgq.service.impl.BlogServiceImpl - 9
2019-12-30 00:36:12.910 [http-nio-8080-exec-4] INFO  com.lgq.controller.TokenController - FrancisBlog: getToken
2019-12-30 00:36:12.931 [http-nio-8080-exec-10] INFO  com.lgq.controller.TagController - FrancisBlog: getAllTag
2019-12-30 00:36:12.931 [http-nio-8080-exec-1] INFO  com.lgq.controller.CategoryController - FrancisBlog: getAllCategory
2019-12-30 00:36:12.990 [http-nio-8080-exec-3] INFO  com.lgq.controller.BlogController - FrancisBlog: getBlogById: blog_id:3
2019-12-30 00:36:13.080 [http-nio-8080-exec-3] INFO  com.lgq.service.impl.BlogServiceImpl - 1577637372786
2019-12-30 00:36:13.083 [http-nio-8080-exec-3] INFO  com.lgq.service.impl.BlogServiceImpl - 10
2019-12-30 00:36:16.544 [http-nio-8080-exec-2] INFO  com.lgq.controller.BlogController - FrancisBlog: getBlogList:1
2019-12-30 00:36:18.995 [http-nio-8080-exec-6] INFO  com.lgq.controller.BlogController - FrancisBlog: getBlogList:4
2019-12-30 00:36:20.980 [http-nio-8080-exec-9] INFO  com.lgq.controller.TokenController - FrancisBlog: getToken
2019-12-30 00:36:20.992 [http-nio-8080-exec-8] INFO  com.lgq.controller.BlogController - FrancisBlog: getBlogById: blog_id:13
2019-12-30 00:36:20.995 [http-nio-8080-exec-5] INFO  com.lgq.controller.CategoryController - FrancisBlog: getAllCategory
2019-12-30 00:36:21.000 [http-nio-8080-exec-4] INFO  com.lgq.controller.TagController - FrancisBlog: getAllTag
2019-12-30 00:36:21.002 [http-nio-8080-exec-8] INFO  com.lgq.service.impl.BlogServiceImpl - 1577637372786
2019-12-30 00:36:21.004 [http-nio-8080-exec-8] INFO  com.lgq.service.impl.BlogServiceImpl - 1
2019-12-30 00:36:23.255 [http-nio-8080-exec-1] INFO  com.lgq.controller.BlogController - FrancisBlog: getBlogList:1
2019-12-30 00:37:25.190 [lettuce-nioEventLoop-4-1] INFO  io.lettuce.core.protocol.CommandHandler - null Unexpected exception during request: java.io.IOException: 远程主机强迫关闭了一个现有的连接。
java.io.IOException: 远程主机强迫关闭了一个现有的连接。
	at sun.nio.ch.SocketDispatcher.read0(Native Method)
	at sun.nio.ch.SocketDispatcher.read(SocketDispatcher.java:43)
	at sun.nio.ch.IOUtil.readIntoNativeBuffer(IOUtil.java:223)
	at sun.nio.ch.IOUtil.read(IOUtil.java:192)
	at sun.nio.ch.SocketChannelImpl.read(SocketChannelImpl.java:380)
	at io.netty.buffer.PooledUnsafeDirectByteBuf.setBytes(PooledUnsafeDirectByteBuf.java:288)
	at io.netty.buffer.AbstractByteBuf.writeBytes(AbstractByteBuf.java:1125)
	at io.netty.channel.socket.nio.NioSocketChannel.doReadBytes(NioSocketChannel.java:347)
	at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:148)
	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:677)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:612)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:529)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:491)
	at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:905)
	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
	at java.lang.Thread.run(Thread.java:748)
2019-12-30 00:37:25.338 [lettuce-eventExecutorLoop-1-3] INFO  io.lettuce.core.protocol.ConnectionWatchdog - Reconnecting, last destination was /127.0.0.1:6379
2019-12-30 10:33:29.110 [main] INFO  com.lgq.FrancisBlogApplication - Starting FrancisBlogApplication on DESKTOP-G6KT9CH with PID 14544 (I:\blog_for_feifeifei\blog-for-feifeifei\target\classes started by lin in I:\blog_for_feifeifei\blog-for-feifeifei)
2019-12-30 10:33:29.141 [main] INFO  com.lgq.FrancisBlogApplication - No active profile set, falling back to default profiles: default
2019-12-30 10:33:31.909 [main] INFO  o.s.d.r.config.RepositoryConfigurationDelegate - Multiple Spring Data modules found, entering strict repository configuration mode!
2019-12-30 10:33:31.909 [main] INFO  o.s.d.r.config.RepositoryConfigurationDelegate - Bootstrapping Spring Data repositories in DEFAULT mode.
2019-12-30 10:33:31.999 [main] INFO  o.s.d.r.config.RepositoryConfigurationDelegate - Finished Spring Data repository scanning in 50ms. Found 0 repository interfaces.
2019-12-30 10:33:32.679 [main] INFO  o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker - Bean 'org.springframework.transaction.annotation.ProxyTransactionManagementConfiguration' of type [org.springframework.transaction.annotation.ProxyTransactionManagementConfiguration$$EnhancerBySpringCGLIB$$1718e434] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2019-12-30 10:33:33.398 [main] INFO  o.s.boot.web.embedded.tomcat.TomcatWebServer - Tomcat initialized with port(s): 8080 (http)
2019-12-30 10:33:33.428 [main] INFO  org.apache.coyote.http11.Http11NioProtocol - Initializing ProtocolHandler ["http-nio-8080"]
2019-12-30 10:33:33.438 [main] INFO  org.apache.catalina.core.StandardService - Starting service [Tomcat]
2019-12-30 10:33:33.438 [main] INFO  org.apache.catalina.core.StandardEngine - Starting Servlet engine: [Apache Tomcat/9.0.17]
2019-12-30 10:33:33.438 [main] INFO  org.apache.catalina.core.AprLifecycleListener - An older version [1.2.17] of the APR based Apache Tomcat Native library is installed, while Tomcat recommends a minimum version of [1.2.21]
2019-12-30 10:33:33.438 [main] INFO  org.apache.catalina.core.AprLifecycleListener - Loaded APR based Apache Tomcat Native library [1.2.17] using APR version [1.6.3].
2019-12-30 10:33:33.438 [main] INFO  org.apache.catalina.core.AprLifecycleListener - APR capabilities: IPv6 [true], sendfile [true], accept filters [false], random [true].
2019-12-30 10:33:33.438 [main] INFO  org.apache.catalina.core.AprLifecycleListener - APR/OpenSSL configuration: useAprConnector [false], useOpenSSL [true]
2019-12-30 10:33:34.548 [main] INFO  org.apache.catalina.core.AprLifecycleListener - OpenSSL successfully initialized [OpenSSL 1.0.2o  27 Mar 2018]
2019-12-30 10:33:34.777 [main] INFO  o.a.c.c.C.[.[localhost].[/francisblog/api/v1] - Initializing Spring embedded WebApplicationContext
2019-12-30 10:33:34.777 [main] INFO  org.springframework.web.context.ContextLoader - Root WebApplicationContext: initialization completed in 5547 ms
2019-12-30 10:33:36.626 [main] INFO  s.d.s.w.PropertySourcedRequestMappingHandlerMapping - Mapped URL path [/v2/api-docs] onto method [public org.springframework.http.ResponseEntity<springfox.documentation.spring.web.json.Json> springfox.documentation.swagger2.web.Swagger2Controller.getDocumentation(java.lang.String,javax.servlet.http.HttpServletRequest)]
2019-12-30 10:33:36.806 [main] INFO  o.s.scheduling.concurrent.ThreadPoolTaskExecutor - Initializing ExecutorService 'applicationTaskExecutor'
2019-12-30 10:33:37.106 [main] INFO  s.d.s.web.plugins.DocumentationPluginsBootstrapper - Context refreshed
2019-12-30 10:33:37.146 [main] INFO  s.d.s.web.plugins.DocumentationPluginsBootstrapper - Found 1 custom documentation plugin(s)
2019-12-30 10:33:37.196 [main] INFO  s.d.spring.web.scanners.ApiListingReferenceScanner - Scanning for api listing references
2019-12-30 10:33:37.336 [main] INFO  s.d.s.w.r.operation.CachingOperationNameGenerator - Generating unique operation named: getAllAlbumUsingGET_1
2019-12-30 10:33:37.446 [main] INFO  org.apache.coyote.http11.Http11NioProtocol - Starting ProtocolHandler ["http-nio-8080"]
2019-12-30 10:33:37.466 [main] INFO  o.s.boot.web.embedded.tomcat.TomcatWebServer - Tomcat started on port(s): 8080 (http) with context path '/francisblog/api/v1'
2019-12-30 10:33:37.466 [main] INFO  com.lgq.FrancisBlogApplication - Started FrancisBlogApplication in 9.525 seconds (JVM running for 13.419)
2019-12-30 10:41:21.138 [http-nio-8080-exec-1] INFO  o.a.c.c.C.[.[localhost].[/francisblog/api/v1] - Initializing Spring DispatcherServlet 'dispatcherServlet'
2019-12-30 10:41:21.138 [http-nio-8080-exec-1] INFO  org.springframework.web.servlet.DispatcherServlet - Initializing Servlet 'dispatcherServlet'
2019-12-30 10:41:21.147 [http-nio-8080-exec-1] INFO  org.springframework.web.servlet.DispatcherServlet - Completed initialization in 0 ms
2019-12-30 10:41:21.287 [http-nio-8080-exec-1] INFO  com.lgq.controller.BlogController - FrancisBlog: getBlogList:1
2019-12-30 10:41:21.477 [http-nio-8080-exec-1] INFO  com.alibaba.druid.pool.DruidDataSource - {dataSource-1} inited
2019-12-30 10:41:22.127 [http-nio-8080-exec-5] INFO  com.lgq.controller.SiteIconController - FrancisBlog: getAllSiteIcon
2019-12-30 10:41:22.127 [http-nio-8080-exec-2] INFO  com.lgq.controller.SiteController - FrancisBlog: getSiteInfo
2019-12-30 10:41:22.127 [http-nio-8080-exec-4] INFO  com.lgq.controller.SiteTagController - FrancisBlog: getAllSiteTag
2019-12-30 10:41:22.127 [http-nio-8080-exec-3] INFO  com.lgq.controller.MenuController - FrancisBlog: getAllParentMenu
2019-12-30 10:41:22.127 [http-nio-8080-exec-6] INFO  com.lgq.controller.SiteFriendLinkController - FrancisBlog: getAllSiteFriendLink
2019-12-30 10:41:23.056 [http-nio-8080-exec-7] INFO  com.lgq.controller.AdvertisementController - FrancisBlog: getAllAdvertisement
2019-12-30 10:41:23.246 [http-nio-8080-exec-2] INFO  io.lettuce.core.EpollProvider - Starting without optional epoll library
2019-12-30 10:41:23.246 [http-nio-8080-exec-2] INFO  io.lettuce.core.KqueueProvider - Starting without optional kqueue library
2019-12-30 10:41:25.245 [http-nio-8080-exec-2] INFO  com.lgq.service.impl.SiteServiceImpl - DAY_PAGE_VIEW_PREFIX2019-12-30
2019-12-30 10:41:25.275 [http-nio-8080-exec-8] INFO  com.lgq.controller.SiteController - FrancisBlog: getSiteInfo
2019-12-30 10:41:25.275 [http-nio-8080-exec-8] INFO  com.lgq.service.impl.SiteServiceImpl - DAY_PAGE_VIEW_PREFIX2019-12-30
2019-12-30 10:41:25.305 [http-nio-8080-exec-9] INFO  com.lgq.controller.SiteController - FrancisBlog: getSiteInfo
2019-12-30 10:41:25.305 [http-nio-8080-exec-9] INFO  com.lgq.service.impl.SiteServiceImpl - DAY_PAGE_VIEW_PREFIX2019-12-30
2019-12-30 10:41:56.896 [http-nio-8080-exec-10] INFO  com.lgq.controller.SiteController - FrancisBlog: getSiteInfo
2019-12-30 10:41:56.896 [http-nio-8080-exec-5] INFO  com.lgq.controller.MenuController - FrancisBlog: getAllParentMenu
2019-12-30 10:41:56.896 [http-nio-8080-exec-10] INFO  com.lgq.service.impl.SiteServiceImpl - DAY_PAGE_VIEW_PREFIX2019-12-30
2019-12-30 10:41:56.916 [http-nio-8080-exec-4] INFO  com.lgq.controller.SiteController - FrancisBlog: getSiteInfo
2019-12-30 10:41:56.916 [http-nio-8080-exec-4] INFO  com.lgq.service.impl.SiteServiceImpl - DAY_PAGE_VIEW_PREFIX2019-12-30
2019-12-30 10:42:15.846 [http-nio-8080-exec-10] INFO  com.lgq.controller.UserController - FrancisBlog: signIn -> {"userAccount":"1326338672","userPassword":"12345"}
2019-12-30 10:45:42.361 [http-nio-8080-exec-5] INFO  com.lgq.controller.TagController - FrancisBlog: getAllTag
2019-12-30 10:45:43.350 [http-nio-8080-exec-8] INFO  com.lgq.controller.SiteIconController - FrancisBlog: getAllSiteIcon
2019-12-30 10:45:44.070 [http-nio-8080-exec-1] INFO  com.lgq.controller.SiteFriendLinkController - FrancisBlog: getAllSiteFriendLink
2019-12-30 10:45:44.760 [http-nio-8080-exec-6] INFO  com.lgq.controller.AdvertisementController - FrancisBlog: getAllAdvertisement
2019-12-30 10:45:45.569 [http-nio-8080-exec-2] INFO  com.lgq.controller.SiteController - FrancisBlog: getSiteInfo
2019-12-30 10:45:45.579 [http-nio-8080-exec-2] INFO  com.lgq.service.impl.SiteServiceImpl - DAY_PAGE_VIEW_PREFIX2019-12-30
2019-12-30 10:45:47.098 [http-nio-8080-exec-7] INFO  com.lgq.controller.AlbumController - FrancisBlog: getAllAlbum
2019-12-30 10:45:48.917 [http-nio-8080-exec-3] INFO  com.lgq.controller.AlbumPictureController - FrancisBlog: getAllAlbum
2019-12-30 10:45:48.927 [http-nio-8080-exec-10] INFO  com.lgq.controller.AlbumController - FrancisBlog: getAllAlbum
2019-12-30 10:45:58.662 [http-nio-8080-exec-9] INFO  com.lgq.controller.TokenController - FrancisBlog: getToken
2019-12-30 10:46:08.287 [http-nio-8080-exec-5] INFO  com.lgq.controller.AlbumPictureController - FrancisBlog: getAllAlbum
2019-12-30 10:46:08.287 [http-nio-8080-exec-4] INFO  com.lgq.controller.AlbumController - FrancisBlog: getAllAlbum
2019-12-30 10:46:10.726 [http-nio-8080-exec-8] INFO  com.lgq.controller.MenuController - FrancisBlog: getAllMenu
2019-12-30 10:46:13.404 [http-nio-8080-exec-1] INFO  com.lgq.controller.UserController - FrancisBlog: getAllUser
2019-12-30 10:46:17.642 [http-nio-8080-exec-6] INFO  com.lgq.controller.UserController - FrancisBlog: getAllUser
2019-12-30 10:46:36.922 [http-nio-8080-exec-3] INFO  com.lgq.controller.MenuController - FrancisBlog: getAllParentMenu
2019-12-30 10:46:36.922 [http-nio-8080-exec-10] INFO  com.lgq.controller.SiteController - FrancisBlog: getSiteInfo
2019-12-30 10:46:36.922 [http-nio-8080-exec-10] INFO  com.lgq.service.impl.SiteServiceImpl - DAY_PAGE_VIEW_PREFIX2019-12-30
2019-12-30 10:46:36.932 [http-nio-8080-exec-9] INFO  com.lgq.controller.SiteController - FrancisBlog: getSiteInfo
2019-12-30 10:46:36.932 [http-nio-8080-exec-9] INFO  com.lgq.service.impl.SiteServiceImpl - DAY_PAGE_VIEW_PREFIX2019-12-30
2019-12-30 10:53:17.578 [http-nio-8080-exec-1] INFO  com.lgq.controller.SiteController - FrancisBlog: getSiteInfo
2019-12-30 10:53:17.578 [http-nio-8080-exec-8] INFO  com.lgq.controller.BlogController - FrancisBlog: getBlogList:1
2019-12-30 10:53:17.587 [http-nio-8080-exec-1] INFO  com.lgq.service.impl.SiteServiceImpl - DAY_PAGE_VIEW_PREFIX2019-12-30
2019-12-30 10:53:17.587 [http-nio-8080-exec-6] INFO  com.lgq.controller.MenuController - FrancisBlog: getAllParentMenu
2019-12-30 10:53:17.587 [http-nio-8080-exec-1] INFO  com.lgq.controller.SiteTagController - FrancisBlog: getAllSiteTag
2019-12-30 10:53:17.587 [http-nio-8080-exec-2] INFO  com.lgq.controller.SiteIconController - FrancisBlog: getAllSiteIcon
2019-12-30 10:53:17.587 [http-nio-8080-exec-7] INFO  com.lgq.controller.SiteFriendLinkController - FrancisBlog: getAllSiteFriendLink
2019-12-30 10:53:17.597 [http-nio-8080-exec-10] INFO  com.lgq.controller.AdvertisementController - FrancisBlog: getAllAdvertisement
2019-12-30 10:53:17.597 [http-nio-8080-exec-9] INFO  com.lgq.controller.SiteController - FrancisBlog: getSiteInfo
2019-12-30 10:53:17.607 [http-nio-8080-exec-9] INFO  com.lgq.service.impl.SiteServiceImpl - DAY_PAGE_VIEW_PREFIX2019-12-30
2019-12-30 10:53:17.647 [http-nio-8080-exec-4] INFO  com.lgq.controller.SiteController - FrancisBlog: getSiteInfo
2019-12-30 10:53:17.647 [http-nio-8080-exec-4] INFO  com.lgq.service.impl.SiteServiceImpl - DAY_PAGE_VIEW_PREFIX2019-12-30
2019-12-30 10:53:29.912 [http-nio-8080-exec-1] INFO  com.lgq.controller.SiteController - FrancisBlog: getSiteInfo
2019-12-30 10:53:29.912 [http-nio-8080-exec-2] INFO  com.lgq.controller.MenuController - FrancisBlog: getAllParentMenu
2019-12-30 10:53:29.912 [http-nio-8080-exec-1] INFO  com.lgq.service.impl.SiteServiceImpl - DAY_PAGE_VIEW_PREFIX2019-12-30
2019-12-30 10:53:29.932 [http-nio-8080-exec-3] INFO  com.lgq.controller.SiteController - FrancisBlog: getSiteInfo
2019-12-30 10:53:29.932 [http-nio-8080-exec-3] INFO  com.lgq.service.impl.SiteServiceImpl - DAY_PAGE_VIEW_PREFIX2019-12-30
2019-12-30 10:53:42.344 [http-nio-8080-exec-5] INFO  com.lgq.controller.UserController - FrancisBlog: signIn -> {"userAccount":"1326338672","userPassword":"12345"}
2019-12-30 10:53:45.872 [http-nio-8080-exec-8] INFO  com.lgq.controller.CategoryController - FrancisBlog: getAllCategory
2019-12-30 10:53:48.341 [http-nio-8080-exec-2] INFO  com.lgq.controller.SiteController - FrancisBlog: getSiteViewTrend
2019-12-30 10:53:48.341 [http-nio-8080-exec-1] INFO  com.lgq.controller.BlogController - FrancisBlog: getBlogCategoryNum
2019-12-30 10:53:48.341 [http-nio-8080-exec-10] INFO  com.lgq.controller.BlogCommentController - FrancisBlog: getLatestComment
2019-12-30 10:53:48.341 [http-nio-8080-exec-3] INFO  com.lgq.controller.BlogController - FrancisBlog: getDateNum
2019-12-30 10:53:48.341 [http-nio-8080-exec-6] INFO  com.lgq.controller.BlogController - FrancisBlog: getBlogViewNum
2019-12-30 10:54:33.577 [http-nio-8080-exec-9] INFO  com.lgq.controller.SiteTagController - FrancisBlog: getAllSiteTag
2019-12-30 10:54:35.905 [http-nio-8080-exec-4] INFO  com.lgq.controller.TagController - FrancisBlog: getAllTag
2019-12-30 10:54:36.675 [http-nio-8080-exec-5] INFO  com.lgq.controller.SiteTagController - FrancisBlog: getAllSiteTag
2019-12-30 10:54:38.314 [http-nio-8080-exec-8] INFO  com.lgq.controller.TagController - FrancisBlog: getAllTag
2019-12-30 10:54:39.214 [http-nio-8080-exec-1] INFO  com.lgq.controller.SiteIconController - FrancisBlog: getAllSiteIcon
2019-12-30 10:54:41.842 [http-nio-8080-exec-3] INFO  com.lgq.controller.AlbumController - FrancisBlog: getAllAlbum
2019-12-30 10:54:41.842 [http-nio-8080-exec-6] INFO  com.lgq.controller.AlbumPictureController - FrancisBlog: getAllAlbum
2019-12-30 10:54:48.479 [http-nio-8080-exec-2] INFO  com.lgq.controller.CategoryController - FrancisBlog: getAllCategory
2019-12-30 10:54:50.717 [http-nio-8080-exec-4] INFO  com.lgq.controller.MenuController - FrancisBlog: getAllMenu
2019-12-30 10:54:52.776 [http-nio-8080-exec-5] INFO  com.lgq.controller.CategoryController - FrancisBlog: getAllCategory
2019-12-30 10:54:54.605 [http-nio-8080-exec-8] INFO  com.lgq.controller.MenuController - FrancisBlog: getAllMenu
2019-12-30 10:54:56.145 [http-nio-8080-exec-1] INFO  com.lgq.controller.MenuController - FrancisBlog: getAllParentMenu
2019-12-30 10:55:05.040 [http-nio-8080-exec-3] INFO  com.lgq.controller.MenuController - FrancisBlog: addMenu -> {"menuDescription":"啊啊啊","menuName":"啊啊啊","menuPid":6}
2019-12-30 10:55:05.380 [http-nio-8080-exec-2] INFO  com.lgq.controller.MenuController - FrancisBlog: getAllMenu
2019-12-30 10:55:05.380 [http-nio-8080-exec-7] INFO  com.lgq.controller.MenuController - FrancisBlog: getAllParentMenu
2019-12-30 10:55:08.408 [http-nio-8080-exec-10] INFO  com.lgq.controller.MenuController - FrancisBlog: getAllParentMenu
2019-12-30 10:55:16.004 [http-nio-8080-exec-4] INFO  com.lgq.controller.MenuController - FrancisBlog: updateMenu -> {"menuDescription":"肥肥肥","menuId":6,"menuName":"肥肥","menuPid":6}
2019-12-30 10:55:16.474 [http-nio-8080-exec-8] INFO  com.lgq.controller.MenuController - FrancisBlog: getAllParentMenu
2019-12-30 10:55:16.474 [http-nio-8080-exec-5] INFO  com.lgq.controller.MenuController - FrancisBlog: getAllMenu
2019-12-30 10:55:23.480 [http-nio-8080-exec-1] INFO  com.lgq.controller.SiteController - FrancisBlog: getSiteInfo
2019-12-30 10:55:23.480 [http-nio-8080-exec-6] INFO  com.lgq.controller.MenuController - FrancisBlog: getAllParentMenu
2019-12-30 10:55:23.480 [http-nio-8080-exec-1] INFO  com.lgq.service.impl.SiteServiceImpl - DAY_PAGE_VIEW_PREFIX2019-12-30
2019-12-30 10:55:23.480 [http-nio-8080-exec-3] INFO  com.lgq.controller.MenuController - FrancisBlog: getAllMenu
2019-12-30 10:55:23.490 [http-nio-8080-exec-7] INFO  com.lgq.controller.SiteController - FrancisBlog: getSiteInfo
2019-12-30 10:55:23.490 [http-nio-8080-exec-7] INFO  com.lgq.service.impl.SiteServiceImpl - DAY_PAGE_VIEW_PREFIX2019-12-30
2019-12-30 10:55:25.629 [http-nio-8080-exec-2] INFO  com.lgq.controller.MenuController - FrancisBlog: getAllMenu
2019-12-30 10:55:26.438 [http-nio-8080-exec-10] INFO  com.lgq.controller.MenuController - FrancisBlog: getAllMenu
2019-12-30 10:55:27.638 [http-nio-8080-exec-9] INFO  com.lgq.controller.MenuController - FrancisBlog: getAllMenu
2019-12-30 10:55:28.577 [http-nio-8080-exec-4] INFO  com.lgq.controller.MenuController - FrancisBlog: getAllMenu
2019-12-30 10:55:29.437 [http-nio-8080-exec-8] INFO  com.lgq.controller.MenuController - FrancisBlog: getAllMenu
2019-12-30 10:55:31.086 [http-nio-8080-exec-5] INFO  com.lgq.controller.MenuController - FrancisBlog: getAllMenu
2019-12-30 10:55:35.803 [http-nio-8080-exec-2] INFO  com.lgq.controller.MenuController - FrancisBlog: getAllMenu
2019-12-30 10:55:36.953 [http-nio-8080-exec-10] INFO  com.lgq.controller.MenuController - FrancisBlog: getAllMenu
2019-12-30 10:55:37.802 [http-nio-8080-exec-9] INFO  com.lgq.controller.MenuController - FrancisBlog: getAllMenu
2019-12-30 10:55:43.469 [http-nio-8080-exec-4] INFO  com.lgq.controller.MenuController - FrancisBlog: getAllParentMenu
2019-12-30 10:55:54.380 [http-nio-8080-exec-5] INFO  com.lgq.controller.MenuController - FrancisBlog: getAllParentMenu
2019-12-30 10:55:54.380 [http-nio-8080-exec-8] INFO  com.lgq.controller.SiteController - FrancisBlog: getSiteInfo
2019-12-30 10:55:54.382 [http-nio-8080-exec-3] INFO  com.lgq.controller.MenuController - FrancisBlog: getAllMenu
2019-12-30 10:55:54.386 [http-nio-8080-exec-8] INFO  com.lgq.service.impl.SiteServiceImpl - DAY_PAGE_VIEW_PREFIX2019-12-30
2019-12-30 10:55:54.396 [http-nio-8080-exec-6] INFO  com.lgq.controller.SiteController - FrancisBlog: getSiteInfo
2019-12-30 10:55:54.399 [http-nio-8080-exec-6] INFO  com.lgq.service.impl.SiteServiceImpl - DAY_PAGE_VIEW_PREFIX2019-12-30
2019-12-30 10:55:56.044 [http-nio-8080-exec-7] INFO  com.lgq.controller.MenuController - FrancisBlog: getAllParentMenu
2019-12-30 10:56:03.824 [http-nio-8080-exec-3] INFO  com.lgq.controller.BlogCommentController - FrancisBlog: getAllBlogComment
2019-12-30 10:56:09.107 [http-nio-8080-exec-8] INFO  com.lgq.controller.UserController - FrancisBlog: getAllUser
2019-12-30 10:56:10.425 [http-nio-8080-exec-6] INFO  com.lgq.controller.BlogCommentController - FrancisBlog: getAllBlogComment
2019-12-30 10:56:48.144 [http-nio-8080-exec-7] INFO  com.lgq.controller.BlogController - FrancisBlog: getBlogList:1
2019-12-30 10:56:53.197 [http-nio-8080-exec-10] INFO  com.lgq.controller.BlogController - FrancisBlog: getBlogList:4
2019-12-30 10:56:54.808 [http-nio-8080-exec-1] INFO  com.lgq.controller.BlogController - FrancisBlog: getBlogList:3
2019-12-30 10:56:56.117 [http-nio-8080-exec-5] INFO  com.lgq.controller.BlogController - FrancisBlog: getBlogList:2
2019-12-30 10:56:57.218 [http-nio-8080-exec-4] INFO  com.lgq.controller.BlogController - FrancisBlog: getBlogList:1
2019-12-30 10:56:58.244 [http-nio-8080-exec-3] INFO  com.lgq.controller.BlogController - FrancisBlog: getBlogList:2
2019-12-30 10:56:59.387 [http-nio-8080-exec-8] INFO  com.lgq.controller.BlogController - FrancisBlog: getBlogList:3
2019-12-30 10:56:59.910 [http-nio-8080-exec-6] INFO  com.lgq.controller.BlogController - FrancisBlog: getBlogList:4
2019-12-30 10:57:02.666 [http-nio-8080-exec-7] INFO  com.lgq.controller.BlogController - FrancisBlog: getBlogList:3
2019-12-30 10:57:05.719 [http-nio-8080-exec-10] INFO  com.lgq.controller.TokenController - FrancisBlog: getToken
2019-12-30 10:57:05.732 [http-nio-8080-exec-9] INFO  com.lgq.controller.TagController - FrancisBlog: getAllTag
2019-12-30 10:57:05.732 [http-nio-8080-exec-2] INFO  com.lgq.controller.CategoryController - FrancisBlog: getAllCategory
2019-12-30 10:57:29.253 [http-nio-8080-exec-4] INFO  com.lgq.controller.BlogController - FrancisBlog: getBlogList:1
2019-12-30 10:57:30.091 [http-nio-8080-exec-3] INFO  com.lgq.controller.BlogCommentController - FrancisBlog: getAllBlogComment
2019-12-30 10:57:30.844 [http-nio-8080-exec-8] INFO  com.lgq.controller.UserController - FrancisBlog: getAllUser
2019-12-30 10:57:31.931 [http-nio-8080-exec-6] INFO  com.lgq.controller.BlogCommentController - FrancisBlog: getAllBlogComment
2019-12-30 10:57:33.356 [http-nio-8080-exec-7] INFO  com.lgq.controller.MenuController - FrancisBlog: getAllMenu
2019-12-30 10:57:34.541 [http-nio-8080-exec-10] INFO  com.lgq.controller.CategoryController - FrancisBlog: getAllCategory
2019-12-30 10:57:35.291 [http-nio-8080-exec-9] INFO  com.lgq.controller.MenuController - FrancisBlog: getAllMenu
2019-12-30 10:57:35.856 [http-nio-8080-exec-2] INFO  com.lgq.controller.CategoryController - FrancisBlog: getAllCategory
2019-12-30 10:57:44.686 [http-nio-8080-exec-7] INFO  com.lgq.controller.SiteController - FrancisBlog: getSiteInfo
2019-12-30 10:57:44.686 [http-nio-8080-exec-10] INFO  com.lgq.controller.MenuController - FrancisBlog: getAllParentMenu
2019-12-30 10:57:44.689 [http-nio-8080-exec-7] INFO  com.lgq.service.impl.SiteServiceImpl - DAY_PAGE_VIEW_PREFIX2019-12-30
2019-12-30 10:57:44.702 [http-nio-8080-exec-9] INFO  com.lgq.controller.SiteController - FrancisBlog: getSiteInfo
2019-12-30 10:57:44.704 [http-nio-8080-exec-9] INFO  com.lgq.service.impl.SiteServiceImpl - DAY_PAGE_VIEW_PREFIX2019-12-30
2019-12-30 10:57:56.523 [http-nio-8080-exec-2] INFO  com.lgq.controller.UserController - FrancisBlog: signIn -> {"userAccount":"1326338672","userPassword":"12345"}
2019-12-30 10:58:01.059 [http-nio-8080-exec-4] INFO  com.lgq.controller.TagController - FrancisBlog: getAllTag
2019-12-30 10:58:02.093 [http-nio-8080-exec-1] INFO  com.lgq.controller.SiteFriendLinkController - FrancisBlog: getAllSiteFriendLink
2019-12-30 10:58:02.767 [http-nio-8080-exec-5] INFO  com.lgq.controller.AlbumController - FrancisBlog: getAllAlbum
2019-12-30 10:58:03.697 [http-nio-8080-exec-3] INFO  com.lgq.controller.UserController - FrancisBlog: getAllUser
2019-12-30 10:58:08.123 [http-nio-8080-exec-8] INFO  com.lgq.controller.BlogCommentController - FrancisBlog: getAllBlogComment
2019-12-30 10:58:10.998 [http-nio-8080-exec-6] INFO  com.lgq.controller.BlogController - FrancisBlog: getBlogList:1
2019-12-30 10:58:13.199 [http-nio-8080-exec-10] INFO  com.lgq.controller.SiteController - FrancisBlog: getSiteInfo
2019-12-30 10:58:13.202 [http-nio-8080-exec-10] INFO  com.lgq.service.impl.SiteServiceImpl - DAY_PAGE_VIEW_PREFIX2019-12-30
2019-12-30 10:58:16.663 [http-nio-8080-exec-7] INFO  com.lgq.controller.SiteController - FrancisBlog: getSiteInfo
2019-12-30 10:58:16.663 [http-nio-8080-exec-9] INFO  com.lgq.controller.MenuController - FrancisBlog: getAllParentMenu
2019-12-30 10:58:16.665 [http-nio-8080-exec-7] INFO  com.lgq.service.impl.SiteServiceImpl - DAY_PAGE_VIEW_PREFIX2019-12-30
2019-12-30 10:58:16.677 [http-nio-8080-exec-2] INFO  com.lgq.controller.SiteController - FrancisBlog: getSiteInfo
2019-12-30 10:58:16.679 [http-nio-8080-exec-2] INFO  com.lgq.service.impl.SiteServiceImpl - DAY_PAGE_VIEW_PREFIX2019-12-30
2019-12-30 10:58:16.691 [http-nio-8080-exec-4] INFO  com.lgq.controller.SiteController - FrancisBlog: getSiteInfo
2019-12-30 10:58:16.693 [http-nio-8080-exec-4] INFO  com.lgq.service.impl.SiteServiceImpl - DAY_PAGE_VIEW_PREFIX2019-12-30
2019-12-30 10:58:22.327 [http-nio-8080-exec-1] INFO  com.lgq.controller.TagController - FrancisBlog: getAllTag
2019-12-30 10:58:42.984 [http-nio-8080-exec-8] INFO  com.lgq.controller.SiteController - FrancisBlog: getSiteInfo
2019-12-30 10:58:42.986 [http-nio-8080-exec-8] INFO  com.lgq.service.impl.SiteServiceImpl - DAY_PAGE_VIEW_PREFIX2019-12-30
2019-12-30 10:58:49.530 [http-nio-8080-exec-10] INFO  com.lgq.controller.SiteController - FrancisBlog: getSiteInfo
2019-12-30 10:58:49.530 [http-nio-8080-exec-6] INFO  com.lgq.controller.BlogController - FrancisBlog: getBlogList:1
2019-12-30 10:58:49.533 [http-nio-8080-exec-10] INFO  com.lgq.service.impl.SiteServiceImpl - DAY_PAGE_VIEW_PREFIX2019-12-30
2019-12-30 10:58:49.535 [http-nio-8080-exec-9] INFO  com.lgq.controller.MenuController - FrancisBlog: getAllParentMenu
2019-12-30 10:58:49.541 [http-nio-8080-exec-7] INFO  com.lgq.controller.SiteTagController - FrancisBlog: getAllSiteTag
2019-12-30 10:58:49.541 [http-nio-8080-exec-2] INFO  com.lgq.controller.SiteIconController - FrancisBlog: getAllSiteIcon
2019-12-30 10:58:49.544 [http-nio-8080-exec-4] INFO  com.lgq.controller.SiteFriendLinkController - FrancisBlog: getAllSiteFriendLink
2019-12-30 10:58:49.545 [http-nio-8080-exec-1] INFO  com.lgq.controller.AdvertisementController - FrancisBlog: getAllAdvertisement
2019-12-30 10:58:49.549 [http-nio-8080-exec-3] INFO  com.lgq.controller.SiteController - FrancisBlog: getSiteInfo
2019-12-30 10:58:49.552 [http-nio-8080-exec-3] INFO  com.lgq.service.impl.SiteServiceImpl - DAY_PAGE_VIEW_PREFIX2019-12-30
2019-12-30 10:58:49.562 [http-nio-8080-exec-5] INFO  com.lgq.controller.SiteController - FrancisBlog: getSiteInfo
2019-12-30 10:58:49.565 [http-nio-8080-exec-5] INFO  com.lgq.service.impl.SiteServiceImpl - DAY_PAGE_VIEW_PREFIX2019-12-30
2019-12-30 10:58:57.029 [http-nio-8080-exec-7] INFO  com.lgq.controller.MenuController - FrancisBlog: getAllParentMenu
2019-12-30 10:58:57.030 [http-nio-8080-exec-2] INFO  com.lgq.controller.BlogController - FrancisBlog: getBlogById: blog_id:3
2019-12-30 10:58:57.029 [http-nio-8080-exec-9] INFO  com.lgq.controller.SiteController - FrancisBlog: getSiteInfo
2019-12-30 10:58:57.033 [http-nio-8080-exec-9] INFO  com.lgq.service.impl.SiteServiceImpl - DAY_PAGE_VIEW_PREFIX2019-12-30
2019-12-30 10:58:57.052 [http-nio-8080-exec-4] INFO  com.lgq.controller.SiteController - FrancisBlog: getSiteInfo
2019-12-30 10:58:57.055 [http-nio-8080-exec-4] INFO  com.lgq.service.impl.SiteServiceImpl - DAY_PAGE_VIEW_PREFIX2019-12-30
2019-12-30 10:58:57.063 [http-nio-8080-exec-2] INFO  com.lgq.service.impl.BlogServiceImpl - null
2019-12-30 10:58:57.181 [http-nio-8080-exec-2] INFO  com.lgq.service.impl.BlogServiceImpl - 9
2019-12-30 10:59:16.112 [http-nio-8080-exec-5] INFO  com.lgq.controller.SiteTagController - FrancisBlog: getAllSiteTag
2019-12-30 10:59:16.114 [http-nio-8080-exec-10] INFO  com.lgq.controller.SiteFriendLinkController - FrancisBlog: getAllSiteFriendLink
2019-12-30 10:59:16.114 [http-nio-8080-exec-1] INFO  com.lgq.controller.BlogController - FrancisBlog: getBlogList:1
2019-12-30 10:59:16.112 [http-nio-8080-exec-8] INFO  com.lgq.controller.SiteIconController - FrancisBlog: getAllSiteIcon
2019-12-30 10:59:16.114 [http-nio-8080-exec-6] INFO  com.lgq.controller.AdvertisementController - FrancisBlog: getAllAdvertisement
2019-12-30 10:59:16.112 [http-nio-8080-exec-3] INFO  com.lgq.controller.SiteController - FrancisBlog: getSiteInfo
2019-12-30 10:59:16.119 [http-nio-8080-exec-3] INFO  com.lgq.service.impl.SiteServiceImpl - DAY_PAGE_VIEW_PREFIX2019-12-30
2019-12-30 10:59:18.729 [http-nio-8080-exec-7] INFO  com.lgq.controller.BlogController - FrancisBlog: getBlogList:2
2019-12-30 10:59:23.526 [http-nio-8080-exec-9] INFO  com.lgq.controller.SiteController - FrancisBlog: getSiteInfo
2019-12-30 10:59:23.526 [http-nio-8080-exec-2] INFO  com.lgq.controller.BlogController - FrancisBlog: getBlogById: blog_id:1
2019-12-30 10:59:23.526 [http-nio-8080-exec-4] INFO  com.lgq.controller.MenuController - FrancisBlog: getAllParentMenu
2019-12-30 10:59:23.528 [http-nio-8080-exec-9] INFO  com.lgq.service.impl.SiteServiceImpl - DAY_PAGE_VIEW_PREFIX2019-12-30
2019-12-30 10:59:23.539 [http-nio-8080-exec-5] INFO  com.lgq.controller.SiteController - FrancisBlog: getSiteInfo
2019-12-30 10:59:23.541 [http-nio-8080-exec-5] INFO  com.lgq.service.impl.SiteServiceImpl - DAY_PAGE_VIEW_PREFIX2019-12-30
2019-12-30 10:59:23.628 [http-nio-8080-exec-2] INFO  com.lgq.service.impl.BlogServiceImpl - null
2019-12-30 10:59:23.632 [http-nio-8080-exec-2] INFO  com.lgq.service.impl.BlogServiceImpl - 121
2019-12-30 11:00:05.413 [http-nio-8080-exec-4] INFO  com.lgq.controller.SiteController - FrancisBlog: getSiteInfo
2019-12-30 11:00:05.415 [http-nio-8080-exec-4] INFO  com.lgq.service.impl.SiteServiceImpl - DAY_PAGE_VIEW_PREFIX2019-12-30
2019-12-30 11:00:05.421 [http-nio-8080-exec-9] INFO  com.lgq.controller.MenuController - FrancisBlog: getAllParentMenu
2019-12-30 11:00:05.421 [http-nio-8080-exec-5] INFO  com.lgq.controller.BlogController - FrancisBlog: getBlogById: blog_id:10
2019-12-30 11:00:05.426 [http-nio-8080-exec-5] INFO  com.lgq.service.impl.BlogServiceImpl - null
2019-12-30 11:00:05.430 [http-nio-8080-exec-2] INFO  com.lgq.controller.SiteController - FrancisBlog: getSiteInfo
2019-12-30 11:00:05.433 [http-nio-8080-exec-2] INFO  com.lgq.service.impl.SiteServiceImpl - DAY_PAGE_VIEW_PREFIX2019-12-30
2019-12-30 11:00:05.449 [http-nio-8080-exec-5] INFO  com.lgq.service.impl.BlogServiceImpl - 2
2019-12-30 11:00:14.265 [http-nio-8080-exec-6] INFO  com.lgq.controller.MenuController - FrancisBlog: getAllParentMenu
2019-12-30 11:00:14.265 [http-nio-8080-exec-10] INFO  com.lgq.controller.SiteController - FrancisBlog: getSiteInfo
2019-12-30 11:00:14.265 [http-nio-8080-exec-3] INFO  com.lgq.controller.BlogController - FrancisBlog: getBlogById: blog_id:3
2019-12-30 11:00:14.267 [http-nio-8080-exec-10] INFO  com.lgq.service.impl.SiteServiceImpl - DAY_PAGE_VIEW_PREFIX2019-12-30
2019-12-30 11:00:14.270 [http-nio-8080-exec-3] INFO  com.lgq.service.impl.BlogServiceImpl - 1577674805427
2019-12-30 11:00:14.271 [http-nio-8080-exec-3] INFO  com.lgq.service.impl.BlogServiceImpl - 10
2019-12-30 11:00:14.277 [http-nio-8080-exec-1] INFO  com.lgq.controller.SiteController - FrancisBlog: getSiteInfo
2019-12-30 11:00:14.280 [http-nio-8080-exec-1] INFO  com.lgq.service.impl.SiteServiceImpl - DAY_PAGE_VIEW_PREFIX2019-12-30
2019-12-30 11:00:23.800 [http-nio-8080-exec-3] INFO  com.lgq.controller.MenuController - FrancisBlog: getAllParentMenu
2019-12-30 11:00:23.800 [http-nio-8080-exec-10] INFO  com.lgq.controller.SiteController - FrancisBlog: getSiteInfo
2019-12-30 11:00:23.800 [http-nio-8080-exec-1] INFO  com.lgq.controller.BlogController - FrancisBlog: getBlogById: blog_id:10
2019-12-30 11:00:23.803 [http-nio-8080-exec-10] INFO  com.lgq.service.impl.SiteServiceImpl - DAY_PAGE_VIEW_PREFIX2019-12-30
2019-12-30 11:00:23.807 [http-nio-8080-exec-1] INFO  com.lgq.service.impl.BlogServiceImpl - null
2019-12-30 11:00:23.813 [http-nio-8080-exec-1] INFO  com.lgq.service.impl.BlogServiceImpl - 3
2019-12-30 11:00:23.819 [http-nio-8080-exec-8] INFO  com.lgq.controller.SiteController - FrancisBlog: getSiteInfo
2019-12-30 11:00:23.821 [http-nio-8080-exec-8] INFO  com.lgq.service.impl.SiteServiceImpl - DAY_PAGE_VIEW_PREFIX2019-12-30
2019-12-30 11:06:38.687 [http-nio-8080-exec-6] INFO  com.lgq.controller.SiteController - FrancisBlog: getSiteInfo
2019-12-30 11:06:38.687 [http-nio-8080-exec-3] INFO  com.lgq.controller.MenuController - FrancisBlog: getAllParentMenu
2019-12-30 11:06:38.689 [http-nio-8080-exec-10] INFO  com.lgq.controller.BlogController - FrancisBlog: getBlogById: blog_id:10
2019-12-30 11:06:38.691 [http-nio-8080-exec-6] INFO  com.lgq.service.impl.SiteServiceImpl - DAY_PAGE_VIEW_PREFIX2019-12-30
2019-12-30 11:06:38.696 [http-nio-8080-exec-10] INFO  com.lgq.service.impl.BlogServiceImpl - null
2019-12-30 11:06:38.705 [http-nio-8080-exec-8] INFO  com.lgq.controller.SiteController - FrancisBlog: getSiteInfo
2019-12-30 11:06:38.706 [http-nio-8080-exec-8] INFO  com.lgq.service.impl.SiteServiceImpl - DAY_PAGE_VIEW_PREFIX2019-12-30
2019-12-30 11:06:38.717 [http-nio-8080-exec-10] INFO  com.lgq.service.impl.BlogServiceImpl - 4
2019-12-30 11:07:35.302 [http-nio-8080-exec-1] INFO  com.lgq.controller.BlogController - FrancisBlog: getBlogById: blog_id:10
2019-12-30 11:07:35.308 [http-nio-8080-exec-1] INFO  com.lgq.service.impl.BlogServiceImpl - null
2019-12-30 11:07:35.612 [http-nio-8080-exec-1] INFO  com.lgq.service.impl.BlogServiceImpl - 5
2019-12-30 11:15:36.152 [http-nio-8080-exec-5] INFO  com.lgq.controller.SiteController - FrancisBlog: getSiteInfo
2019-12-30 11:15:36.156 [http-nio-8080-exec-5] INFO  com.lgq.service.impl.SiteServiceImpl - DAY_PAGE_VIEW_PREFIX2019-12-30
2019-12-30 11:24:51.754 [main] INFO  com.lgq.FrancisBlogApplication - Starting FrancisBlogApplication on DESKTOP-G6KT9CH with PID 15016 (I:\blog_for_feifeifei\blog-for-feifeifei\target\classes started by lin in I:\blog_for_feifeifei\blog-for-feifeifei)
2019-12-30 11:24:51.757 [main] INFO  com.lgq.FrancisBlogApplication - No active profile set, falling back to default profiles: default
2019-12-30 11:24:52.893 [main] INFO  o.s.d.r.config.RepositoryConfigurationDelegate - Multiple Spring Data modules found, entering strict repository configuration mode!
2019-12-30 11:24:52.896 [main] INFO  o.s.d.r.config.RepositoryConfigurationDelegate - Bootstrapping Spring Data repositories in DEFAULT mode.
2019-12-30 11:24:52.963 [main] INFO  o.s.d.r.config.RepositoryConfigurationDelegate - Finished Spring Data repository scanning in 53ms. Found 0 repository interfaces.
2019-12-30 11:24:53.273 [main] INFO  o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker - Bean 'org.springframework.transaction.annotation.ProxyTransactionManagementConfiguration' of type [org.springframework.transaction.annotation.ProxyTransactionManagementConfiguration$$EnhancerBySpringCGLIB$$36099e39] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2019-12-30 11:24:53.576 [main] INFO  o.s.boot.web.embedded.tomcat.TomcatWebServer - Tomcat initialized with port(s): 8080 (http)
2019-12-30 11:24:53.590 [main] INFO  org.apache.coyote.http11.Http11NioProtocol - Initializing ProtocolHandler ["http-nio-8080"]
2019-12-30 11:24:53.598 [main] INFO  org.apache.catalina.core.StandardService - Starting service [Tomcat]
2019-12-30 11:24:53.598 [main] INFO  org.apache.catalina.core.StandardEngine - Starting Servlet engine: [Apache Tomcat/9.0.17]
2019-12-30 11:24:53.604 [main] INFO  org.apache.catalina.core.AprLifecycleListener - An older version [1.2.17] of the APR based Apache Tomcat Native library is installed, while Tomcat recommends a minimum version of [1.2.21]
2019-12-30 11:24:53.604 [main] INFO  org.apache.catalina.core.AprLifecycleListener - Loaded APR based Apache Tomcat Native library [1.2.17] using APR version [1.6.3].
2019-12-30 11:24:53.605 [main] INFO  org.apache.catalina.core.AprLifecycleListener - APR capabilities: IPv6 [true], sendfile [true], accept filters [false], random [true].
2019-12-30 11:24:53.605 [main] INFO  org.apache.catalina.core.AprLifecycleListener - APR/OpenSSL configuration: useAprConnector [false], useOpenSSL [true]
2019-12-30 11:24:54.702 [main] INFO  org.apache.catalina.core.AprLifecycleListener - OpenSSL successfully initialized [OpenSSL 1.0.2o  27 Mar 2018]
2019-12-30 11:24:54.852 [main] INFO  o.a.c.c.C.[.[localhost].[/francisblog/api/v1] - Initializing Spring embedded WebApplicationContext
2019-12-30 11:24:54.853 [main] INFO  org.springframework.web.context.ContextLoader - Root WebApplicationContext: initialization completed in 3019 ms
2019-12-30 11:24:56.044 [main] INFO  s.d.s.w.PropertySourcedRequestMappingHandlerMapping - Mapped URL path [/v2/api-docs] onto method [public org.springframework.http.ResponseEntity<springfox.documentation.spring.web.json.Json> springfox.documentation.swagger2.web.Swagger2Controller.getDocumentation(java.lang.String,javax.servlet.http.HttpServletRequest)]
2019-12-30 11:24:56.177 [main] INFO  o.s.scheduling.concurrent.ThreadPoolTaskExecutor - Initializing ExecutorService 'applicationTaskExecutor'
2019-12-30 11:24:56.479 [main] INFO  s.d.s.web.plugins.DocumentationPluginsBootstrapper - Context refreshed
2019-12-30 11:24:56.497 [main] INFO  s.d.s.web.plugins.DocumentationPluginsBootstrapper - Found 1 custom documentation plugin(s)
2019-12-30 11:24:56.556 [main] INFO  s.d.spring.web.scanners.ApiListingReferenceScanner - Scanning for api listing references
2019-12-30 11:24:56.696 [main] INFO  s.d.s.w.r.operation.CachingOperationNameGenerator - Generating unique operation named: getAllAlbumUsingGET_1
2019-12-30 11:24:56.817 [main] INFO  org.apache.coyote.http11.Http11NioProtocol - Starting ProtocolHandler ["http-nio-8080"]
2019-12-30 11:24:56.840 [main] INFO  o.s.boot.web.embedded.tomcat.TomcatWebServer - Tomcat started on port(s): 8080 (http) with context path '/francisblog/api/v1'
2019-12-30 11:24:56.843 [main] INFO  com.lgq.FrancisBlogApplication - Started FrancisBlogApplication in 5.692 seconds (JVM running for 7.786)
2019-12-30 11:25:13.114 [http-nio-8080-exec-2] INFO  o.a.c.c.C.[.[localhost].[/francisblog/api/v1] - Initializing Spring DispatcherServlet 'dispatcherServlet'
2019-12-30 11:25:13.114 [http-nio-8080-exec-2] INFO  org.springframework.web.servlet.DispatcherServlet - Initializing Servlet 'dispatcherServlet'
2019-12-30 11:25:13.123 [http-nio-8080-exec-2] INFO  org.springframework.web.servlet.DispatcherServlet - Completed initialization in 9 ms
2019-12-30 11:25:27.886 [http-nio-8080-exec-5] INFO  com.lgq.controller.BlogCommentController - FrancisBlog: getBlogCommentByBlogId:1
2019-12-30 11:25:27.952 [http-nio-8080-exec-5] INFO  com.alibaba.druid.pool.DruidDataSource - {dataSource-1} inited
2019-12-30 11:25:35.901 [http-nio-8080-exec-6] INFO  com.lgq.controller.BlogCommentController - FrancisBlog: getBlogCommentByBlogId:10
2019-12-30 11:25:44.363 [http-nio-8080-exec-7] INFO  com.lgq.controller.BlogCommentController - FrancisBlog: getBlogCommentByBlogId:1
2019-12-30 11:26:06.879 [main] INFO  com.lgq.FrancisBlogApplication - Starting FrancisBlogApplication on DESKTOP-G6KT9CH with PID 2076 (I:\blog_for_feifeifei\blog-for-feifeifei\target\classes started by lin in I:\blog_for_feifeifei\blog-for-feifeifei)
2019-12-30 11:26:06.882 [main] INFO  com.lgq.FrancisBlogApplication - No active profile set, falling back to default profiles: default
2019-12-30 11:26:08.055 [main] INFO  o.s.d.r.config.RepositoryConfigurationDelegate - Multiple Spring Data modules found, entering strict repository configuration mode!
2019-12-30 11:26:08.057 [main] INFO  o.s.d.r.config.RepositoryConfigurationDelegate - Bootstrapping Spring Data repositories in DEFAULT mode.
2019-12-30 11:26:08.118 [main] INFO  o.s.d.r.config.RepositoryConfigurationDelegate - Finished Spring Data repository scanning in 48ms. Found 0 repository interfaces.
2019-12-30 11:26:08.419 [main] INFO  o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker - Bean 'org.springframework.transaction.annotation.ProxyTransactionManagementConfiguration' of type [org.springframework.transaction.annotation.ProxyTransactionManagementConfiguration$$EnhancerBySpringCGLIB$$4c55e234] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2019-12-30 11:26:08.726 [main] INFO  o.s.boot.web.embedded.tomcat.TomcatWebServer - Tomcat initialized with port(s): 8080 (http)
2019-12-30 11:26:08.738 [main] INFO  org.apache.coyote.http11.Http11NioProtocol - Initializing ProtocolHandler ["http-nio-8080"]
2019-12-30 11:26:08.748 [main] INFO  org.apache.catalina.core.StandardService - Starting service [Tomcat]
2019-12-30 11:26:08.748 [main] INFO  org.apache.catalina.core.StandardEngine - Starting Servlet engine: [Apache Tomcat/9.0.17]
2019-12-30 11:26:08.754 [main] INFO  org.apache.catalina.core.AprLifecycleListener - An older version [1.2.17] of the APR based Apache Tomcat Native library is installed, while Tomcat recommends a minimum version of [1.2.21]
2019-12-30 11:26:08.754 [main] INFO  org.apache.catalina.core.AprLifecycleListener - Loaded APR based Apache Tomcat Native library [1.2.17] using APR version [1.6.3].
2019-12-30 11:26:08.754 [main] INFO  org.apache.catalina.core.AprLifecycleListener - APR capabilities: IPv6 [true], sendfile [true], accept filters [false], random [true].
2019-12-30 11:26:08.755 [main] INFO  org.apache.catalina.core.AprLifecycleListener - APR/OpenSSL configuration: useAprConnector [false], useOpenSSL [true]
2019-12-30 11:26:09.826 [main] INFO  org.apache.catalina.core.AprLifecycleListener - OpenSSL successfully initialized [OpenSSL 1.0.2o  27 Mar 2018]
2019-12-30 11:26:09.935 [main] INFO  o.a.c.c.C.[.[localhost].[/francisblog/api/v1] - Initializing Spring embedded WebApplicationContext
2019-12-30 11:26:09.935 [main] INFO  org.springframework.web.context.ContextLoader - Root WebApplicationContext: initialization completed in 2977 ms
2019-12-30 11:26:11.218 [main] INFO  s.d.s.w.PropertySourcedRequestMappingHandlerMapping - Mapped URL path [/v2/api-docs] onto method [public org.springframework.http.ResponseEntity<springfox.documentation.spring.web.json.Json> springfox.documentation.swagger2.web.Swagger2Controller.getDocumentation(java.lang.String,javax.servlet.http.HttpServletRequest)]
2019-12-30 11:26:11.353 [main] INFO  o.s.scheduling.concurrent.ThreadPoolTaskExecutor - Initializing ExecutorService 'applicationTaskExecutor'
2019-12-30 11:26:11.662 [main] INFO  s.d.s.web.plugins.DocumentationPluginsBootstrapper - Context refreshed
2019-12-30 11:26:11.679 [main] INFO  s.d.s.web.plugins.DocumentationPluginsBootstrapper - Found 1 custom documentation plugin(s)
2019-12-30 11:26:11.730 [main] INFO  s.d.spring.web.scanners.ApiListingReferenceScanner - Scanning for api listing references
2019-12-30 11:26:11.870 [main] INFO  s.d.s.w.r.operation.CachingOperationNameGenerator - Generating unique operation named: getAllAlbumUsingGET_1
2019-12-30 11:26:11.992 [main] INFO  org.apache.coyote.http11.Http11NioProtocol - Starting ProtocolHandler ["http-nio-8080"]
2019-12-30 11:26:12.015 [main] INFO  o.s.boot.web.embedded.tomcat.TomcatWebServer - Tomcat started on port(s): 8080 (http) with context path '/francisblog/api/v1'
2019-12-30 11:26:12.018 [main] INFO  com.lgq.FrancisBlogApplication - Started FrancisBlogApplication in 5.77 seconds (JVM running for 7.507)
2019-12-30 11:28:01.417 [main] INFO  com.lgq.FrancisBlogApplication - Starting FrancisBlogApplication on DESKTOP-G6KT9CH with PID 10252 (I:\blog_for_feifeifei\blog-for-feifeifei\target\classes started by lin in I:\blog_for_feifeifei\blog-for-feifeifei)
2019-12-30 11:28:01.420 [main] INFO  com.lgq.FrancisBlogApplication - No active profile set, falling back to default profiles: default
2019-12-30 11:28:02.437 [main] INFO  o.s.d.r.config.RepositoryConfigurationDelegate - Multiple Spring Data modules found, entering strict repository configuration mode!
2019-12-30 11:28:02.439 [main] INFO  o.s.d.r.config.RepositoryConfigurationDelegate - Bootstrapping Spring Data repositories in DEFAULT mode.
2019-12-30 11:28:02.499 [main] INFO  o.s.d.r.config.RepositoryConfigurationDelegate - Finished Spring Data repository scanning in 49ms. Found 0 repository interfaces.
2019-12-30 11:28:02.791 [main] INFO  o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker - Bean 'org.springframework.transaction.annotation.ProxyTransactionManagementConfiguration' of type [org.springframework.transaction.annotation.ProxyTransactionManagementConfiguration$$EnhancerBySpringCGLIB$$b1359d] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2019-12-30 11:28:03.098 [main] INFO  o.s.boot.web.embedded.tomcat.TomcatWebServer - Tomcat initialized with port(s): 8080 (http)
2019-12-30 11:28:03.111 [main] INFO  org.apache.coyote.http11.Http11NioProtocol - Initializing ProtocolHandler ["http-nio-8080"]
2019-12-30 11:28:03.119 [main] INFO  org.apache.catalina.core.StandardService - Starting service [Tomcat]
2019-12-30 11:28:03.119 [main] INFO  org.apache.catalina.core.StandardEngine - Starting Servlet engine: [Apache Tomcat/9.0.17]
2019-12-30 11:28:03.126 [main] INFO  org.apache.catalina.core.AprLifecycleListener - An older version [1.2.17] of the APR based Apache Tomcat Native library is installed, while Tomcat recommends a minimum version of [1.2.21]
2019-12-30 11:28:03.126 [main] INFO  org.apache.catalina.core.AprLifecycleListener - Loaded APR based Apache Tomcat Native library [1.2.17] using APR version [1.6.3].
2019-12-30 11:28:03.126 [main] INFO  org.apache.catalina.core.AprLifecycleListener - APR capabilities: IPv6 [true], sendfile [true], accept filters [false], random [true].
2019-12-30 11:28:03.127 [main] INFO  org.apache.catalina.core.AprLifecycleListener - APR/OpenSSL configuration: useAprConnector [false], useOpenSSL [true]
2019-12-30 11:28:04.214 [main] INFO  org.apache.catalina.core.AprLifecycleListener - OpenSSL successfully initialized [OpenSSL 1.0.2o  27 Mar 2018]
2019-12-30 11:28:04.325 [main] INFO  o.a.c.c.C.[.[localhost].[/francisblog/api/v1] - Initializing Spring embedded WebApplicationContext
2019-12-30 11:28:04.325 [main] INFO  org.springframework.web.context.ContextLoader - Root WebApplicationContext: initialization completed in 2866 ms
2019-12-30 11:28:05.437 [main] INFO  s.d.s.w.PropertySourcedRequestMappingHandlerMapping - Mapped URL path [/v2/api-docs] onto method [public org.springframework.http.ResponseEntity<springfox.documentation.spring.web.json.Json> springfox.documentation.swagger2.web.Swagger2Controller.getDocumentation(java.lang.String,javax.servlet.http.HttpServletRequest)]
2019-12-30 11:28:05.567 [main] INFO  o.s.scheduling.concurrent.ThreadPoolTaskExecutor - Initializing ExecutorService 'applicationTaskExecutor'
2019-12-30 11:28:05.848 [main] INFO  s.d.s.web.plugins.DocumentationPluginsBootstrapper - Context refreshed
2019-12-30 11:28:05.865 [main] INFO  s.d.s.web.plugins.DocumentationPluginsBootstrapper - Found 1 custom documentation plugin(s)
2019-12-30 11:28:05.914 [main] INFO  s.d.spring.web.scanners.ApiListingReferenceScanner - Scanning for api listing references
2019-12-30 11:28:06.052 [main] INFO  s.d.s.w.r.operation.CachingOperationNameGenerator - Generating unique operation named: getAllAlbumUsingGET_1
2019-12-30 11:28:06.169 [main] INFO  org.apache.coyote.http11.Http11NioProtocol - Starting ProtocolHandler ["http-nio-8080"]
2019-12-30 11:28:06.193 [main] INFO  o.s.boot.web.embedded.tomcat.TomcatWebServer - Tomcat started on port(s): 8080 (http) with context path '/francisblog/api/v1'
2019-12-30 11:28:06.196 [main] INFO  com.lgq.FrancisBlogApplication - Started FrancisBlogApplication in 5.401 seconds (JVM running for 7.415)
2019-12-30 11:29:34.524 [http-nio-8080-exec-2] INFO  o.a.c.c.C.[.[localhost].[/francisblog/api/v1] - Initializing Spring DispatcherServlet 'dispatcherServlet'
2019-12-30 11:29:34.525 [http-nio-8080-exec-2] INFO  org.springframework.web.servlet.DispatcherServlet - Initializing Servlet 'dispatcherServlet'
2019-12-30 11:29:34.541 [http-nio-8080-exec-2] INFO  org.springframework.web.servlet.DispatcherServlet - Completed initialization in 16 ms
2019-12-30 11:29:34.627 [http-nio-8080-exec-2] INFO  com.lgq.controller.BlogController - FrancisBlog: getBlogById: blog_id:10
2019-12-30 11:29:34.709 [http-nio-8080-exec-2] INFO  com.alibaba.druid.pool.DruidDataSource - {dataSource-1} inited
2019-12-30 11:29:35.071 [http-nio-8080-exec-2] INFO  io.lettuce.core.EpollProvider - Starting without optional epoll library
2019-12-30 11:29:35.075 [http-nio-8080-exec-2] INFO  io.lettuce.core.KqueueProvider - Starting without optional kqueue library
2019-12-30 11:29:39.375 [http-nio-8080-exec-2] INFO  com.lgq.service.impl.BlogServiceImpl - null
2019-12-30 11:29:39.523 [http-nio-8080-exec-2] INFO  com.lgq.service.impl.BlogServiceImpl - 6
2019-12-30 11:29:43.393 [http-nio-8080-exec-3] INFO  com.lgq.controller.BlogController - FrancisBlog: getBlogById: blog_id:10
2019-12-30 11:29:43.404 [http-nio-8080-exec-3] INFO  com.lgq.service.impl.BlogServiceImpl - 1577676579378
2019-12-30 11:29:43.407 [http-nio-8080-exec-3] INFO  com.lgq.service.impl.BlogServiceImpl - 7
2019-12-30 11:29:53.980 [http-nio-8080-exec-6] INFO  com.lgq.controller.BlogController - FrancisBlog: getBlogList:2
2019-12-30 11:29:57.216 [http-nio-8080-exec-7] INFO  com.lgq.controller.SiteController - FrancisBlog: getSiteInfo
2019-12-30 11:29:57.227 [http-nio-8080-exec-8] INFO  com.lgq.controller.MenuController - FrancisBlog: getAllParentMenu
2019-12-30 11:29:57.227 [http-nio-8080-exec-9] INFO  com.lgq.controller.BlogController - FrancisBlog: getBlogById: blog_id:1
2019-12-30 11:29:57.233 [http-nio-8080-exec-7] INFO  com.lgq.service.impl.SiteServiceImpl - DAY_PAGE_VIEW_PREFIX2019-12-30
2019-12-30 11:29:57.247 [http-nio-8080-exec-9] INFO  com.lgq.service.impl.BlogServiceImpl - null
2019-12-30 11:29:57.250 [http-nio-8080-exec-1] INFO  com.lgq.controller.SiteController - FrancisBlog: getSiteInfo
2019-12-30 11:29:57.271 [http-nio-8080-exec-1] INFO  com.lgq.service.impl.SiteServiceImpl - DAY_PAGE_VIEW_PREFIX2019-12-30
2019-12-30 11:29:57.358 [http-nio-8080-exec-9] INFO  com.lgq.service.impl.BlogServiceImpl - 122
2019-12-30 11:31:45.342 [http-nio-8080-exec-8] INFO  com.lgq.controller.BlogController - FrancisBlog: getBlogById: blog_id:1
2019-12-30 11:31:45.342 [http-nio-8080-exec-10] INFO  com.lgq.controller.BlogCommentController - FrancisBlog: getBlogCommentByBlogId:1
2019-12-30 11:31:45.358 [http-nio-8080-exec-8] INFO  com.lgq.service.impl.BlogServiceImpl - null
2019-12-30 11:31:45.695 [http-nio-8080-exec-8] INFO  com.lgq.service.impl.BlogServiceImpl - 123
2019-12-30 11:32:18.942 [http-nio-8080-exec-1] INFO  com.lgq.controller.BlogController - FrancisBlog: getBlogById: blog_id:1
2019-12-30 11:32:18.960 [http-nio-8080-exec-1] INFO  com.lgq.service.impl.BlogServiceImpl - null
2019-12-30 11:32:18.967 [http-nio-8080-exec-9] INFO  com.lgq.controller.BlogCommentController - FrancisBlog: getBlogCommentByBlogId:1
2019-12-30 11:32:19.069 [http-nio-8080-exec-1] INFO  com.lgq.service.impl.BlogServiceImpl - 124
2019-12-30 11:32:39.552 [main] INFO  com.lgq.FrancisBlogApplication - Starting FrancisBlogApplication on DESKTOP-G6KT9CH with PID 18888 (I:\blog_for_feifeifei\blog-for-feifeifei\target\classes started by lin in I:\blog_for_feifeifei\blog-for-feifeifei)
2019-12-30 11:32:39.558 [main] INFO  com.lgq.FrancisBlogApplication - No active profile set, falling back to default profiles: default
2019-12-30 11:32:41.687 [main] INFO  o.s.d.r.config.RepositoryConfigurationDelegate - Multiple Spring Data modules found, entering strict repository configuration mode!
2019-12-30 11:32:41.691 [main] INFO  o.s.d.r.config.RepositoryConfigurationDelegate - Bootstrapping Spring Data repositories in DEFAULT mode.
2019-12-30 11:32:41.819 [main] INFO  o.s.d.r.config.RepositoryConfigurationDelegate - Finished Spring Data repository scanning in 103ms. Found 0 repository interfaces.
2019-12-30 11:32:42.393 [main] INFO  o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker - Bean 'org.springframework.transaction.annotation.ProxyTransactionManagementConfiguration' of type [org.springframework.transaction.annotation.ProxyTransactionManagementConfiguration$$EnhancerBySpringCGLIB$$155cd7ca] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2019-12-30 11:32:42.954 [main] INFO  o.s.boot.web.embedded.tomcat.TomcatWebServer - Tomcat initialized with port(s): 8080 (http)
2019-12-30 11:32:42.979 [main] INFO  org.apache.coyote.http11.Http11NioProtocol - Initializing ProtocolHandler ["http-nio-8080"]
2019-12-30 11:32:42.994 [main] INFO  org.apache.catalina.core.StandardService - Starting service [Tomcat]
2019-12-30 11:32:42.994 [main] INFO  org.apache.catalina.core.StandardEngine - Starting Servlet engine: [Apache Tomcat/9.0.17]
2019-12-30 11:32:43.005 [main] INFO  org.apache.catalina.core.AprLifecycleListener - An older version [1.2.17] of the APR based Apache Tomcat Native library is installed, while Tomcat recommends a minimum version of [1.2.21]
2019-12-30 11:32:43.006 [main] INFO  org.apache.catalina.core.AprLifecycleListener - Loaded APR based Apache Tomcat Native library [1.2.17] using APR version [1.6.3].
2019-12-30 11:32:43.006 [main] INFO  org.apache.catalina.core.AprLifecycleListener - APR capabilities: IPv6 [true], sendfile [true], accept filters [false], random [true].
2019-12-30 11:32:43.007 [main] INFO  org.apache.catalina.core.AprLifecycleListener - APR/OpenSSL configuration: useAprConnector [false], useOpenSSL [true]
2019-12-30 11:32:44.173 [main] INFO  org.apache.catalina.core.AprLifecycleListener - OpenSSL successfully initialized [OpenSSL 1.0.2o  27 Mar 2018]
2019-12-30 11:32:44.378 [main] INFO  o.a.c.c.C.[.[localhost].[/francisblog/api/v1] - Initializing Spring embedded WebApplicationContext
2019-12-30 11:32:44.379 [main] INFO  org.springframework.web.context.ContextLoader - Root WebApplicationContext: initialization completed in 4703 ms
2019-12-30 11:32:46.471 [main] INFO  s.d.s.w.PropertySourcedRequestMappingHandlerMapping - Mapped URL path [/v2/api-docs] onto method [public org.springframework.http.ResponseEntity<springfox.documentation.spring.web.json.Json> springfox.documentation.swagger2.web.Swagger2Controller.getDocumentation(java.lang.String,javax.servlet.http.HttpServletRequest)]
2019-12-30 11:32:46.715 [main] INFO  o.s.scheduling.concurrent.ThreadPoolTaskExecutor - Initializing ExecutorService 'applicationTaskExecutor'
2019-12-30 11:32:47.248 [main] INFO  s.d.s.web.plugins.DocumentationPluginsBootstrapper - Context refreshed
2019-12-30 11:32:47.281 [main] INFO  s.d.s.web.plugins.DocumentationPluginsBootstrapper - Found 1 custom documentation plugin(s)
2019-12-30 11:32:47.369 [main] INFO  s.d.spring.web.scanners.ApiListingReferenceScanner - Scanning for api listing references
2019-12-30 11:32:47.632 [main] INFO  s.d.s.w.r.operation.CachingOperationNameGenerator - Generating unique operation named: getAllAlbumUsingGET_1
2019-12-30 11:32:47.844 [main] INFO  org.apache.coyote.http11.Http11NioProtocol - Starting ProtocolHandler ["http-nio-8080"]
2019-12-30 11:32:47.891 [main] INFO  o.s.boot.web.embedded.tomcat.TomcatWebServer - Tomcat started on port(s): 8080 (http) with context path '/francisblog/api/v1'
2019-12-30 11:32:47.896 [main] INFO  com.lgq.FrancisBlogApplication - Started FrancisBlogApplication in 9.535 seconds (JVM running for 13.14)
2019-12-30 11:33:31.240 [http-nio-8080-exec-3] INFO  o.a.c.c.C.[.[localhost].[/francisblog/api/v1] - Initializing Spring DispatcherServlet 'dispatcherServlet'
2019-12-30 11:33:31.241 [http-nio-8080-exec-3] INFO  org.springframework.web.servlet.DispatcherServlet - Initializing Servlet 'dispatcherServlet'
2019-12-30 11:33:31.259 [http-nio-8080-exec-3] INFO  org.springframework.web.servlet.DispatcherServlet - Completed initialization in 18 ms
2019-12-30 11:33:31.319 [http-nio-8080-exec-1] INFO  com.lgq.controller.SiteController - FrancisBlog: getSiteInfo
2019-12-30 11:33:31.319 [http-nio-8080-exec-2] INFO  com.lgq.controller.MenuController - FrancisBlog: getAllParentMenu
2019-12-30 11:33:31.332 [http-nio-8080-exec-3] INFO  com.lgq.controller.BlogController - FrancisBlog: getBlogById: blog_id:1
2019-12-30 11:33:31.332 [http-nio-8080-exec-4] INFO  com.lgq.controller.BlogCommentController - FrancisBlog: getBlogCommentByBlogId:1
2019-12-30 11:33:31.418 [http-nio-8080-exec-3] INFO  com.alibaba.druid.pool.DruidDataSource - {dataSource-1} inited
2019-12-30 11:33:31.825 [http-nio-8080-exec-3] INFO  io.lettuce.core.EpollProvider - Starting without optional epoll library
2019-12-30 11:33:31.828 [http-nio-8080-exec-3] INFO  io.lettuce.core.KqueueProvider - Starting without optional kqueue library
2019-12-30 11:33:35.954 [http-nio-8080-exec-1] INFO  com.lgq.service.impl.SiteServiceImpl - DAY_PAGE_VIEW_PREFIX2019-12-30
2019-12-30 11:33:35.981 [http-nio-8080-exec-3] INFO  com.lgq.service.impl.BlogServiceImpl - null
2019-12-30 11:33:35.982 [http-nio-8080-exec-5] INFO  com.lgq.controller.SiteController - FrancisBlog: getSiteInfo
2019-12-30 11:33:35.988 [http-nio-8080-exec-5] INFO  com.lgq.service.impl.SiteServiceImpl - DAY_PAGE_VIEW_PREFIX2019-12-30
2019-12-30 11:33:36.111 [http-nio-8080-exec-3] INFO  com.lgq.service.impl.BlogServiceImpl - 125
2019-12-30 11:36:50.240 [http-nio-8080-exec-10] INFO  com.lgq.controller.BlogController - FrancisBlog: getBlogById: blog_id:1
2019-12-30 11:36:50.247 [http-nio-8080-exec-4] INFO  com.lgq.controller.BlogCommentController - FrancisBlog: getBlogCommentByBlogId:1
2019-12-30 11:36:50.267 [http-nio-8080-exec-10] INFO  com.lgq.service.impl.BlogServiceImpl - null
2019-12-30 11:36:50.405 [http-nio-8080-exec-10] INFO  com.lgq.service.impl.BlogServiceImpl - 126
2019-12-30 11:38:25.899 [main] INFO  com.lgq.FrancisBlogApplication - Starting FrancisBlogApplication on DESKTOP-G6KT9CH with PID 13364 (I:\blog_for_feifeifei\blog-for-feifeifei\target\classes started by lin in I:\blog_for_feifeifei\blog-for-feifeifei)
2019-12-30 11:38:25.905 [main] INFO  com.lgq.FrancisBlogApplication - No active profile set, falling back to default profiles: default
2019-12-30 11:38:28.443 [main] INFO  o.s.d.r.config.RepositoryConfigurationDelegate - Multiple Spring Data modules found, entering strict repository configuration mode!
2019-12-30 11:38:28.448 [main] INFO  o.s.d.r.config.RepositoryConfigurationDelegate - Bootstrapping Spring Data repositories in DEFAULT mode.
2019-12-30 11:38:28.575 [main] INFO  o.s.d.r.config.RepositoryConfigurationDelegate - Finished Spring Data repository scanning in 103ms. Found 0 repository interfaces.
2019-12-30 11:38:29.145 [main] INFO  o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker - Bean 'org.springframework.transaction.annotation.ProxyTransactionManagementConfiguration' of type [org.springframework.transaction.annotation.ProxyTransactionManagementConfiguration$$EnhancerBySpringCGLIB$$b19116ba] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2019-12-30 11:38:29.716 [main] INFO  o.s.boot.web.embedded.tomcat.TomcatWebServer - Tomcat initialized with port(s): 8080 (http)
2019-12-30 11:38:29.741 [main] INFO  org.apache.coyote.http11.Http11NioProtocol - Initializing ProtocolHandler ["http-nio-8080"]
2019-12-30 11:38:29.757 [main] INFO  org.apache.catalina.core.StandardService - Starting service [Tomcat]
2019-12-30 11:38:29.759 [main] INFO  org.apache.catalina.core.StandardEngine - Starting Servlet engine: [Apache Tomcat/9.0.17]
2019-12-30 11:38:29.772 [main] INFO  org.apache.catalina.core.AprLifecycleListener - An older version [1.2.17] of the APR based Apache Tomcat Native library is installed, while Tomcat recommends a minimum version of [1.2.21]
2019-12-30 11:38:29.772 [main] INFO  org.apache.catalina.core.AprLifecycleListener - Loaded APR based Apache Tomcat Native library [1.2.17] using APR version [1.6.3].
2019-12-30 11:38:29.773 [main] INFO  org.apache.catalina.core.AprLifecycleListener - APR capabilities: IPv6 [true], sendfile [true], accept filters [false], random [true].
2019-12-30 11:38:29.773 [main] INFO  org.apache.catalina.core.AprLifecycleListener - APR/OpenSSL configuration: useAprConnector [false], useOpenSSL [true]
2019-12-30 11:38:30.941 [main] INFO  org.apache.catalina.core.AprLifecycleListener - OpenSSL successfully initialized [OpenSSL 1.0.2o  27 Mar 2018]
2019-12-30 11:38:31.203 [main] INFO  o.a.c.c.C.[.[localhost].[/francisblog/api/v1] - Initializing Spring embedded WebApplicationContext
2019-12-30 11:38:31.204 [main] INFO  org.springframework.web.context.ContextLoader - Root WebApplicationContext: initialization completed in 5143 ms
2019-12-30 11:38:33.368 [main] INFO  s.d.s.w.PropertySourcedRequestMappingHandlerMapping - Mapped URL path [/v2/api-docs] onto method [public org.springframework.http.ResponseEntity<springfox.documentation.spring.web.json.Json> springfox.documentation.swagger2.web.Swagger2Controller.getDocumentation(java.lang.String,javax.servlet.http.HttpServletRequest)]
2019-12-30 11:38:33.616 [main] INFO  o.s.scheduling.concurrent.ThreadPoolTaskExecutor - Initializing ExecutorService 'applicationTaskExecutor'
2019-12-30 11:38:34.148 [main] INFO  s.d.s.web.plugins.DocumentationPluginsBootstrapper - Context refreshed
2019-12-30 11:38:34.180 [main] INFO  s.d.s.web.plugins.DocumentationPluginsBootstrapper - Found 1 custom documentation plugin(s)
2019-12-30 11:38:34.269 [main] INFO  s.d.spring.web.scanners.ApiListingReferenceScanner - Scanning for api listing references
2019-12-30 11:38:34.526 [main] INFO  s.d.s.w.r.operation.CachingOperationNameGenerator - Generating unique operation named: getAllAlbumUsingGET_1
2019-12-30 11:38:34.745 [main] INFO  org.apache.coyote.http11.Http11NioProtocol - Starting ProtocolHandler ["http-nio-8080"]
2019-12-30 11:38:34.791 [main] INFO  o.s.boot.web.embedded.tomcat.TomcatWebServer - Tomcat started on port(s): 8080 (http) with context path '/francisblog/api/v1'
2019-12-30 11:38:34.797 [main] INFO  com.lgq.FrancisBlogApplication - Started FrancisBlogApplication in 10.141 seconds (JVM running for 14.586)
2019-12-30 11:38:40.269 [http-nio-8080-exec-1] INFO  o.a.c.c.C.[.[localhost].[/francisblog/api/v1] - Initializing Spring DispatcherServlet 'dispatcherServlet'
2019-12-30 11:38:40.269 [http-nio-8080-exec-1] INFO  org.springframework.web.servlet.DispatcherServlet - Initializing Servlet 'dispatcherServlet'
2019-12-30 11:38:40.285 [http-nio-8080-exec-1] INFO  org.springframework.web.servlet.DispatcherServlet - Completed initialization in 15 ms
2019-12-30 11:38:40.359 [http-nio-8080-exec-1] INFO  com.lgq.controller.BlogController - FrancisBlog: getBlogById: blog_id:1
2019-12-30 11:38:40.359 [http-nio-8080-exec-2] INFO  com.lgq.controller.BlogCommentController - FrancisBlog: getBlogCommentByBlogId:1
2019-12-30 11:38:40.440 [http-nio-8080-exec-1] INFO  com.alibaba.druid.pool.DruidDataSource - {dataSource-1} inited
2019-12-30 11:38:40.803 [http-nio-8080-exec-1] INFO  io.lettuce.core.EpollProvider - Starting without optional epoll library
2019-12-30 11:38:40.806 [http-nio-8080-exec-1] INFO  io.lettuce.core.KqueueProvider - Starting without optional kqueue library
2019-12-30 11:38:45.010 [http-nio-8080-exec-1] INFO  com.lgq.service.impl.BlogServiceImpl - null
2019-12-30 11:38:45.164 [http-nio-8080-exec-1] INFO  com.lgq.service.impl.BlogServiceImpl - 127
2019-12-30 11:39:26.819 [http-nio-8080-exec-5] INFO  com.lgq.controller.BlogController - FrancisBlog: getBlogById: blog_id:1
2019-12-30 11:39:26.819 [http-nio-8080-exec-4] INFO  com.lgq.controller.BlogCommentController - FrancisBlog: getBlogCommentByBlogId:1
2019-12-30 11:39:26.832 [http-nio-8080-exec-5] INFO  com.lgq.service.impl.BlogServiceImpl - null
2019-12-30 11:39:26.852 [http-nio-8080-exec-5] INFO  com.lgq.service.impl.BlogServiceImpl - 128
2019-12-30 12:02:47.682 [http-nio-8080-exec-8] INFO  com.lgq.controller.BlogController - FrancisBlog: getBlogById: blog_id:1
2019-12-30 12:02:47.682 [http-nio-8080-exec-9] INFO  com.lgq.controller.BlogCommentController - FrancisBlog: getBlogCommentByBlogId:1
2019-12-30 12:02:47.702 [http-nio-8080-exec-8] INFO  com.lgq.service.impl.BlogServiceImpl - null
2019-12-30 12:02:48.047 [http-nio-8080-exec-8] INFO  com.lgq.service.impl.BlogServiceImpl - 129
2019-12-30 12:03:14.916 [http-nio-8080-exec-2] INFO  com.lgq.controller.BlogCommentController - FrancisBlog: addBlog -> {"blogCommentBlogId":1,"blogCommentContent":"","blogCommentParentId":0,"blogCommentUsername":""}
2019-12-30 12:03:22.290 [http-nio-8080-exec-3] INFO  com.lgq.controller.MenuController - FrancisBlog: getAllParentMenu
2019-12-30 12:03:22.290 [http-nio-8080-exec-1] INFO  com.lgq.controller.SiteController - FrancisBlog: getSiteInfo
2019-12-30 12:03:22.300 [http-nio-8080-exec-5] INFO  com.lgq.controller.BlogCommentController - FrancisBlog: getBlogCommentByBlogId:1
2019-12-30 12:03:22.305 [http-nio-8080-exec-1] INFO  com.lgq.service.impl.SiteServiceImpl - DAY_PAGE_VIEW_PREFIX2019-12-30
2019-12-30 12:03:22.311 [http-nio-8080-exec-4] INFO  com.lgq.controller.BlogController - FrancisBlog: getBlogById: blog_id:1
2019-12-30 12:03:22.323 [http-nio-8080-exec-4] INFO  com.lgq.service.impl.BlogServiceImpl - null
2019-12-30 12:03:22.323 [http-nio-8080-exec-6] INFO  com.lgq.controller.SiteController - FrancisBlog: getSiteInfo
2019-12-30 12:03:22.329 [http-nio-8080-exec-6] INFO  com.lgq.service.impl.SiteServiceImpl - DAY_PAGE_VIEW_PREFIX2019-12-30
2019-12-30 12:03:22.357 [http-nio-8080-exec-4] INFO  com.lgq.service.impl.BlogServiceImpl - 130
2019-12-30 12:03:36.958 [http-nio-8080-exec-7] INFO  com.lgq.controller.BlogCommentController - FrancisBlog: getBlogCommentByBlogId:1
2019-12-30 12:04:08.093 [http-nio-8080-exec-8] INFO  com.lgq.controller.BlogCommentController - FrancisBlog: getBlogCommentByBlogId:1
2019-12-30 12:04:08.093 [http-nio-8080-exec-9] INFO  com.lgq.controller.BlogController - FrancisBlog: getBlogById: blog_id:1
2019-12-30 12:04:08.104 [http-nio-8080-exec-9] INFO  com.lgq.service.impl.BlogServiceImpl - null
2019-12-30 12:04:08.421 [http-nio-8080-exec-9] INFO  com.lgq.service.impl.BlogServiceImpl - 131
2019-12-30 12:04:16.839 [http-nio-8080-exec-2] INFO  com.lgq.controller.BlogCommentController - FrancisBlog: addBlog -> {"blogCommentBlogId":1,"blogCommentContent":"","blogCommentParentId":0,"blogCommentUsername":""}
2019-12-30 12:04:22.986 [http-nio-8080-exec-6] INFO  com.lgq.controller.MenuController - FrancisBlog: getAllParentMenu
2019-12-30 12:04:22.986 [http-nio-8080-exec-1] INFO  com.lgq.controller.SiteController - FrancisBlog: getSiteInfo
2019-12-30 12:04:22.986 [http-nio-8080-exec-5] INFO  com.lgq.controller.BlogController - FrancisBlog: getBlogById: blog_id:1
2019-12-30 12:04:22.993 [http-nio-8080-exec-3] INFO  com.lgq.controller.BlogCommentController - FrancisBlog: getBlogCommentByBlogId:1
2019-12-30 12:04:22.995 [http-nio-8080-exec-1] INFO  com.lgq.service.impl.SiteServiceImpl - DAY_PAGE_VIEW_PREFIX2019-12-30
2019-12-30 12:04:23.010 [http-nio-8080-exec-5] INFO  com.lgq.service.impl.BlogServiceImpl - null
2019-12-30 12:04:23.011 [http-nio-8080-exec-4] INFO  com.lgq.controller.SiteController - FrancisBlog: getSiteInfo
2019-12-30 12:04:23.018 [http-nio-8080-exec-4] INFO  com.lgq.service.impl.SiteServiceImpl - DAY_PAGE_VIEW_PREFIX2019-12-30
2019-12-30 12:04:23.121 [http-nio-8080-exec-5] INFO  com.lgq.service.impl.BlogServiceImpl - 132
2019-12-30 12:06:37.483 [http-nio-8080-exec-6] INFO  com.lgq.controller.BlogController - FrancisBlog: getBlogById: blog_id:1
2019-12-30 12:06:37.485 [http-nio-8080-exec-1] INFO  com.lgq.controller.BlogCommentController - FrancisBlog: getBlogCommentByBlogId:1
2019-12-30 12:06:37.496 [http-nio-8080-exec-6] INFO  com.lgq.service.impl.BlogServiceImpl - null
2019-12-30 12:06:37.600 [http-nio-8080-exec-6] INFO  com.lgq.service.impl.BlogServiceImpl - 133
2019-12-30 12:06:54.687 [http-nio-8080-exec-3] INFO  com.lgq.controller.BlogCommentController - FrancisBlog: addBlog -> {"blogCommentBlogId":1,"blogCommentContent":"瘦瘦瘦","blogCommentParentId":0,"blogCommentUsername":"啊啊啊"}
2019-12-30 12:07:00.917 [http-nio-8080-exec-4] INFO  com.lgq.controller.SiteController - FrancisBlog: getSiteInfo
2019-12-30 12:07:00.917 [http-nio-8080-exec-5] INFO  com.lgq.controller.MenuController - FrancisBlog: getAllParentMenu
2019-12-30 12:07:00.922 [http-nio-8080-exec-4] INFO  com.lgq.service.impl.SiteServiceImpl - DAY_PAGE_VIEW_PREFIX2019-12-30
2019-12-30 12:07:00.926 [http-nio-8080-exec-7] INFO  com.lgq.controller.BlogController - FrancisBlog: getBlogById: blog_id:1
2019-12-30 12:07:00.927 [http-nio-8080-exec-5] INFO  com.lgq.controller.BlogCommentController - FrancisBlog: getBlogCommentByBlogId:1
2019-12-30 12:07:00.934 [http-nio-8080-exec-8] INFO  com.lgq.controller.SiteController - FrancisBlog: getSiteInfo
2019-12-30 12:07:00.940 [http-nio-8080-exec-7] INFO  com.lgq.service.impl.BlogServiceImpl - null
2019-12-30 12:07:00.940 [http-nio-8080-exec-8] INFO  com.lgq.service.impl.SiteServiceImpl - DAY_PAGE_VIEW_PREFIX2019-12-30
2019-12-30 12:07:01.071 [http-nio-8080-exec-7] INFO  com.lgq.service.impl.BlogServiceImpl - 134
2019-12-30 12:07:49.035 [http-nio-8080-exec-2] INFO  com.lgq.controller.SiteController - FrancisBlog: getSiteInfo
2019-12-30 12:07:49.035 [http-nio-8080-exec-1] INFO  com.lgq.controller.MenuController - FrancisBlog: getAllParentMenu
2019-12-30 12:07:49.036 [http-nio-8080-exec-10] INFO  com.lgq.controller.BlogController - FrancisBlog: getBlogList:1
2019-12-30 12:07:49.040 [http-nio-8080-exec-2] INFO  com.lgq.service.impl.SiteServiceImpl - DAY_PAGE_VIEW_PREFIX2019-12-30
2019-12-30 12:07:49.044 [http-nio-8080-exec-6] INFO  com.lgq.controller.SiteTagController - FrancisBlog: getAllSiteTag
2019-12-30 12:07:49.045 [http-nio-8080-exec-2] INFO  com.lgq.controller.SiteIconController - FrancisBlog: getAllSiteIcon
2019-12-30 12:07:49.045 [http-nio-8080-exec-3] INFO  com.lgq.controller.SiteFriendLinkController - FrancisBlog: getAllSiteFriendLink
2019-12-30 12:07:49.060 [http-nio-8080-exec-6] INFO  com.lgq.controller.SiteController - FrancisBlog: getSiteInfo
2019-12-30 12:07:49.060 [http-nio-8080-exec-4] INFO  com.lgq.controller.AdvertisementController - FrancisBlog: getAllAdvertisement
2019-12-30 12:07:49.069 [http-nio-8080-exec-6] INFO  com.lgq.service.impl.SiteServiceImpl - DAY_PAGE_VIEW_PREFIX2019-12-30
2019-12-30 12:07:49.084 [http-nio-8080-exec-8] INFO  com.lgq.controller.SiteController - FrancisBlog: getSiteInfo
2019-12-30 12:07:49.090 [http-nio-8080-exec-8] INFO  com.lgq.service.impl.SiteServiceImpl - DAY_PAGE_VIEW_PREFIX2019-12-30
2019-12-30 12:08:01.027 [http-nio-8080-exec-1] INFO  com.lgq.controller.MenuController - FrancisBlog: getAllParentMenu
2019-12-30 12:08:01.026 [http-nio-8080-exec-9] INFO  com.lgq.controller.SiteController - FrancisBlog: getSiteInfo
2019-12-30 12:08:01.028 [http-nio-8080-exec-7] INFO  com.lgq.controller.BlogController - FrancisBlog: getBlogList:1
2019-12-30 12:08:01.032 [http-nio-8080-exec-9] INFO  com.lgq.service.impl.SiteServiceImpl - DAY_PAGE_VIEW_PREFIX2019-12-30
2019-12-30 12:08:01.034 [http-nio-8080-exec-1] INFO  com.lgq.controller.SiteFriendLinkController - FrancisBlog: getAllSiteFriendLink
2019-12-30 12:08:01.036 [http-nio-8080-exec-5] INFO  com.lgq.controller.SiteIconController - FrancisBlog: getAllSiteIcon
2019-12-30 12:08:01.038 [http-nio-8080-exec-2] INFO  com.lgq.controller.SiteTagController - FrancisBlog: getAllSiteTag
2019-12-30 12:08:01.050 [http-nio-8080-exec-4] INFO  com.lgq.controller.AdvertisementController - FrancisBlog: getAllAdvertisement
2019-12-30 12:08:01.055 [http-nio-8080-exec-6] INFO  com.lgq.controller.SiteController - FrancisBlog: getSiteInfo
2019-12-30 12:08:01.059 [http-nio-8080-exec-6] INFO  com.lgq.service.impl.SiteServiceImpl - DAY_PAGE_VIEW_PREFIX2019-12-30
2019-12-30 12:08:01.071 [http-nio-8080-exec-8] INFO  com.lgq.controller.SiteController - FrancisBlog: getSiteInfo
2019-12-30 12:08:01.075 [http-nio-8080-exec-8] INFO  com.lgq.service.impl.SiteServiceImpl - DAY_PAGE_VIEW_PREFIX2019-12-30
2019-12-30 12:08:02.764 [http-nio-8080-exec-10] INFO  com.lgq.controller.SiteController - FrancisBlog: getSiteInfo
2019-12-30 12:08:02.764 [http-nio-8080-exec-3] INFO  com.lgq.controller.MenuController - FrancisBlog: getAllParentMenu
2019-12-30 12:08:02.769 [http-nio-8080-exec-10] INFO  com.lgq.service.impl.SiteServiceImpl - DAY_PAGE_VIEW_PREFIX2019-12-30
2019-12-30 12:08:02.781 [http-nio-8080-exec-9] INFO  com.lgq.controller.SiteController - FrancisBlog: getSiteInfo
2019-12-30 12:08:02.786 [http-nio-8080-exec-9] INFO  com.lgq.service.impl.SiteServiceImpl - DAY_PAGE_VIEW_PREFIX2019-12-30
2019-12-30 12:08:15.280 [http-nio-8080-exec-2] INFO  com.lgq.controller.UserController - FrancisBlog: signIn -> {"userAccount":"2487049041","userPassword":"123456"}
2019-12-30 12:08:17.998 [http-nio-8080-exec-5] INFO  com.lgq.controller.BlogCommentController - FrancisBlog: getAllBlogComment
2019-12-30 12:08:22.594 [http-nio-8080-exec-4] INFO  com.lgq.controller.BlogCommentController - FrancisBlog: deleteBlogComment6
2019-12-30 12:08:22.799 [http-nio-8080-exec-6] INFO  com.lgq.controller.BlogCommentController - FrancisBlog: getAllBlogComment
2019-12-30 12:08:25.885 [http-nio-8080-exec-3] INFO  com.lgq.controller.BlogCommentController - FrancisBlog: deleteBlogComment7
2019-12-30 12:08:26.088 [http-nio-8080-exec-10] INFO  com.lgq.controller.BlogCommentController - FrancisBlog: getAllBlogComment
2019-12-30 12:08:35.885 [http-nio-8080-exec-2] INFO  com.lgq.controller.MenuController - FrancisBlog: getAllParentMenu
2019-12-30 12:08:35.885 [http-nio-8080-exec-1] INFO  com.lgq.controller.SiteController - FrancisBlog: getSiteInfo
2019-12-30 12:08:35.885 [http-nio-8080-exec-9] INFO  com.lgq.controller.BlogController - FrancisBlog: getBlogList:1
2019-12-30 12:08:35.889 [http-nio-8080-exec-4] INFO  com.lgq.controller.SiteFriendLinkController - FrancisBlog: getAllSiteFriendLink
2019-12-30 12:08:35.889 [http-nio-8080-exec-5] INFO  com.lgq.controller.SiteTagController - FrancisBlog: getAllSiteTag
2019-12-30 12:08:35.889 [http-nio-8080-exec-7] INFO  com.lgq.controller.SiteIconController - FrancisBlog: getAllSiteIcon
2019-12-30 12:08:36.076 [http-nio-8080-exec-1] INFO  com.lgq.service.impl.SiteServiceImpl - DAY_PAGE_VIEW_PREFIX2019-12-30
2019-12-30 12:08:36.080 [http-nio-8080-exec-6] INFO  com.lgq.controller.AdvertisementController - FrancisBlog: getAllAdvertisement
2019-12-30 12:08:36.088 [http-nio-8080-exec-8] INFO  com.lgq.controller.SiteController - FrancisBlog: getSiteInfo
2019-12-30 12:08:36.100 [http-nio-8080-exec-8] INFO  com.lgq.service.impl.SiteServiceImpl - DAY_PAGE_VIEW_PREFIX2019-12-30
2019-12-30 12:08:36.113 [http-nio-8080-exec-3] INFO  com.lgq.controller.SiteController - FrancisBlog: getSiteInfo
2019-12-30 12:08:36.118 [http-nio-8080-exec-3] INFO  com.lgq.service.impl.SiteServiceImpl - DAY_PAGE_VIEW_PREFIX2019-12-30
2019-12-30 12:09:54.457 [http-nio-8080-exec-3] INFO  com.lgq.controller.BlogController - FrancisBlog: getBlogList:2
2019-12-30 12:09:57.906 [http-nio-8080-exec-9] INFO  com.lgq.controller.SiteController - FrancisBlog: getSiteInfo
2019-12-30 12:09:57.911 [http-nio-8080-exec-9] INFO  com.lgq.service.impl.SiteServiceImpl - DAY_PAGE_VIEW_PREFIX2019-12-30
2019-12-30 12:09:57.913 [http-nio-8080-exec-10] INFO  com.lgq.controller.MenuController - FrancisBlog: getAllParentMenu
2019-12-30 12:09:57.914 [http-nio-8080-exec-5] INFO  com.lgq.controller.BlogCommentController - FrancisBlog: getBlogCommentByBlogId:1
2019-12-30 12:09:57.916 [http-nio-8080-exec-7] INFO  com.lgq.controller.BlogController - FrancisBlog: getBlogById: blog_id:1
2019-12-30 12:09:57.922 [http-nio-8080-exec-4] INFO  com.lgq.controller.SiteController - FrancisBlog: getSiteInfo
2019-12-30 12:09:57.926 [http-nio-8080-exec-4] INFO  com.lgq.service.impl.SiteServiceImpl - DAY_PAGE_VIEW_PREFIX2019-12-30
2019-12-30 12:09:58.043 [http-nio-8080-exec-7] INFO  com.lgq.service.impl.BlogServiceImpl - null
2019-12-30 12:09:58.062 [http-nio-8080-exec-7] INFO  com.lgq.service.impl.BlogServiceImpl - 135
2019-12-30 12:10:15.247 [http-nio-8080-exec-1] INFO  com.lgq.controller.BlogCommentController - FrancisBlog: addBlog -> {"blogCommentBlogId":1,"blogCommentContent":"信息从v","blogCommentParentId":0,"blogCommentUsername":"瘦瘦瘦"}
2019-12-30 12:10:15.422 [http-nio-8080-exec-2] INFO  com.lgq.controller.BlogCommentController - FrancisBlog: getBlogCommentByBlogId:1
2019-12-30 12:11:57.254 [http-nio-8080-exec-10] INFO  com.lgq.controller.BlogController - FrancisBlog: getBlogList:1
2019-12-30 12:11:57.255 [http-nio-8080-exec-4] INFO  com.lgq.controller.SiteController - FrancisBlog: getSiteInfo
2019-12-30 12:11:57.255 [http-nio-8080-exec-5] INFO  com.lgq.controller.SiteTagController - FrancisBlog: getAllSiteTag
2019-12-30 12:11:57.260 [http-nio-8080-exec-4] INFO  com.lgq.service.impl.SiteServiceImpl - DAY_PAGE_VIEW_PREFIX2019-12-30
2019-12-30 12:11:57.261 [http-nio-8080-exec-7] INFO  com.lgq.controller.SiteIconController - FrancisBlog: getAllSiteIcon
2019-12-30 12:11:57.266 [http-nio-8080-exec-4] INFO  com.lgq.controller.SiteFriendLinkController - FrancisBlog: getAllSiteFriendLink
2019-12-30 12:11:57.537 [http-nio-8080-exec-1] INFO  com.lgq.controller.AdvertisementController - FrancisBlog: getAllAdvertisement
2019-12-30 12:14:37.597 [http-nio-8080-exec-1] INFO  com.lgq.controller.AlbumController - FrancisBlog: getAllAlbum
2019-12-30 12:14:37.597 [http-nio-8080-exec-7] INFO  com.lgq.controller.AlbumPictureController - FrancisBlog: getAllAlbum
2019-12-30 12:15:06.941 [http-nio-8080-exec-5] INFO  com.lgq.controller.SiteController - FrancisBlog: getSiteViewTrend
2019-12-30 12:15:06.943 [http-nio-8080-exec-8] INFO  com.lgq.controller.BlogController - FrancisBlog: getDateNum
2019-12-30 12:15:06.946 [http-nio-8080-exec-10] INFO  com.lgq.controller.BlogController - FrancisBlog: getBlogCategoryNum
2019-12-30 12:15:06.952 [http-nio-8080-exec-3] INFO  com.lgq.controller.BlogCommentController - FrancisBlog: getLatestComment
2019-12-30 12:15:06.952 [http-nio-8080-exec-6] INFO  com.lgq.controller.BlogController - FrancisBlog: getBlogViewNum
2019-12-30 12:15:19.787 [http-nio-8080-exec-9] INFO  com.lgq.controller.BlogCommentController - FrancisBlog: getAllBlogComment
2019-12-30 12:15:22.856 [http-nio-8080-exec-2] INFO  com.lgq.controller.BlogController - FrancisBlog: getBlogList:1
2019-12-30 12:15:54.808 [http-nio-8080-exec-4] INFO  com.lgq.controller.TokenController - FrancisBlog: getToken
2019-12-30 12:15:54.816 [http-nio-8080-exec-1] INFO  com.lgq.controller.BlogController - FrancisBlog: getBlogById: blog_id:3
2019-12-30 12:15:54.820 [http-nio-8080-exec-7] INFO  com.lgq.controller.TagController - FrancisBlog: getAllTag
2019-12-30 12:15:54.826 [http-nio-8080-exec-1] INFO  com.lgq.service.impl.BlogServiceImpl - null
2019-12-30 12:15:54.828 [http-nio-8080-exec-10] INFO  com.lgq.controller.CategoryController - FrancisBlog: getAllCategory
2019-12-30 12:15:54.880 [http-nio-8080-exec-1] INFO  com.lgq.service.impl.BlogServiceImpl - 11
2019-12-30 12:17:28.918 [http-nio-8080-exec-7] INFO  com.lgq.controller.BlogController - FrancisBlog: updateBlogById -> {"blogCategoryId":1,"blogContent":"<div class=\"output_wrapper\" id=\"output_wrapper_id\" style=\"font-size: 16px; color: rgb(62, 62, 62); line-height: 1.7; word-spacing: 0px; letter-spacing: 0px; font-family: 'Helvetica Neue', Helvetica, 'Hiragino Sans GB', 'Microsoft YaHei', Arial, sans-serif; background-image: linear-gradient(90deg, rgba(50, 0, 0, 0.05) 3%, rgba(0, 0, 0, 0) 3%), linear-gradient(360deg, rgba(50, 0, 0, 0.05) 3%, rgba(0, 0, 0, 0) 3%); background-size: 20px 20px; background-position: center center;\"><h2 id=\"h\" style=\"color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px; font-weight: bold; font-size: 1.5em; border-bottom: 2.2px solid rgb(255, 111, 0);\"><span style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; background: rgb(255, 111, 0); padding: 5px 15px; display: inline-block;\">吐槽</span></h2>\n<blockquote style=\"line-height: inherit; display: block; padding: 15px 15px 15px 1rem; font-size: 1em; margin: 1em 0px; color: rgb(129, 145, 152); border-left: 8px solid rgb(255, 138, 101); background: rgb(224, 242, 241); overflow: auto; overflow-wrap: normal; word-break: normal; letter-spacing: 1.5px; font-family: YouYuan;\">\n  <p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 0px;\">文章很长，点赞再看，养成好习惯😋😋😋</p>\n</blockquote>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">这真的是考前的最后一篇博客，再写真的要挂科了。</p>\n<figure style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><img src=\"https://user-gold-cdn.xitu.io/2019/12/11/16ef37eaae5f8d42?w=255&amp;h=255&amp;f=jpeg&amp;s=11940\" alt=\"\" title=\"\" style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;\"><figcaption style=\"line-height: inherit; margin: 0px; padding: 0px; margin-top: 10px; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;\"></figcaption></figure>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">其实一直想吐槽现在很多大学的计算机教育的，我从大二开始入门 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Java</code>后端，其实我觉得我的学习效率很低，中间也走了很多歪路。但是，如今和同龄人比较，我发现大部分同学竟然连基本的代码都不会敲，尤其到了课程设计大家都是水水过的，让他们做一个管理系统简直要他们命。包括现在大三了，很多人希望本科就出来就业的开始报培训班，培机构开始大把大把地捞金，学生在那疯狂吐槽三四年里没有从学校学到任何东西，这可能是大部分大学计算机教育的通病吧。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">当然还有很多师资力量的问题，不知道清北的，但在我认识的一些 211 或者某些 985 的同学，他们学校的老师或者所教的一些知识也已经落伍了好多年了(当然不是指一些操作系统类似的基础学科，我觉得它们是几十年都不变的)。如果一个数据库老师会告诉你 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">MySQL</code> 不支持事务，一个数据结构老师说 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">B+树</code> 是二叉树，甚至在学生提到一些新的东西的时候没有了解过并且不想去了解，你们会怎么想。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">但很庆幸，在大二的时候加入了我们学校最牛的技术组织 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">TECH F5VE</code> ，这是一个学生组织的创业型技术团队，成立五年目前成员四十人不到，但里面不乏各种大厂的大牛，我在里面获得了很多很多。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">当然，参加过一些小公司的实习或者和他们合作过做一些外包项目，但发现他们的技术选型也已经 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">out</code> 了，我们团队的成员戏称 \"考古式开发\"。我想这也是大部分人挤破了头皮想要进大厂的理由吧。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">可能观点有点偏激，希望大家理解🤐🤐🤐。</p>\n<h2 id=\"h-1\" style=\"color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px; font-weight: bold; font-size: 1.5em; border-bottom: 2.2px solid rgb(255, 111, 0);\"><span style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; background: rgb(255, 111, 0); padding: 5px 15px; display: inline-block;\">消息队列扫盲</span></h2>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">消息队列顾名思义就是存放消息的队列，队列我就不解释了，别告诉我你连队列都不知道似啥吧？</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">所以问题并不是消息队列是什么，而是 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">消息队列为什么会出现？消息队列能用来干什么？用它来干这些事会带来什么好处？消息队列会带来副作用吗？</strong></p>\n<h3 id=\"h-2\" style=\"color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px; font-weight: bold; font-size: 1.3em;\"><span style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\">消息队列为什么会出现？</span></h3>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">消息队列算是作为后端程序员的一个必备技能吧，因为<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">分布式应用必定涉及到各个系统之间的通信问题</strong>，这个时候消息队列也应运而生了。可以说分布式的产生是消息队列的基础，而分布式怕是一个很古老的概念了吧，所以消息队列也是一个很古老的中间件了。</p>\n<h3 id=\"h-3\" style=\"color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px; font-weight: bold; font-size: 1.3em;\"><span style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\">消息队列能用来干什么？</span></h3>\n<h4 id=\"h-4\" style=\"color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px; font-weight: bold; font-size: 1.2em;\"><span style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\">异步</span></h4>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">你可能会反驳我，应用之间的通信又不是只能由消息队列解决，好好的通信为什么中间非要插一个消息队列呢？我不能直接进行通信吗？</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">很好👍，你又提出了一个概念，<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">同步通信</strong>。就比如现在业界使用比较多的 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Dubbo</code> 就是一个适用于各个系统之间同步通信的 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RPC</code> 框架。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">我来举个🌰吧，比如我们有一个购票系统，需求是用户在购买完之后能接收到购买完成的短信。</p>\n<figure style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><img src=\"https://user-gold-cdn.xitu.io/2019/12/11/16ef37fee7e09230?w=951&amp;h=209&amp;f=jpeg&amp;s=20202\" alt=\"\" title=\"\" style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;\"><figcaption style=\"line-height: inherit; margin: 0px; padding: 0px; margin-top: 10px; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;\"></figcaption></figure>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">我们省略中间的网络通信时间消耗，假如购票系统处理需要 150ms ，短信系统处理需要 200ms ，那么整个处理流程的时间消耗就是 150ms + 200ms = 350ms。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">当然，乍看没什么问题。可是仔细一想你就感觉有点问题，我用户购票在购票系统的时候其实就已经完成了购买，而我现在通过同步调用非要让整个请求拉长时间，而短息系统这玩意又不是很有必要，它仅仅是一个辅助功能增强用户体验感而已。我现在整个调用流程就有点 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">头重脚轻</strong> 的感觉了，购票是一个不太耗时的流程，而我现在因为同步调用，非要等待发送短信这个比较耗时的操作才返回结果。那我如果再加一个发送邮件呢？</p>\n<figure style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><img src=\"https://user-gold-cdn.xitu.io/2019/12/11/16ef380429cf373e?w=1364&amp;h=210&amp;f=jpeg&amp;s=28357\" alt=\"\" title=\"\" style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;\"><figcaption style=\"line-height: inherit; margin: 0px; padding: 0px; margin-top: 10px; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;\"></figcaption></figure>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">这样整个系统的调用链又变长了，整个时间就变成了550ms。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">当我们在学生时代需要在食堂排队的时候，我们和食堂大妈就是一个同步的模型。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">我们需要告诉食堂大妈：“姐姐，给我加个鸡腿，再加个酸辣土豆丝，帮我浇点汁上去，多打点饭哦😋😋😋”  咦~~~ 为了多吃点，真恶心。</p>\n<figure style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><img src=\"https://user-gold-cdn.xitu.io/2019/12/11/16ef3807de75dce5?w=170&amp;h=220&amp;f=gif&amp;s=489646\" alt=\"\" title=\"\" style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;\"><figcaption style=\"line-height: inherit; margin: 0px; padding: 0px; margin-top: 10px; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;\"></figcaption></figure>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">然后大妈帮我们打饭配菜，我们看着大妈那颤抖的手和掉落的土豆丝不禁咽了咽口水。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">最终我们从大妈手中接过饭菜然后去寻找座位了…</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">回想一下，我们在给大妈发送需要的信息之后我们是 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">同步等待大妈给我配好饭菜</strong> 的，上面我们只是加了鸡腿和土豆丝，万一我再加一个番茄牛腩，韭菜鸡蛋，这样是不是大妈打饭配菜的流程就会变长，我们等待的时间也会相应的变长。</p>\n<figure style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><img src=\"https://user-gold-cdn.xitu.io/2019/12/11/16ef380ae4f8be5b?w=250&amp;h=221&amp;f=jpeg&amp;s=8279\" alt=\"\" title=\"\" style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;\"><figcaption style=\"line-height: inherit; margin: 0px; padding: 0px; margin-top: 10px; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;\"></figcaption></figure>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">那后来，我们工作赚钱了有钱去饭店吃饭了，我们告诉服务员来一碗牛肉面加个荷包蛋 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">(传达一个消息)</strong> ，然后我们就可以在饭桌上安心的玩手机了 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">(干自己其他事情)</strong> ，等到我们的牛肉面上了我们就可以吃了。这其中我们也就传达了一个消息，然后我们又转过头干其他事情了。这其中虽然做面的时间没有变短，但是我们只需要传达一个消息就可以看其他事情了，这是一个 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">异步</strong> 的概念。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">所以，为了解决这一个问题，聪明的程序员在中间也加了个类似于服务员的中间件——消息队列。这个时候我们就可以把模型给改造了。</p>\n<figure style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><img src=\"https://user-gold-cdn.xitu.io/2019/12/11/16ef38124f55eaea?w=1194&amp;h=326&amp;f=jpeg&amp;s=47622\" alt=\"\" title=\"\" style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;\"><figcaption style=\"line-height: inherit; margin: 0px; padding: 0px; margin-top: 10px; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;\"></figcaption></figure>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">这样，我们在将消息存入消息队列之后我们就可以直接返回了(我们告诉服务员我们要吃什么然后玩手机)，所以整个耗时只是 150ms + 10ms = 160ms。</p>\n<blockquote style=\"line-height: inherit; display: block; padding: 15px 15px 15px 1rem; font-size: 1em; margin: 1em 0px; color: rgb(129, 145, 152); border-left: 8px solid rgb(255, 138, 101); background: rgb(224, 242, 241); overflow: auto; overflow-wrap: normal; word-break: normal; letter-spacing: 1.5px; font-family: YouYuan;\">\n  <p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 0px;\">但是你需要注意的是，整个流程的时长是没变的，就像你仅仅告诉服务员要吃什么是不会影响到做面的速度的。</p>\n</blockquote>\n<h4 id=\"h-5\" style=\"color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px; font-weight: bold; font-size: 1.2em;\"><span style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\">解耦</span></h4>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">回到最初同步调用的过程，我们写个伪代码简单概括一下。</p>\n<figure style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><img src=\"https://user-gold-cdn.xitu.io/2019/12/11/16ef381a505d3e1f?w=538&amp;h=337&amp;f=png&amp;s=42350\" alt=\"\" title=\"\" style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;\"><figcaption style=\"line-height: inherit; margin: 0px; padding: 0px; margin-top: 10px; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;\"></figcaption></figure>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">那么第二步，我们又添加了一个发送邮件，我们就得重新去修改代码，如果我们又加一个需求：用户购买完还需要给他加积分，这个时候我们是不是又得改代码？</p>\n<figure style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><img src=\"https://user-gold-cdn.xitu.io/2019/12/11/16ef381c4e1b1ac7?w=538&amp;h=463&amp;f=png&amp;s=53705\" alt=\"\" title=\"\" style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;\"><figcaption style=\"line-height: inherit; margin: 0px; padding: 0px; margin-top: 10px; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;\"></figcaption></figure>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">如果你觉得还行，那么我这个时候不要发邮件这个服务了呢，我是不是又得改代码，又得重启应用？</p>\n<figure style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><img src=\"https://user-gold-cdn.xitu.io/2019/12/11/16ef381f273a66bd?w=200&amp;h=200&amp;f=jpeg&amp;s=8544\" alt=\"\" title=\"\" style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;\"><figcaption style=\"line-height: inherit; margin: 0px; padding: 0px; margin-top: 10px; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;\"></figcaption></figure>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">这样改来改去是不是很麻烦，那么 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">此时我们就用一个消息队列在中间进行解耦</strong> 。你需要注意的是，我们后面的发送短信、发送邮件、添加积分等一些操作都依赖于上面的 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">result</code> ，这东西抽象出来就是购票的处理结果呀，比如订单号，用户账号等等，也就是说我们后面的一系列服务都是需要同样的消息来进行处理。既然这样，我们是不是可以通过 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">“广播消息”</strong> 来实现。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">我上面所讲的“广播”并不是真正的广播，而是接下来的系统作为消费者去 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">订阅</strong> 特定的主题。比如我们这里的主题就可以叫做 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">订票</code> ，我们购买系统作为一个生产者去生产这条消息放入消息队列，然后消费者订阅了这个主题，会从消息队列中拉取消息并消费。就比如我们刚刚画的那张图，你会发现，在生产者这边我们只需要关注 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">生产消息到指定主题中</strong> ，而 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">消费者只需要关注从指定主题中拉取消息</strong> 就行了。</p>\n<figure style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><img src=\"https://user-gold-cdn.xitu.io/2019/12/11/16ef382674b66892?w=1194&amp;h=326&amp;f=jpeg&amp;s=47622\" alt=\"\" title=\"\" style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;\"><figcaption style=\"line-height: inherit; margin: 0px; padding: 0px; margin-top: 10px; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;\"></figcaption></figure>\n<blockquote style=\"line-height: inherit; display: block; padding: 15px 15px 15px 1rem; font-size: 1em; margin: 1em 0px; color: rgb(129, 145, 152); border-left: 8px solid rgb(255, 138, 101); background: rgb(224, 242, 241); overflow: auto; overflow-wrap: normal; word-break: normal; letter-spacing: 1.5px; font-family: YouYuan;\">\n  <p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 0px;\">如果没有消息队列，每当一个新的业务接入，我们都要在主系统调用新接口、或者当我们取消某些业务，我们也得在主系统删除某些接口调用。有了消息队列，我们只需要关心消息是否送达了队列，至于谁希望订阅，接下来收到消息如何处理，是下游的事情，无疑极大地减少了开发和联调的工作量。</p>\n</blockquote>\n<h4 id=\"h-6\" style=\"color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px; font-weight: bold; font-size: 1.2em;\"><span style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\">削峰</span></h4>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">我们再次回到一开始我们使用同步调用系统的情况，并且思考一下，如果此时有大量用户请求购票整个系统会变成什么样？</p>\n<figure style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><img src=\"https://user-gold-cdn.xitu.io/2019/12/11/16ef382a9756bb1c?w=1048&amp;h=469&amp;f=jpeg&amp;s=38175\" alt=\"\" title=\"\" style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;\"><figcaption style=\"line-height: inherit; margin: 0px; padding: 0px; margin-top: 10px; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;\"></figcaption></figure>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">如果，此时有一万的请求进入购票系统，我们知道运行我们主业务的服务器配置一般会比较好，所以这里我们假设购票系统能承受这一万的用户请求，那么也就意味着我们同时也会出现一万调用发短信服务的请求。而对于短信系统来说并不是我们的主要业务，所以我们配备的硬件资源并不会太高，那么你觉得现在这个短信系统能承受这一万的峰值么，且不说能不能承受，系统会不会 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">直接崩溃</strong> 了？</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">短信业务又不是我们的主业务，我们能不能 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">折中处理</strong> 呢？如果我们把购买完成的信息发送到消息队列中，而短信系统 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">尽自己所能地去消息队列中取消息和消费消息</strong> ，即使处理速度慢一点也无所谓，只要我们的系统没有崩溃就行了。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">留得江山在，还怕没柴烧？你敢说每次发送验证码的时候是一发你就收到了的么？</p>\n<h4 id=\"h-7\" style=\"color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px; font-weight: bold; font-size: 1.2em;\"><span style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\">消息队列能带来什么好处？</span></h4>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">其实上面我已经说了。<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">异步、解耦、削峰。</strong> 哪怕你上面的都没看懂也千万要记住这六个字，因为他不仅是消息队列的精华，更是编程和架构的精华。</p>\n<h4 id=\"h-8\" style=\"color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px; font-weight: bold; font-size: 1.2em;\"><span style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\">消息队列会带来副作用吗？</span></h4>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">没有哪一门技术是“银弹”，消息队列也有它的副作用。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">比如，本来好好的两个系统之间的调用，我中间加了个消息队列，如果消息队列挂了怎么办呢？是不是 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">降低了系统的可用性</strong> ？</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">那这样是不是要保证HA(高可用)？是不是要搞集群？那么我 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">整个系统的复杂度是不是上升了</strong> ？</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">抛开上面的问题不讲，万一我发送方发送失败了，然后执行重试，这样就可能产生重复的消息。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">或者我消费端处理失败了，请求重发，这样也会产生重复的消息。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">对于一些微服务来说，消费重复消息会带来更大的麻烦，比如增加积分，这个时候我加了多次是不是对其他用户不公平？</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">那么，又 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">如何解决重复消费消息的问题</strong> 呢？</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">如果我们此时的消息需要保证严格的顺序性怎么办呢？比如生产者生产了一系列的有序消息(对一个id为1的记录进行删除增加修改)，但是我们知道在发布订阅模型中，对于主题是无顺序的，那么这个时候就会导致对于消费者消费消息的时候没有按照生产者的发送顺序消费，比如这个时候我们消费的顺序为修改删除增加，如果该记录涉及到金额的话是不是会出大事情？</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">那么，又 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">如何解决消息的顺序消费问题</strong> 呢？</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">就拿我们上面所讲的分布式系统来说，用户购票完成之后是不是需要增加账户积分？在同一个系统中我们一般会使用事务来进行解决，如果用 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Spring</code> 的话我们在上面伪代码中加入 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">@Transactional</code> 注解就好了。但是在不同系统中如何保证事务呢？总不能这个系统我扣钱成功了你那积分系统积分没加吧？或者说我这扣钱明明失败了，你那积分系统给我加了积分。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">那么，又如何 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">解决分布式事务问题</strong> 呢？</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">我们刚刚说了，消息队列可以进行削峰操作，那如果我的消费者如果消费很慢或者生产者生产消息很快，这样是不是会将消息堆积在消息队列中？</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">那么，又如何 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">解决消息堆积的问题</strong> 呢？</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">可用性降低，复杂度上升，又带来一系列的重复消费，顺序消费，分布式事务，消息堆积的问题，这消息队列还怎么用啊😵？</p>\n<figure style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><img src=\"https://user-gold-cdn.xitu.io/2019/12/11/16ef382d709abc9d?w=255&amp;h=255&amp;f=jpeg&amp;s=8169\" alt=\"\" title=\"\" style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;\"><figcaption style=\"line-height: inherit; margin: 0px; padding: 0px; margin-top: 10px; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;\"></figcaption></figure>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">别急，办法总是有的。</p>\n<h2 id=\"hrocketmq\" style=\"color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px; font-weight: bold; font-size: 1.5em; border-bottom: 2.2px solid rgb(255, 111, 0);\"><span style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; background: rgb(255, 111, 0); padding: 5px 15px; display: inline-block;\">RocketMQ是什么？</span></h2>\n<figure style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><img src=\"https://user-gold-cdn.xitu.io/2019/12/11/16ef383014430799?w=1450&amp;h=430&amp;f=jpeg&amp;s=103646\" alt=\"\" title=\"\" style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;\"><figcaption style=\"line-height: inherit; margin: 0px; padding: 0px; margin-top: 10px; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;\"></figcaption></figure>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">哇，你个混蛋！上面给我抛出那么多问题，你现在又讲 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> ，还让不让人活了？！🤬</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">别急别急，话说你现在清楚 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">MQ</code> 的构造吗，我还没讲呢，我们先搞明白 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">MQ</code> 的内部构造，再来看看如何解决上面的一系列问题吧，不过你最好带着问题去阅读和了解喔。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\"><code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 是一个 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">队列模型</strong> 的消息中间件，具有<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">高性能、高可靠、高实时、分布式</strong> 的特点。它是一个采用 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Java</code> 语言开发的分布式的消息系统，由阿里巴巴团队开发，在2016年底贡献给 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Apache</code>，成为了 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Apache</code> 的一个顶级项目。 在阿里内部，<code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 很好地服务了集团大大小小上千个应用，在每年的双十一当天，更有不可思议的万亿级消息通过 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 流转。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">废话不多说，想要了解 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 历史的同学可以自己去搜寻资料。听完上面的介绍，你只要知道 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 很快、很牛、而且经历过双十一的实践就行了！</p>\n<h2 id=\"h-9\" style=\"color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px; font-weight: bold; font-size: 1.5em; border-bottom: 2.2px solid rgb(255, 111, 0);\"><span style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; background: rgb(255, 111, 0); padding: 5px 15px; display: inline-block;\">队列模型和主题模型</span></h2>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">在谈 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 的技术架构之前，我们先来了解一下两个名词概念——<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">队列模型</strong> 和 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">主题模型</strong> 。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">首先我问一个问题，消息队列为什么要叫消息队列？</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">你可能觉得很弱智，这玩意不就是存放消息的队列嘛？不叫消息队列叫什么？</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">的确，早期的消息中间件是通过 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">队列</strong> 这一模型来实现的，可能是历史原因，我们都习惯把消息中间件成为消息队列。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">但是，如今例如 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 、<code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Kafka</code> 这些优秀的消息中间件不仅仅是通过一个 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">队列</strong> 来实现消息存储的。</p>\n<h3 id=\"h-10\" style=\"color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px; font-weight: bold; font-size: 1.3em;\"><span style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\">队列模型</span></h3>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">就像我们理解队列一样，消息中间件的队列模型就真的只是一个队列。。。我画一张图给大家理解。</p>\n<figure style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><img src=\"https://user-gold-cdn.xitu.io/2019/12/11/16ef3834ae653469?w=760&amp;h=142&amp;f=jpeg&amp;s=22424\" alt=\"\" title=\"\" style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;\"><figcaption style=\"line-height: inherit; margin: 0px; padding: 0px; margin-top: 10px; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;\"></figcaption></figure>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">在一开始我跟你提到了一个 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">“广播”</strong> 的概念，也就是说如果我们此时我们需要将一个消息发送给多个消费者(比如此时我需要将信息发送给短信系统和邮件系统)，这个时候单个队列即不能满足需求了。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">当然你可以让 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Producer</code> 生产消息放入多个队列中，然后每个队列去对应每一个消费者。问题是可以解决，创建多个队列并且复制多份消息是会很影响资源和性能的。而且，这样子就会导致生产者需要知道具体消费者个数然后去复制对应数量的消息队列，这就违背我们消息中间件的 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">解耦</strong> 这一原则。</p>\n<h3 id=\"h-11\" style=\"color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px; font-weight: bold; font-size: 1.3em;\"><span style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\">主题模型</span></h3>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">那么有没有好的方法去解决这一个问题呢？有，那就是 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">主题模型</strong> 或者可以称为 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">发布订阅模型</strong> 。</p>\n<blockquote style=\"line-height: inherit; display: block; padding: 15px 15px 15px 1rem; font-size: 1em; margin: 1em 0px; color: rgb(129, 145, 152); border-left: 8px solid rgb(255, 138, 101); background: rgb(224, 242, 241); overflow: auto; overflow-wrap: normal; word-break: normal; letter-spacing: 1.5px; font-family: YouYuan;\">\n  <p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 0px;\">感兴趣的同学可以去了解一下设计模式里面的观察者模式并且手动实现一下，我相信你会有所收获的。</p>\n</blockquote>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">在主题模型中，消息的生产者称为 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">发布者(Publisher)</strong> ，消息的消费者称为 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">订阅者(Subscriber)</strong> ，存放消息的容器称为 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">主题(Topic)</strong> 。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">其中，发布者将消息发送到指定主题中，订阅者需要 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">提前订阅主题</strong> 才能接受特定主题的消息。</p>\n<figure style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><img src=\"https://user-gold-cdn.xitu.io/2019/12/11/16ef3837887d9a54?w=760&amp;h=341&amp;f=jpeg&amp;s=47404\" alt=\"\" title=\"\" style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;\"><figcaption style=\"line-height: inherit; margin: 0px; padding: 0px; margin-top: 10px; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;\"></figcaption></figure>\n<h3 id=\"hrocketmq-1\" style=\"color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px; font-weight: bold; font-size: 1.3em;\"><span style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\">RocketMQ中的消息模型</span></h3>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\"><code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RockerMQ</code> 中的消息模型就是按照 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">主题模型</strong> 所实现的。你可能会好奇这个 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">主题</strong> 到底是怎么实现的呢？你上面也没有讲到呀！</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">其实对于主题模型的实现来说每个消息中间件的底层设计都是不一样的，就比如 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Kafka</code> 中的 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">分区</strong> ，<code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 中的 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">队列</strong> ，<code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RabbitMQ</code> 中的 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Exchange</code> 。我们可以理解为 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">主题模型/发布订阅模型</strong> 就是一个标准，那些中间件只不过照着这个标准去实现而已。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">所以，<code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 中的 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">主题模型</strong> 到底是如何实现的呢？首先我画一张图，大家尝试着去理解一下。</p>\n<figure style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><img src=\"https://user-gold-cdn.xitu.io/2019/12/11/16ef383d3e8c9788?w=1391&amp;h=555&amp;f=jpeg&amp;s=116552\" alt=\"\" title=\"\" style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;\"><figcaption style=\"line-height: inherit; margin: 0px; padding: 0px; margin-top: 10px; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;\"></figcaption></figure>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">我们可以看到在整个图中有 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Producer Group</code> 、<code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Topic</code> 、<code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Consumer Group</code>  三个角色，我来分别介绍一下他们。</p>\n<ul style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px; padding-left: 32px; list-style-type: disc;\">\n<li style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px; margin-bottom: 0.5em;\"><code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Producer Group</code> 生产者组： 代表某一类的生产者，比如我们有多个秒杀系统作为生产者，这多个合在一起就是一个 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Producer Group</code> 生产者组，它们一般生产相同的消息。</li>\n<li style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px; margin-bottom: 0.5em;\"><code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Consumer Group</code> 消费者组： 代表某一类的消费者，比如我们有多个短信系统作为消费者，这多个合在一起就是一个 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Consumer Group</code> 消费者组，它们一般消费相同的消息。</li>\n<li style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px; margin-bottom: 0.5em;\"><code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Topic</code> 主题： 代表一类消息，比如订单消息，物流消息等等。</li>\n</ul>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">你可以看到图中生产者组中的生产者会向主题发送消息，而 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">主题中存在多个队列</strong>，生产者每次生产消息之后是指定主题中的某个队列发送消息的。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">每个主题中都有多个队列(这里还不涉及到 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code>)，集群消费模式下，一个消费者集群多台机器共同消费一个 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">topic</code> 的多个队列，<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">一个队列只会被一个消费者消费</strong>。如果某个消费者挂掉，分组内其它消费者会接替挂掉的消费者继续消费。就像上图中 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Consumer1</code> 和 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Consumer2</code> 分别对应着两个队列，而 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Consuer3</code> 是没有队列对应的，所以一般来讲要控制 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">消费者组中的消费者个数和主题中队列个数相同</strong> 。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">当然也可以消费者个数小于队列个数，只不过不太建议。如下图。</p>\n<figure style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><img src=\"https://user-gold-cdn.xitu.io/2019/12/11/16ef3850c808d707?w=910&amp;h=261&amp;f=jpeg&amp;s=43637\" alt=\"\" title=\"\" style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;\"><figcaption style=\"line-height: inherit; margin: 0px; padding: 0px; margin-top: 10px; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;\"></figcaption></figure>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\"><strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">每个消费组在每个队列上维护一个消费位置</strong> ，为什么呢？</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">因为我们刚刚画的仅仅是一个消费者组，我们知道在发布订阅模式中一般会涉及到多个消费者组，而每个消费者组在每个队列中的消费位置都是不同的。如果此时有多个消费者组，那么消息被一个消费者组消费完之后是不会删除的(因为其它消费者组也需要呀)，它仅仅是为每个消费者组维护一个 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">消费位移(offset)</strong> ，每次消费者组消费完会返回一个成功的响应，然后队列再把维护的消费位移加一，这样就不会出现刚刚消费过的消息再一次被消费了。</p>\n<figure style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><img src=\"https://user-gold-cdn.xitu.io/2019/12/11/16ef3857fefaa079?w=1251&amp;h=599&amp;f=jpeg&amp;s=130119\" alt=\"\" title=\"\" style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;\"><figcaption style=\"line-height: inherit; margin: 0px; padding: 0px; margin-top: 10px; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;\"></figcaption></figure>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">可能你还有一个问题，<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">为什么一个主题中需要维护多个队列</strong> ？</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">答案是 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">提高并发能力</strong> 。的确，每个主题中只存在一个队列也是可行的。你想一下，如果每个主题中只存在一个队列，这个队列中也维护着每个消费者组的消费位置，这样也可以做到 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">发布订阅模式</strong> 。如下图。</p>\n<figure style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><img src=\"https://user-gold-cdn.xitu.io/2019/12/11/16ef38600cdb6d4b?w=1271&amp;h=632&amp;f=jpeg&amp;s=128950\" alt=\"\" title=\"\" style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;\"><figcaption style=\"line-height: inherit; margin: 0px; padding: 0px; margin-top: 10px; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;\"></figcaption></figure>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">但是，这样我生产者是不是只能向一个队列发送消息？又因为需要维护消费位置所以一个队列只能对应一个消费者组中的消费者，这样是不是其他的 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Consumer</code> 就没有用武之地了？从这两个角度来讲，并发度一下子就小了很多。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">所以总结来说，<code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 通过<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">使用在一个 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Topic</code> 中配置多个队列并且每个队列维护每个消费者组的消费位置</strong> 实现了 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">主题模式/发布订阅模式</strong> 。</p>\n<h2 id=\"hrocketmq-2\" style=\"color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px; font-weight: bold; font-size: 1.5em; border-bottom: 2.2px solid rgb(255, 111, 0);\"><span style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; background: rgb(255, 111, 0); padding: 5px 15px; display: inline-block;\">RocketMQ的架构图</span></h2>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">讲完了消息模型，我们理解起 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 的技术架构起来就容易多了。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\"><code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 技术架构中有四大角色 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">NameServer</code> 、<code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 、<code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Producer</code> 、<code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Consumer</code> 。我来向大家分别解释一下这四个角色是干啥的。</p>\n<ul style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px; padding-left: 32px; list-style-type: disc;\">\n<li style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px; margin-bottom: 0.5em;\"><p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\"><code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code>： 主要负责消息的存储、投递和查询以及服务高可用保证。说白了就是消息队列服务器嘛，生产者生产消息到 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> ，消费者从 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 拉取消息并消费。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">这里，我还得普及一下关于 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 、<code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Topic</code> 和 队列的关系。上面我讲解了 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Topic</code> 和队列的关系——一个 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Topic</code> 中存在多个队列，那么这个 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Topic</code> 和队列存放在哪呢？</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\"><strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">一个 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Topic</code> 分布在多个 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code>上，一个 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 可以配置多个 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Topic</code> ，它们是多对多的关系</strong>。 </p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">如果某个 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Topic</code> 消息量很大，应该给它多配置几个队列(上文中提到了提高并发能力)，并且 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">尽量多分布在不同 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 上，以减轻某个 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 的压力</strong> 。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\"><code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Topic</code> 消息量都比较均匀的情况下，如果某个 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">broker</code> 上的队列越多，则该 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">broker</code> 压力越大。</p>\n<figure style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><img src=\"https://user-gold-cdn.xitu.io/2019/12/11/16ef38687488a5a4?w=936&amp;h=673&amp;f=jpeg&amp;s=93578\" alt=\"\" title=\"\" style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;\"><figcaption style=\"line-height: inherit; margin: 0px; padding: 0px; margin-top: 10px; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;\"></figcaption></figure></li>\n</ul>\n<blockquote style=\"line-height: inherit; display: block; padding: 15px 15px 15px 1rem; font-size: 1em; margin: 1em 0px; color: rgb(129, 145, 152); border-left: 8px solid rgb(255, 138, 101); background: rgb(224, 242, 241); overflow: auto; overflow-wrap: normal; word-break: normal; letter-spacing: 1.5px; font-family: YouYuan;\">\n  <p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 0px;\">所以说我们需要配置多个Broker。</p>\n</blockquote>\n<ul style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px; padding-left: 32px; list-style-type: disc;\">\n<li style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px; margin-bottom: 0.5em;\"><p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\"><code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">NameServer</code>： 不知道你们有没有接触过 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">ZooKeeper</code> 和 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Spring Cloud</code> 中的 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Eureka</code> ，它其实也是一个 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">注册中心</strong> ，主要提供两个功能：<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">Broker管理</strong> 和 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">路由信息管理</strong> 。说白了就是 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 会将自己的信息注册到 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">NameServer</code> 中，此时 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">NameServer</code> 就存放了很多 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 的信息(Broker的路由表)，消费者和生产者就从 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">NameServer</code> 中获取路由表然后照着路由表的信息和对应的 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 进行通信(生产者和消费者定期会向 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">NameServer</code> 去查询相关的 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 的信息)。</p></li>\n<li style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px; margin-bottom: 0.5em;\"><p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\"><code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Producer</code>： 消息发布的角色，支持分布式集群方式部署。说白了就是生产者。</p></li>\n<li style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px; margin-bottom: 0.5em;\"><p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\"><code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Consumer</code>： 消息消费的角色，支持分布式集群方式部署。支持以push推，pull拉两种模式对消息进行消费。同时也支持集群方式和广播方式的消费，它提供实时消息订阅机制。说白了就是消费者。</p></li>\n</ul>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">听完了上面的解释你可能会觉得，这玩意好简单。不就是这样的么？</p>\n<figure style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><img src=\"https://user-gold-cdn.xitu.io/2019/12/11/16ef386c6d1e8bdb?w=1237&amp;h=454&amp;f=jpeg&amp;s=93637\" alt=\"\" title=\"\" style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;\"><figcaption style=\"line-height: inherit; margin: 0px; padding: 0px; margin-top: 10px; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;\"></figcaption></figure>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">嗯？你可能会发现一个问题，这老家伙 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">NameServer</code> 干啥用的，这不多余吗？直接 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Producer</code> 、<code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Consumer</code> 和 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 直接进行生产消息，消费消息不就好了么？</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">但是，我们上文提到过 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 是需要保证高可用的，如果整个系统仅仅靠着一个 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 来维持的话，那么这个 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 的压力会不会很大？所以我们需要使用多个 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 来保证 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">负载均衡</strong> 。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">如果说，我们的消费者和生产者直接和多个 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 相连，那么当 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 修改的时候必定会牵连着每个生产者和消费者，这样就会产生耦合问题，而 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">NameServer</code> 注册中心就是用来解决这个问题的。</p>\n<blockquote style=\"line-height: inherit; display: block; padding: 15px 15px 15px 1rem; font-size: 1em; margin: 1em 0px; color: rgb(129, 145, 152); border-left: 8px solid rgb(255, 138, 101); background: rgb(224, 242, 241); overflow: auto; overflow-wrap: normal; word-break: normal; letter-spacing: 1.5px; font-family: YouYuan;\">\n  <p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 0px;\">如果还不是很理解的话，可以去看我介绍 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Spring Cloud</code> 的那篇文章，其中介绍了 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Eureka</code> 注册中心。</p>\n</blockquote>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">当然，<code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 中的技术架构肯定不止前面那么简单，因为上面图中的四个角色都是需要做集群的。我给出一张官网的架构图，大家尝试理解一下。</p>\n<figure style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><img src=\"https://user-gold-cdn.xitu.io/2019/12/11/16ef386fa3be1e53?w=1281&amp;h=522&amp;f=jpeg&amp;s=66376\" alt=\"\" title=\"\" style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;\"><figcaption style=\"line-height: inherit; margin: 0px; padding: 0px; margin-top: 10px; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;\"></figcaption></figure>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">其实和我们最开始画的那张乞丐版的架构图也没什么区别，主要是一些细节上的差别。听我细细道来🤨。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">第一、我们的 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">做了集群并且还进行了主从部署</strong> ，由于消息分布在各个 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 上，一旦某个 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 宕机，则该<code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 上的消息读写都会受到影响。所以 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Rocketmq</code> 提供了 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">master/slave</code> 的结构，<code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">salve</code> 定时从 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">master</code> 同步数据(同步刷盘或者异步刷盘)，如果 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">master</code> 宕机，<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">则 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">slave</code> 提供消费服务，但是不能写入消息</strong> (后面我还会提到哦)。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">第二、为了保证 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">HA</code> ，我们的 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">NameServer</code> 也做了集群部署，但是请注意它是 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">去中心化</strong> 的。也就意味着它没有主节点，你可以很明显地看出 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">NameServer</code> 的所有节点是没有进行 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Info Replicate</code> 的，在 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 中是通过 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">单个Broker和所有NameServer保持长连接</strong> ，并且在每隔30秒 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 会向所有 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Nameserver</code> 发送心跳，心跳包含了自身的 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Topic</code> 配置信息，这个步骤就对应这上面的 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Routing Info</code> 。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">第三、在生产者需要向 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 发送消息的时候，<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">需要先从 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">NameServer</code> 获取关于 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 的路由信息</strong>，然后通过 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">轮询</strong> 的方法去向每个队列中生产数据以达到 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">负载均衡</strong> 的效果。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">第四、消费者通过 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">NameServer</code> 获取所有 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 的路由信息后，向 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 发送 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Pull</code> 请求来获取消息数据。<code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Consumer</code> 可以以两种模式启动—— <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">广播（Broadcast）和集群（Cluster）</strong>。广播模式下，一条消息会发送给 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">同一个消费组中的所有消费者</strong> ，集群模式下消息只会发送给一个消费者。</p>\n<h2 id=\"h-12\" style=\"color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px; font-weight: bold; font-size: 1.5em; border-bottom: 2.2px solid rgb(255, 111, 0);\"><span style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; background: rgb(255, 111, 0); padding: 5px 15px; display: inline-block;\">如何解决 顺序消费、重复消费</span></h2>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">其实，这些东西都是我在介绍消息队列带来的一些副作用的时候提到的，也就是说，这些问题不仅仅挂钩于 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> ，而是应该每个消息中间件都需要去解决的。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">在上面我介绍 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 的技术架构的时候我已经向你展示了 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">它是如何保证高可用的</strong> ，这里不涉及运维方面的搭建，如果你感兴趣可以自己去官网上照着例子搭建属于你自己的 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 集群。</p>\n<blockquote style=\"line-height: inherit; display: block; padding: 15px 15px 15px 1rem; font-size: 1em; margin: 1em 0px; color: rgb(129, 145, 152); border-left: 8px solid rgb(255, 138, 101); background: rgb(224, 242, 241); overflow: auto; overflow-wrap: normal; word-break: normal; letter-spacing: 1.5px; font-family: YouYuan;\">\n  <p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 0px;\">其实 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Kafka</code> 的架构基本和 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 类似，只是它注册中心使用了 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Zookeeper</code> 、它的 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">分区</strong> 就相当于 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 中的 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">队列</strong> 。还有一些小细节不同会在后面提到。</p>\n</blockquote>\n<h3 id=\"h-13\" style=\"color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px; font-weight: bold; font-size: 1.3em;\"><span style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\">顺序消费</span></h3>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">在上面的技术架构介绍中，我们已经知道了 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\"><code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 在主题上是无序的、它只有在队列层面才是保证有序</strong> 的。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">这又扯到两个概念——<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">普通顺序</strong> 和 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">严格顺序</strong> 。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">所谓普通顺序是指 消费者通过 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">同一个消费队列收到的消息是有顺序的</strong> ，不同消息队列收到的消息则可能是无顺序的。普通顺序消息在 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">重启情况下不会保证消息顺序性</strong> (短暂时间) 。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">所谓严格顺序是指  消费者收到的 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">所有消息</strong> 均是有顺序的。严格顺序消息 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">即使在异常情况下也会保证消息的顺序性</strong> 。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">但是，严格顺序看起来虽好，实现它可会付出巨大的代价。如果你使用严格顺序模式，<code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 集群中只要有一台机器不可用，则整个集群都不可用。你还用啥？现在主要场景也就在 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">binlog</code> 同步。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">一般而言，我们的 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">MQ</code> 都是能容忍短暂的乱序，所以推荐使用普通顺序模式。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">那么，我们现在使用了 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">普通顺序模式</strong> ，我们从上面学习知道了在 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Producer</code> 生产消息的时候会进行轮询(取决你的负载均衡策略)来向同一主题的不同消息队列发送消息。那么如果此时我有几个消息分别是同一个订单的创建、支付、发货，在轮询的策略下这 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">三个消息会被发送到不同队列</strong> ，因为在不同的队列此时就无法使用 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 带来的队列有序特性来保证消息有序性了。</p>\n<figure style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><img src=\"https://user-gold-cdn.xitu.io/2019/12/11/16ef3874585e096e?w=1258&amp;h=484&amp;f=jpeg&amp;s=90329\" alt=\"\" title=\"\" style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;\"><figcaption style=\"line-height: inherit; margin: 0px; padding: 0px; margin-top: 10px; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;\"></figcaption></figure>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">那么，怎么解决呢？</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">其实很简单，我们需要处理的仅仅是将同一语义下的消息放入同一个队列(比如这里是同一个订单)，那我们就可以使用 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">Hash取模法</strong> 来保证同一个订单在同一个队列中就行了。</p>\n<h3 id=\"h-14\" style=\"color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px; font-weight: bold; font-size: 1.3em;\"><span style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\">重复消费</span></h3>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">emmm，就两个字—— <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">幂等</strong> 。在编程中一个<em style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px; font-style: italic;\">幂等</em> 操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。比如说，这个时候我们有一个订单的处理积分的系统，每当来一个消息的时候它就负责为创建这个订单的用户的积分加上相应的数值。可是有一次，消息队列发送给订单系统 FrancisQ 的订单信息，其要求是给 FrancisQ 的积分加上 500。但是积分系统在收到 FrancisQ 的订单信息处理完成之后返回给消息队列处理成功的信息的时候出现了网络波动(当然还有很多种情况，比如Broker意外重启等等)，这条回应没有发送成功。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">那么，消息队列没收到积分系统的回应会不会尝试重发这个消息？问题就来了，我再发这个消息，万一它又给 FrancisQ 的账户加上 500 积分怎么办呢？</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">所以我们需要给我们的消费者实现 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">幂等</strong> ，也就是对同一个消息的处理结果，执行多少次都不变。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">那么如何给业务实现幂等呢？这个还是需要结合具体的业务的。你可以使用 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">写入 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Redis</code></strong> 来保证，因为 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Redis</code> 的 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">key</code> 和 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">value</code> 就是天然支持幂等的。当然还有使用 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">数据库插入法</strong> ，基于数据库的唯一键来保证重复数据不会被插入多条。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">不过最主要的还是需要 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">根据特定场景使用特定的解决方案</strong> ，你要知道你的消息消费是否是完全不可重复消费还是可以忍受重复消费的，然后再选择强校验和弱校验的方式。毕竟在 CS 领域还是很少有技术银弹的说法。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">而在整个互联网领域，幂等不仅仅适用于消息队列的重复消费问题，这些实现幂等的方法，也同样适用于，<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">在其他场景中来解决重复请求或者重复调用的问题</strong> 。比如将HTTP服务设计成幂等的，<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">解决前端或者APP重复提交表单数据的问题</strong> ，也可以将一个微服务设计成幂等的，解决 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RPC</code> 框架自动重试导致的 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">重复调用问题</strong> 。</p>\n<h2 id=\"h-15\" style=\"color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px; font-weight: bold; font-size: 1.5em; border-bottom: 2.2px solid rgb(255, 111, 0);\"><span style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; background: rgb(255, 111, 0); padding: 5px 15px; display: inline-block;\">分布式事务</span></h2>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">如何解释分布式事务呢？事务大家都知道吧？<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">要么都执行要么都不执行</strong> 。在同一个系统中我们可以轻松地实现事务，但是在分布式架构中，我们有很多服务是部署在不同系统之间的，而不同服务之间又需要进行调用。比如此时我下订单然后增加积分，如果保证不了分布式事务的话，就会出现A系统下了订单，但是B系统增加积分失败或者A系统没有下订单，B系统却增加了积分。前者对用户不友好，后者对运营商不利，这是我们都不愿意见到的。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">那么，如何去解决这个问题呢？</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">如今比较常见的分布式事务实现有 2PC、TCC 和事务消息(half 半消息机制)。每一种实现都有其特定的使用场景，但是也有各自的问题，<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">都不是完美的解决方案</strong>。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">在 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 中使用的是 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">事务消息加上事务反查机制</strong> 来解决分布式事务问题的。我画了张图，大家可以对照着图进行理解。</p>\n<figure style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><img src=\"https://user-gold-cdn.xitu.io/2019/12/11/16ef38798d7a987f?w=1355&amp;h=360&amp;f=jpeg&amp;s=107566\" alt=\"\" title=\"\" style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;\"><figcaption style=\"line-height: inherit; margin: 0px; padding: 0px; margin-top: 10px; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;\"></figcaption></figure>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">在第一步发送的 half 消息 ，它的意思是 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">在事务提交之前，对于消费者来说，这个消息是不可见的</strong> 。</p>\n<blockquote style=\"line-height: inherit; display: block; padding: 15px 15px 15px 1rem; font-size: 1em; margin: 1em 0px; color: rgb(129, 145, 152); border-left: 8px solid rgb(255, 138, 101); background: rgb(224, 242, 241); overflow: auto; overflow-wrap: normal; word-break: normal; letter-spacing: 1.5px; font-family: YouYuan;\">\n  <p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 0px;\">那么，如何做到写入消息但是对用户不可见呢？RocketMQ事务消息的做法是：如果消息是half消息，将备份原消息的主题与消息消费队列，然后 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">改变主题</strong> 为RMQ_SYS_TRANS_HALF_TOPIC。由于消费组未订阅该主题，故消费端无法消费half类型的消息，<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">然后RocketMQ会开启一个定时任务，从Topic为RMQ_SYS_TRANS_HALF_TOPIC中拉取消息进行消费</strong>，根据生产者组获取一个服务提供者发送回查事务状态请求，根据事务状态来决定是提交或回滚消息。</p>\n</blockquote>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">你可以试想一下，如果没有从第5步开始的 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">事务反查机制</strong> ，如果出现网路波动第4步没有发送成功，这样就会产生 MQ 不知道是不是需要给消费者消费的问题，他就像一个无头苍蝇一样。在 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 中就是使用的上述的事务反查来解决的，而在 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Kafka</code> 中通常是直接抛出一个异常让用户来自行解决。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">你还需要注意的是，在 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">MQ Server</code> 指向系统B的操作已经和系统A不相关了，也就是说在消息队列中的分布式事务是——<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">本地事务和存储消息到消息队列才是同一个事务</strong>。这样也就产生了事务的<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">最终一致性</strong>，因为整个过程是异步的，<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">每个系统只要保证它自己那一部分的事务就行了</strong>。</p>\n<h2 id=\"h-16\" style=\"color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px; font-weight: bold; font-size: 1.5em; border-bottom: 2.2px solid rgb(255, 111, 0);\"><span style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; background: rgb(255, 111, 0); padding: 5px 15px; display: inline-block;\">消息堆积问题</span></h2>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">在上面我们提到了消息队列一个很重要的功能——<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">削峰</strong> 。那么如果这个峰值太大了导致消息堆积在队列中怎么办呢？</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">其实这个问题可以将它广义化，因为产生消息堆积的根源其实就只有两个——生产者生产太快或者消费者消费太慢。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">我们可以从多个角度去思考解决这个问题，当流量到峰值的时候是因为生产者生产太快，我们可以使用一些 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">限流降级</strong> 的方法，当然你也可以增加多个消费者实例去水平扩展增加消费能力来匹配生产的激增。如果消费者消费过慢的话，我们可以先检查 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">是否是消费者出现了大量的消费错误</strong> ，或者打印一下日志查看是否是哪一个线程卡死，出现了锁资源不释放等等的问题。</p>\n<blockquote style=\"line-height: inherit; display: block; padding: 15px 15px 15px 1rem; font-size: 1em; margin: 1em 0px; color: rgb(129, 145, 152); border-left: 8px solid rgb(255, 138, 101); background: rgb(224, 242, 241); overflow: auto; overflow-wrap: normal; word-break: normal; letter-spacing: 1.5px; font-family: YouYuan;\">\n  <p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 0px;\">当然，最快速解决消息堆积问题的方法还是增加消费者实例，不过 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">同时你还需要增加每个主题的队列数量</strong> 。</p>\n  <p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 0px;\">别忘了在 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 中，<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">一个队列只会被一个消费者消费</strong> ，如果你仅仅是增加消费者实例就会出现我一开始给你画架构图的那种情况。</p>\n</blockquote>\n<figure style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><img src=\"https://user-gold-cdn.xitu.io/2019/12/11/16ef387d939ab66d?w=1391&amp;h=555&amp;f=jpeg&amp;s=116552\" alt=\"\" title=\"\" style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;\"><figcaption style=\"line-height: inherit; margin: 0px; padding: 0px; margin-top: 10px; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;\"></figcaption></figure>\n<h2 id=\"h-17\" style=\"color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px; font-weight: bold; font-size: 1.5em; border-bottom: 2.2px solid rgb(255, 111, 0);\"><span style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; background: rgb(255, 111, 0); padding: 5px 15px; display: inline-block;\">回溯消费</span></h2>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">回溯消费是指 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Consumer</code> 已经消费成功的消息，由于业务上需求需要重新消费，在<code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 中， <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 在向<code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Consumer</code> 投递成功消息后，<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">消息仍然需要保留</strong> 。并且重新消费一般是按照时间维度，例如由于 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Consumer</code> 系统故障，恢复后需要重新消费1小时前的数据，那么 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 要提供一种机制，可以按照时间维度来回退消费进度。<code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 支持按照时间回溯消费，时间维度精确到毫秒。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">这是官方文档的解释，我直接照搬过来就当科普了😁😁😁。</p>\n<h2 id=\"hrocketmq-3\" style=\"color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px; font-weight: bold; font-size: 1.5em; border-bottom: 2.2px solid rgb(255, 111, 0);\"><span style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; background: rgb(255, 111, 0); padding: 5px 15px; display: inline-block;\">RocketMQ 的刷盘机制</span></h2>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">上面我讲了那么多的 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 的架构和设计原理，你有没有好奇</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">在 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Topic</code> 中的 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">队列是以什么样的形式存在的？</strong></p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\"><strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">队列中的消息又是如何进行存储持久化的呢？</strong></p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">我在上文中提到的 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">同步刷盘</strong> 和 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">异步刷盘</strong> 又是什么呢？它们会给持久化带来什么样的影响呢？</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">下面我将给你们一一解释。</p>\n<h3 id=\"h-18\" style=\"color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px; font-weight: bold; font-size: 1.3em;\"><span style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\">同步刷盘和异步刷盘</span></h3>\n<figure style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><img src=\"https://user-gold-cdn.xitu.io/2019/12/11/16ef387fba311cda?w=1101&amp;h=874&amp;f=jpeg&amp;s=101763\" alt=\"\" title=\"\" style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;\"><figcaption style=\"line-height: inherit; margin: 0px; padding: 0px; margin-top: 10px; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;\"></figcaption></figure>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">如上图所示，在同步刷盘中需要等待一个刷盘成功的 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">ACK</code> ，同步刷盘对 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">MQ</code> 消息可靠性来说是一种不错的保障，但是 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">性能上会有较大影响</strong> ，一般地适用于金融等特定业务场景。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">而异步刷盘往往是开启一个线程去异步地执行刷盘操作。消息刷盘采用后台异步线程提交的方式进行， <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">降低了读写延迟</strong> ，提高了 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">MQ</code> 的性能和吞吐量，一般适用于如发验证码等对于消息保证要求不太高的业务场景。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">一般地，<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">异步刷盘只有在 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 意外宕机的时候会丢失部分数据</strong>，你可以设置 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 的参数 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">FlushDiskType</code> 来调整你的刷盘策略(ASYNC_FLUSH 或者 SYNC_FLUSH)。</p>\n<h3 id=\"h-19\" style=\"color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px; font-weight: bold; font-size: 1.3em;\"><span style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\">同步复制和异步复制</span></h3>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">上面的同步刷盘和异步刷盘是在单个结点层面的，而同步复制和异步复制主要是指的 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Borker</code> 主从模式下，主节点返回消息给客户端的时候是否需要同步从节点。</p>\n<ul style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px; padding-left: 32px; list-style-type: disc;\">\n<li style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px; margin-bottom: 0.5em;\">同步复制： 也叫 “同步双写”，也就是说，<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">只有消息同步双写到主从结点上时才返回写入成功</strong> 。</li>\n<li style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px; margin-bottom: 0.5em;\">异步复制： <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">消息写入主节点之后就直接返回写入成功</strong> 。</li>\n</ul>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">然而，很多事情是没有完美的方案的，就比如我们进行消息写入的节点越多就更能保证消息的可靠性，但是随之的性能也会下降，所以需要程序员根据特定业务场景去选择适应的主从复制方案。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">那么，<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">异步复制会不会也像异步刷盘那样影响消息的可靠性呢？</strong></p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">答案是不会的，因为两者就是不同的概念，对于消息可靠性是通过不同的刷盘策略保证的，而像异步同步复制策略仅仅是影响到了 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">可用性</strong> 。为什么呢？其主要原因<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">是 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 是不支持自动主从切换的，当主节点挂掉之后，生产者就不能再给这个主节点生产消息了</strong>。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">比如这个时候采用异步复制的方式，在主节点还未发送完需要同步的消息的时候主节点挂掉了，这个时候从节点就少了一部分消息。但是此时生产者无法再给主节点生产消息了，<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">消费者可以自动切换到从节点进行消费</strong>(仅仅是消费)，所以在主节点挂掉的时间只会产生主从结点短暂的消息不一致的情况，降低了可用性，而当主节点重启之后，从节点那部分未来得及复制的消息还会继续复制。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">在单主从架构中，如果一个主节点挂掉了，那么也就意味着整个系统不能再生产了。那么这个可用性的问题能否解决呢？<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">一个主从不行那就多个主从的呗</strong>，别忘了在我们最初的架构图中，每个 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Topic</code> 是分布在不同 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 中的。</p>\n<figure style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><img src=\"https://user-gold-cdn.xitu.io/2019/12/11/16ef38823b165817?w=936&amp;h=673&amp;f=jpeg&amp;s=93578\" alt=\"\" title=\"\" style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;\"><figcaption style=\"line-height: inherit; margin: 0px; padding: 0px; margin-top: 10px; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;\"></figcaption></figure>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">但是这种复制方式同样也会带来一个问题，那就是无法保证 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">严格顺序</strong> 。在上文中我们提到了如何保证的消息顺序性是通过将一个语义的消息发送在同一个队列中，使用 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Topic</code> 下的队列来保证顺序性的。如果此时我们主节点A负责的是订单A的一系列语义消息，然后它挂了，这样其他节点是无法代替主节点A的，如果我们任意节点都可以存入任何消息，那就没有顺序性可言了。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">而在 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 中采用了 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Dledger</code> 解决这个问题。他要求在写入消息的时候，要求<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">至少消息复制到半数以上的节点之后</strong>，才给客⼾端返回写⼊成功，并且它是⽀持通过选举来动态切换主节点的。这里我就不展开说明了，读者可以自己去了解。</p>\n<blockquote style=\"line-height: inherit; display: block; padding: 15px 15px 15px 1rem; font-size: 1em; margin: 1em 0px; color: rgb(129, 145, 152); border-left: 8px solid rgb(255, 138, 101); background: rgb(224, 242, 241); overflow: auto; overflow-wrap: normal; word-break: normal; letter-spacing: 1.5px; font-family: YouYuan;\">\n  <p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 0px;\">也不是说 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Dledger</code> 是个完美的方案，至少在 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Dledger</code> 选举过程中是无法提供服务的，而且他必须要使用三个节点或以上，如果多数节点同时挂掉他也是无法保证可用性的，而且要求消息复制板书以上节点的效率和直接异步复制还是有一定的差距的。</p>\n</blockquote>\n<h3 id=\"h-20\" style=\"color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px; font-weight: bold; font-size: 1.3em;\"><span style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\">存储机制</span></h3>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">还记得上面我们一开始的三个问题吗？到这里第三个问题已经解决了。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">但是，在 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Topic</code> 中的 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">队列是以什么样的形式存在的？队列中的消息又是如何进行存储持久化的呢？</strong> 还未解决，其实这里涉及到了 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 是如何设计它的存储结构了。我首先想大家介绍 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 消息存储架构中的三大角色——<code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">CommitLog</code> 、<code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">ConsumeQueue</code> 和 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">IndexFile</code> 。</p>\n<ul style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px; padding-left: 32px; list-style-type: disc;\">\n<li style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px; margin-bottom: 0.5em;\"><code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">CommitLog</code>： <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">消息主体以及元数据的存储主体</strong>，存储 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Producer</code> 端写入的消息主体内容,消息内容不是定长的。单个文件大小默认1G ，文件名长度为20位，左边补零，剩余为起始偏移量，比如00000000000000000000代表了第一个文件，起始偏移量为0，文件大小为1G=1073741824；当第一个文件写满了，第二个文件为00000000001073741824，起始偏移量为1073741824，以此类推。消息主要是<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">顺序写入日志文件</strong>，当文件满了，写入下一个文件。</li>\n<li style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px; margin-bottom: 0.5em;\"><code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">ConsumeQueue</code>： 消息消费队列，<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">引入的目的主要是提高消息消费的性能</strong>(我们再前面也讲了)，由于<code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 是基于主题 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Topic</code> 的订阅模式，消息消费是针对主题进行的，如果要遍历 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">commitlog</code> 文件中根据 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Topic</code> 检索消息是非常低效的。<code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Consumer</code> 即可根据 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">ConsumeQueue</code> 来查找待消费的消息。其中，<code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">ConsumeQueue</code>（逻辑消费队列）<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">作为消费消息的索引</strong>，保存了指定 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Topic</code> 下的队列消息在 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">CommitLog</code> 中的 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">起始物理偏移量</strong> <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">offset</code>，<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">消息大小</strong><code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">size</code> 和消息 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Tag</code> 的 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">HashCode</code> 值。<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">consumequeue文件</strong> 可以看成是基于topic的 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">commitlog索引文件</strong> ，故 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">consumequeue</code> 文件夹的组织方式如下：topic/queue/file三层组织结构，具体存储路径为：$HOME/store/consumequeue/{topic}/{queueId}/{fileName}。同样 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">consumequeue</code> 文件采取定长设计，每一个条目共20个字节，分别为8字节的 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">commitlog</code> 物理偏移量、4字节的消息长度、8字节tag <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">hashcode</code>，单个文件由30W个条目组成，可以像数组一样随机访问每一个条目，每个 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">ConsumeQueue</code>文件大小约5.72M；</li>\n<li style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px; margin-bottom: 0.5em;\"><code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">IndexFile</code>： <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">IndexFile</code>（索引文件）提供了一种可以通过key或时间区间来查询消息的方法。这里只做科普不做详细介绍。</li>\n</ul>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">总结来说，整个消息存储的结构，最主要的就是 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">CommitLoq</code> 和 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">ConsumeQueue</code> 。而 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">ConsumeQueue</code> 你可以大概理解为 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Topic</code> 中的队列。</p>\n<figure style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><img src=\"https://user-gold-cdn.xitu.io/2019/12/11/16ef3884c02acc72?w=745&amp;h=341&amp;f=jpeg&amp;s=51683\" alt=\"\" title=\"\" style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;\"><figcaption style=\"line-height: inherit; margin: 0px; padding: 0px; margin-top: 10px; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;\"></figcaption></figure>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\"><code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 采用的是 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">混合型的存储结构</strong> ，即为 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 单个实例下所有的队列共用一个日志数据文件来存储消息。有意思的是在同样高并发的 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Kafka</code> 中会为每个 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Topic</code> 分配一个存储文件。这就有点类似于我们有一大堆书需要装上书架，<code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RockeMQ</code> 是不分书的种类直接成批的塞上去的，而 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Kafka</code> 是将书本放入指定的分类区域的。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">而 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 为什么要这么做呢？原因是 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">提高数据的写入效率</strong> ，不分 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Topic</code> 意味着我们有更大的几率获取 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">成批</strong> 的消息进行数据写入，但也会带来一个麻烦就是读取消息的时候需要遍历整个大文件，这是非常耗时的。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">所以，在 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 中又使用了 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">ConsumeQueue</code> 作为每个队列的索引文件来 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">提升读取消息的效率</strong>。我们可以直接根据队列的消息序号，计算出索引的全局位置（索引序号*索引固定⻓度20），然后直接读取这条索引，再根据索引中记录的消息的全局位置，找到消息。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">讲到这里，你可能对 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RockeMQ</code> 的存储架构还有些模糊，没事，我们结合着图来理解一下。</p>\n<figure style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><img src=\"https://user-gold-cdn.xitu.io/2019/12/11/16ef388763c25c62?w=1142&amp;h=896&amp;f=png&amp;s=111170\" alt=\"\" title=\"\" style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;\"><figcaption style=\"line-height: inherit; margin: 0px; padding: 0px; margin-top: 10px; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;\"></figcaption></figure>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">emmm，是不是有一点复杂🤣，看英文图片和英文文档的时候就不要怂，硬着头皮往下看就行。</p>\n<blockquote style=\"line-height: inherit; display: block; padding: 15px 15px 15px 1rem; font-size: 1em; margin: 1em 0px; color: rgb(129, 145, 152); border-left: 8px solid rgb(255, 138, 101); background: rgb(224, 242, 241); overflow: auto; overflow-wrap: normal; word-break: normal; letter-spacing: 1.5px; font-family: YouYuan;\">\n  <p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 0px;\">如果上面没看懂的读者一定要认真看下面的流程分析！</p>\n</blockquote>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">首先，在最上面的那一块就是我刚刚讲的你现在可以直接 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">把 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">ConsumerQueue</code> 理解为 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Queue</code></strong>。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">在图中最左边说明了 <font color=\"red\" style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\">红色方块 </font> 代表被写入的消息，虚线方块代表等待被写入的。左边的生产者发送消息会指定 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Topic</code> 、<code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">QueueId</code> 和具体消息内容，而在 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 中管你是哪门子消息，他直接 **全部顺序存储到了 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">CommitLog</code> **。而根据生产者指定的 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Topic</code> 和 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">QueueId</code> 将这条消息本身在 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">CommitLog</code> 的偏移(offset)，消息本身大小，和tag的hash值存入对应的 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">ConsumeQueue</code> 索引文件中。而在每个队列中都保存了 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">ConsumeOffset</code> 即每个消费者组的消费位置(我在架构那里提到了，忘了的同学可以回去看一下)，而消费者拉取消息进行消费的时候只需要根据 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">ConsumeOffset</code> 获取下一个未被消费的消息就行了。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">上述就是我对于整个消息存储架构的大概理解(这里不涉及到一些细节讨论，比如稀疏索引等等问题)，希望对你有帮助。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">因为有一个知识点因为写嗨了忘讲了，想想在哪里加也不好，所以我留给大家去思考🤔🤔一下吧。</p>\n<figure style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><img src=\"https://user-gold-cdn.xitu.io/2019/12/11/16ef38894e8ff697?w=255&amp;h=255&amp;f=jpeg&amp;s=8769\" alt=\"\" title=\"\" style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;\"><figcaption style=\"line-height: inherit; margin: 0px; padding: 0px; margin-top: 10px; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;\"></figcaption></figure>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">为什么 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">CommitLog</code> 文件要设计成固定大小的长度呢？提醒：<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">内存映射机制</strong>。</p>\n<h2 id=\"h-21\" style=\"color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px; font-weight: bold; font-size: 1.5em; border-bottom: 2.2px solid rgb(255, 111, 0);\"><span style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; background: rgb(255, 111, 0); padding: 5px 15px; display: inline-block;\">总结</span></h2>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">总算把这篇博客写完了。我讲的你们还记得吗😅？</p>\n<figure style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><img src=\"https://user-gold-cdn.xitu.io/2019/12/11/16ef388ad16144f1?w=255&amp;h=255&amp;f=jpeg&amp;s=10422\" alt=\"\" title=\"\" style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;\"><figcaption style=\"line-height: inherit; margin: 0px; padding: 0px; margin-top: 10px; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;\"></figcaption></figure>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">这篇文章中我主要想大家介绍了</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">消息队列出现的原因</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">消息队列的作用(异步，解耦，削峰)</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">消息队列带来的一系列问题(消息堆积、重复消费、顺序消费、分布式事务等等)</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">消息队列的两种消息模型——队列和主题模式</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">分析了 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 的技术架构(<code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">NameServer</code> 、<code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 、<code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Producer</code> 、<code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Comsumer</code>)</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">结合着 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 回答了消息队列副作用的解决方案</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">介绍了 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 的存储机制和刷盘策略。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">等等。。。</p>\n<blockquote style=\"line-height: inherit; display: block; padding: 15px 15px 15px 1rem; font-size: 1em; margin: 1em 0px; color: rgb(129, 145, 152); border-left: 8px solid rgb(255, 138, 101); background: rgb(224, 242, 241); overflow: auto; overflow-wrap: normal; word-break: normal; letter-spacing: 1.5px; font-family: YouYuan;\">\n  <p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 0px;\">如果喜欢可以点赞哟👍👍👍。</p>\n</blockquote></div>","blogCover":"http://img.francisqiang.top/1577679358","blogId":3,"blogTitle":"👉冒着期末挂科的风险也要给你看的消息队列和RocketMQ入门总结"}
2019-12-30 12:17:29.984 [http-nio-8080-exec-10] INFO  com.lgq.controller.BlogController - FrancisBlog: getBlogList:1
2019-12-30 12:17:52.201 [http-nio-8080-exec-1] INFO  com.lgq.controller.BlogController - FrancisBlog: getBlogList:2
2019-12-30 12:17:54.398 [http-nio-8080-exec-4] INFO  com.lgq.controller.BlogController - FrancisBlog: getBlogList:3
2019-12-30 12:17:56.848 [http-nio-8080-exec-6] INFO  com.lgq.controller.BlogController - FrancisBlog: getBlogList:4
2019-12-30 12:18:00.021 [http-nio-8080-exec-3] INFO  com.lgq.controller.BlogController - FrancisBlog: getBlogList:5
2019-12-30 12:18:08.121 [http-nio-8080-exec-8] INFO  com.lgq.controller.BlogController - FrancisBlog: getBlogList:1
2019-12-30 12:18:08.130 [http-nio-8080-exec-5] INFO  com.lgq.controller.SiteController - FrancisBlog: getSiteInfo
2019-12-30 12:18:08.131 [http-nio-8080-exec-2] INFO  com.lgq.controller.SiteTagController - FrancisBlog: getAllSiteTag
2019-12-30 12:18:08.134 [http-nio-8080-exec-5] INFO  com.lgq.service.impl.SiteServiceImpl - DAY_PAGE_VIEW_PREFIX2019-12-30
2019-12-30 12:18:08.130 [http-nio-8080-exec-9] INFO  com.lgq.controller.MenuController - FrancisBlog: getAllParentMenu
2019-12-30 12:18:08.134 [http-nio-8080-exec-7] INFO  com.lgq.controller.SiteIconController - FrancisBlog: getAllSiteIcon
2019-12-30 12:18:08.142 [http-nio-8080-exec-10] INFO  com.lgq.controller.SiteFriendLinkController - FrancisBlog: getAllSiteFriendLink
2019-12-30 12:18:08.144 [http-nio-8080-exec-9] INFO  com.lgq.controller.AdvertisementController - FrancisBlog: getAllAdvertisement
2019-12-30 12:18:08.149 [http-nio-8080-exec-7] INFO  com.lgq.controller.SiteController - FrancisBlog: getSiteInfo
2019-12-30 12:18:08.154 [http-nio-8080-exec-7] INFO  com.lgq.service.impl.SiteServiceImpl - DAY_PAGE_VIEW_PREFIX2019-12-30
2019-12-30 12:18:08.166 [http-nio-8080-exec-6] INFO  com.lgq.controller.SiteController - FrancisBlog: getSiteInfo
2019-12-30 12:18:08.170 [http-nio-8080-exec-6] INFO  com.lgq.service.impl.SiteServiceImpl - DAY_PAGE_VIEW_PREFIX2019-12-30
2019-12-30 12:18:26.563 [http-nio-8080-exec-3] INFO  com.lgq.controller.TokenController - FrancisBlog: getToken
2019-12-30 12:18:26.573 [http-nio-8080-exec-8] INFO  com.lgq.controller.BlogController - FrancisBlog: getBlogById: blog_id:3
2019-12-30 12:18:26.574 [http-nio-8080-exec-5] INFO  com.lgq.controller.CategoryController - FrancisBlog: getAllCategory
2019-12-30 12:18:26.583 [http-nio-8080-exec-8] INFO  com.lgq.service.impl.BlogServiceImpl - null
2019-12-30 12:18:26.586 [http-nio-8080-exec-2] INFO  com.lgq.controller.TagController - FrancisBlog: getAllTag
2019-12-30 12:18:26.687 [http-nio-8080-exec-8] INFO  com.lgq.service.impl.BlogServiceImpl - 12
2019-12-30 12:18:34.626 [http-nio-8080-exec-1] INFO  com.lgq.controller.BlogController - FrancisBlog: updateBlogById -> {"blogCategoryId":1,"blogContent":"<div class=\"output_wrapper\" id=\"output_wrapper_id\" style=\"font-size: 16px; color: rgb(62, 62, 62); line-height: 1.7; word-spacing: 0px; letter-spacing: 0px; font-family: 'Helvetica Neue', Helvetica, 'Hiragino Sans GB', 'Microsoft YaHei', Arial, sans-serif; background-image: linear-gradient(90deg, rgba(50, 0, 0, 0.05) 3%, rgba(0, 0, 0, 0) 3%), linear-gradient(360deg, rgba(50, 0, 0, 0.05) 3%, rgba(0, 0, 0, 0) 3%); background-size: 20px 20px; background-position: center center;\"><h2 id=\"h\" style=\"color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px; font-weight: bold; font-size: 1.5em; border-bottom: 2.2px solid rgb(255, 111, 0);\"><span style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; background: rgb(255, 111, 0); padding: 5px 15px; display: inline-block;\">吐槽</span></h2>\n<blockquote style=\"line-height: inherit; display: block; padding: 15px 15px 15px 1rem; font-size: 1em; margin: 1em 0px; color: rgb(129, 145, 152); border-left: 8px solid rgb(255, 138, 101); background: rgb(224, 242, 241); overflow: auto; overflow-wrap: normal; word-break: normal; letter-spacing: 1.5px; font-family: YouYuan;\">\n  <p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 0px;\">文章很长，点赞再看，养成好习惯😋😋😋</p>\n</blockquote>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">这真的是考前的最后一篇博客，再写真的要挂科了。</p>\n<figure style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><img src=\"https://user-gold-cdn.xitu.io/2019/12/11/16ef37eaae5f8d42?w=255&amp;h=255&amp;f=jpeg&amp;s=11940\" alt=\"\" title=\"\" style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;\"><figcaption style=\"line-height: inherit; margin: 0px; padding: 0px; margin-top: 10px; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;\"></figcaption></figure>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">其实一直想吐槽现在很多大学的计算机教育的，我从大二开始入门 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Java</code>后端，其实我觉得我的学习效率很低，中间也走了很多歪路。但是，如今和同龄人比较，我发现大部分同学竟然连基本的代码都不会敲，尤其到了课程设计大家都是水水过的，让他们做一个管理系统简直要他们命。包括现在大三了，很多人希望本科就出来就业的开始报培训班，培机构开始大把大把地捞金，学生在那疯狂吐槽三四年里没有从学校学到任何东西，这可能是大部分大学计算机教育的通病吧。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">当然还有很多师资力量的问题，不知道清北的，但在我认识的一些 211 或者某些 985 的同学，他们学校的老师或者所教的一些知识也已经落伍了好多年了(当然不是指一些操作系统类似的基础学科，我觉得它们是几十年都不变的)。如果一个数据库老师会告诉你 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">MySQL</code> 不支持事务，一个数据结构老师说 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">B+树</code> 是二叉树，甚至在学生提到一些新的东西的时候没有了解过并且不想去了解，你们会怎么想。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">但很庆幸，在大二的时候加入了我们学校最牛的技术组织 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">TECH F5VE</code> ，这是一个学生组织的创业型技术团队，成立五年目前成员四十人不到，但里面不乏各种大厂的大牛，我在里面获得了很多很多。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">当然，参加过一些小公司的实习或者和他们合作过做一些外包项目，但发现他们的技术选型也已经 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">out</code> 了，我们团队的成员戏称 \"考古式开发\"。我想这也是大部分人挤破了头皮想要进大厂的理由吧。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">可能观点有点偏激，希望大家理解🤐🤐🤐。</p>\n<h2 id=\"h-1\" style=\"color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px; font-weight: bold; font-size: 1.5em; border-bottom: 2.2px solid rgb(255, 111, 0);\"><span style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; background: rgb(255, 111, 0); padding: 5px 15px; display: inline-block;\">消息队列扫盲</span></h2>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">消息队列顾名思义就是存放消息的队列，队列我就不解释了，别告诉我你连队列都不知道似啥吧？</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">所以问题并不是消息队列是什么，而是 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">消息队列为什么会出现？消息队列能用来干什么？用它来干这些事会带来什么好处？消息队列会带来副作用吗？</strong></p>\n<h3 id=\"h-2\" style=\"color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px; font-weight: bold; font-size: 1.3em;\"><span style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\">消息队列为什么会出现？</span></h3>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">消息队列算是作为后端程序员的一个必备技能吧，因为<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">分布式应用必定涉及到各个系统之间的通信问题</strong>，这个时候消息队列也应运而生了。可以说分布式的产生是消息队列的基础，而分布式怕是一个很古老的概念了吧，所以消息队列也是一个很古老的中间件了。</p>\n<h3 id=\"h-3\" style=\"color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px; font-weight: bold; font-size: 1.3em;\"><span style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\">消息队列能用来干什么？</span></h3>\n<h4 id=\"h-4\" style=\"color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px; font-weight: bold; font-size: 1.2em;\"><span style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\">异步</span></h4>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">你可能会反驳我，应用之间的通信又不是只能由消息队列解决，好好的通信为什么中间非要插一个消息队列呢？我不能直接进行通信吗？</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">很好👍，你又提出了一个概念，<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">同步通信</strong>。就比如现在业界使用比较多的 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Dubbo</code> 就是一个适用于各个系统之间同步通信的 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RPC</code> 框架。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">我来举个🌰吧，比如我们有一个购票系统，需求是用户在购买完之后能接收到购买完成的短信。</p>\n<figure style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><img src=\"https://user-gold-cdn.xitu.io/2019/12/11/16ef37fee7e09230?w=951&amp;h=209&amp;f=jpeg&amp;s=20202\" alt=\"\" title=\"\" style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;\"><figcaption style=\"line-height: inherit; margin: 0px; padding: 0px; margin-top: 10px; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;\"></figcaption></figure>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">我们省略中间的网络通信时间消耗，假如购票系统处理需要 150ms ，短信系统处理需要 200ms ，那么整个处理流程的时间消耗就是 150ms + 200ms = 350ms。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">当然，乍看没什么问题。可是仔细一想你就感觉有点问题，我用户购票在购票系统的时候其实就已经完成了购买，而我现在通过同步调用非要让整个请求拉长时间，而短息系统这玩意又不是很有必要，它仅仅是一个辅助功能增强用户体验感而已。我现在整个调用流程就有点 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">头重脚轻</strong> 的感觉了，购票是一个不太耗时的流程，而我现在因为同步调用，非要等待发送短信这个比较耗时的操作才返回结果。那我如果再加一个发送邮件呢？</p>\n<figure style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><img src=\"https://user-gold-cdn.xitu.io/2019/12/11/16ef380429cf373e?w=1364&amp;h=210&amp;f=jpeg&amp;s=28357\" alt=\"\" title=\"\" style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;\"><figcaption style=\"line-height: inherit; margin: 0px; padding: 0px; margin-top: 10px; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;\"></figcaption></figure>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">这样整个系统的调用链又变长了，整个时间就变成了550ms。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">当我们在学生时代需要在食堂排队的时候，我们和食堂大妈就是一个同步的模型。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">我们需要告诉食堂大妈：“姐姐，给我加个鸡腿，再加个酸辣土豆丝，帮我浇点汁上去，多打点饭哦😋😋😋”  咦~~~ 为了多吃点，真恶心。</p>\n<figure style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><img src=\"https://user-gold-cdn.xitu.io/2019/12/11/16ef3807de75dce5?w=170&amp;h=220&amp;f=gif&amp;s=489646\" alt=\"\" title=\"\" style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;\"><figcaption style=\"line-height: inherit; margin: 0px; padding: 0px; margin-top: 10px; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;\"></figcaption></figure>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">然后大妈帮我们打饭配菜，我们看着大妈那颤抖的手和掉落的土豆丝不禁咽了咽口水。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">最终我们从大妈手中接过饭菜然后去寻找座位了…</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">回想一下，我们在给大妈发送需要的信息之后我们是 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">同步等待大妈给我配好饭菜</strong> 的，上面我们只是加了鸡腿和土豆丝，万一我再加一个番茄牛腩，韭菜鸡蛋，这样是不是大妈打饭配菜的流程就会变长，我们等待的时间也会相应的变长。</p>\n<figure style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><img src=\"https://user-gold-cdn.xitu.io/2019/12/11/16ef380ae4f8be5b?w=250&amp;h=221&amp;f=jpeg&amp;s=8279\" alt=\"\" title=\"\" style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;\"><figcaption style=\"line-height: inherit; margin: 0px; padding: 0px; margin-top: 10px; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;\"></figcaption></figure>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">那后来，我们工作赚钱了有钱去饭店吃饭了，我们告诉服务员来一碗牛肉面加个荷包蛋 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">(传达一个消息)</strong> ，然后我们就可以在饭桌上安心的玩手机了 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">(干自己其他事情)</strong> ，等到我们的牛肉面上了我们就可以吃了。这其中我们也就传达了一个消息，然后我们又转过头干其他事情了。这其中虽然做面的时间没有变短，但是我们只需要传达一个消息就可以看其他事情了，这是一个 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">异步</strong> 的概念。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">所以，为了解决这一个问题，聪明的程序员在中间也加了个类似于服务员的中间件——消息队列。这个时候我们就可以把模型给改造了。</p>\n<figure style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><img src=\"https://user-gold-cdn.xitu.io/2019/12/11/16ef38124f55eaea?w=1194&amp;h=326&amp;f=jpeg&amp;s=47622\" alt=\"\" title=\"\" style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;\"><figcaption style=\"line-height: inherit; margin: 0px; padding: 0px; margin-top: 10px; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;\"></figcaption></figure>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">这样，我们在将消息存入消息队列之后我们就可以直接返回了(我们告诉服务员我们要吃什么然后玩手机)，所以整个耗时只是 150ms + 10ms = 160ms。</p>\n<blockquote style=\"line-height: inherit; display: block; padding: 15px 15px 15px 1rem; font-size: 1em; margin: 1em 0px; color: rgb(129, 145, 152); border-left: 8px solid rgb(255, 138, 101); background: rgb(224, 242, 241); overflow: auto; overflow-wrap: normal; word-break: normal; letter-spacing: 1.5px; font-family: YouYuan;\">\n  <p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 0px;\">但是你需要注意的是，整个流程的时长是没变的，就像你仅仅告诉服务员要吃什么是不会影响到做面的速度的。</p>\n</blockquote>\n<h4 id=\"h-5\" style=\"color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px; font-weight: bold; font-size: 1.2em;\"><span style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\">解耦</span></h4>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">回到最初同步调用的过程，我们写个伪代码简单概括一下。</p>\n<figure style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><img src=\"https://user-gold-cdn.xitu.io/2019/12/11/16ef381a505d3e1f?w=538&amp;h=337&amp;f=png&amp;s=42350\" alt=\"\" title=\"\" style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;\"><figcaption style=\"line-height: inherit; margin: 0px; padding: 0px; margin-top: 10px; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;\"></figcaption></figure>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">那么第二步，我们又添加了一个发送邮件，我们就得重新去修改代码，如果我们又加一个需求：用户购买完还需要给他加积分，这个时候我们是不是又得改代码？</p>\n<figure style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><img src=\"https://user-gold-cdn.xitu.io/2019/12/11/16ef381c4e1b1ac7?w=538&amp;h=463&amp;f=png&amp;s=53705\" alt=\"\" title=\"\" style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;\"><figcaption style=\"line-height: inherit; margin: 0px; padding: 0px; margin-top: 10px; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;\"></figcaption></figure>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">如果你觉得还行，那么我这个时候不要发邮件这个服务了呢，我是不是又得改代码，又得重启应用？</p>\n<figure style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><img src=\"https://user-gold-cdn.xitu.io/2019/12/11/16ef381f273a66bd?w=200&amp;h=200&amp;f=jpeg&amp;s=8544\" alt=\"\" title=\"\" style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;\"><figcaption style=\"line-height: inherit; margin: 0px; padding: 0px; margin-top: 10px; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;\"></figcaption></figure>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">这样改来改去是不是很麻烦，那么 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">此时我们就用一个消息队列在中间进行解耦</strong> 。你需要注意的是，我们后面的发送短信、发送邮件、添加积分等一些操作都依赖于上面的 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">result</code> ，这东西抽象出来就是购票的处理结果呀，比如订单号，用户账号等等，也就是说我们后面的一系列服务都是需要同样的消息来进行处理。既然这样，我们是不是可以通过 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">“广播消息”</strong> 来实现。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">我上面所讲的“广播”并不是真正的广播，而是接下来的系统作为消费者去 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">订阅</strong> 特定的主题。比如我们这里的主题就可以叫做 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">订票</code> ，我们购买系统作为一个生产者去生产这条消息放入消息队列，然后消费者订阅了这个主题，会从消息队列中拉取消息并消费。就比如我们刚刚画的那张图，你会发现，在生产者这边我们只需要关注 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">生产消息到指定主题中</strong> ，而 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">消费者只需要关注从指定主题中拉取消息</strong> 就行了。</p>\n<figure style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><img src=\"https://user-gold-cdn.xitu.io/2019/12/11/16ef382674b66892?w=1194&amp;h=326&amp;f=jpeg&amp;s=47622\" alt=\"\" title=\"\" style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;\"><figcaption style=\"line-height: inherit; margin: 0px; padding: 0px; margin-top: 10px; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;\"></figcaption></figure>\n<blockquote style=\"line-height: inherit; display: block; padding: 15px 15px 15px 1rem; font-size: 1em; margin: 1em 0px; color: rgb(129, 145, 152); border-left: 8px solid rgb(255, 138, 101); background: rgb(224, 242, 241); overflow: auto; overflow-wrap: normal; word-break: normal; letter-spacing: 1.5px; font-family: YouYuan;\">\n  <p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 0px;\">如果没有消息队列，每当一个新的业务接入，我们都要在主系统调用新接口、或者当我们取消某些业务，我们也得在主系统删除某些接口调用。有了消息队列，我们只需要关心消息是否送达了队列，至于谁希望订阅，接下来收到消息如何处理，是下游的事情，无疑极大地减少了开发和联调的工作量。</p>\n</blockquote>\n<h4 id=\"h-6\" style=\"color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px; font-weight: bold; font-size: 1.2em;\"><span style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\">削峰</span></h4>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">我们再次回到一开始我们使用同步调用系统的情况，并且思考一下，如果此时有大量用户请求购票整个系统会变成什么样？</p>\n<figure style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><img src=\"https://user-gold-cdn.xitu.io/2019/12/11/16ef382a9756bb1c?w=1048&amp;h=469&amp;f=jpeg&amp;s=38175\" alt=\"\" title=\"\" style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;\"><figcaption style=\"line-height: inherit; margin: 0px; padding: 0px; margin-top: 10px; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;\"></figcaption></figure>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">如果，此时有一万的请求进入购票系统，我们知道运行我们主业务的服务器配置一般会比较好，所以这里我们假设购票系统能承受这一万的用户请求，那么也就意味着我们同时也会出现一万调用发短信服务的请求。而对于短信系统来说并不是我们的主要业务，所以我们配备的硬件资源并不会太高，那么你觉得现在这个短信系统能承受这一万的峰值么，且不说能不能承受，系统会不会 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">直接崩溃</strong> 了？</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">短信业务又不是我们的主业务，我们能不能 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">折中处理</strong> 呢？如果我们把购买完成的信息发送到消息队列中，而短信系统 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">尽自己所能地去消息队列中取消息和消费消息</strong> ，即使处理速度慢一点也无所谓，只要我们的系统没有崩溃就行了。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">留得江山在，还怕没柴烧？你敢说每次发送验证码的时候是一发你就收到了的么？</p>\n<h4 id=\"h-7\" style=\"color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px; font-weight: bold; font-size: 1.2em;\"><span style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\">消息队列能带来什么好处？</span></h4>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">其实上面我已经说了。<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">异步、解耦、削峰。</strong> 哪怕你上面的都没看懂也千万要记住这六个字，因为他不仅是消息队列的精华，更是编程和架构的精华。</p>\n<h4 id=\"h-8\" style=\"color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px; font-weight: bold; font-size: 1.2em;\"><span style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\">消息队列会带来副作用吗？</span></h4>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">没有哪一门技术是“银弹”，消息队列也有它的副作用。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">比如，本来好好的两个系统之间的调用，我中间加了个消息队列，如果消息队列挂了怎么办呢？是不是 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">降低了系统的可用性</strong> ？</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">那这样是不是要保证HA(高可用)？是不是要搞集群？那么我 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">整个系统的复杂度是不是上升了</strong> ？</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">抛开上面的问题不讲，万一我发送方发送失败了，然后执行重试，这样就可能产生重复的消息。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">或者我消费端处理失败了，请求重发，这样也会产生重复的消息。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">对于一些微服务来说，消费重复消息会带来更大的麻烦，比如增加积分，这个时候我加了多次是不是对其他用户不公平？</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">那么，又 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">如何解决重复消费消息的问题</strong> 呢？</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">如果我们此时的消息需要保证严格的顺序性怎么办呢？比如生产者生产了一系列的有序消息(对一个id为1的记录进行删除增加修改)，但是我们知道在发布订阅模型中，对于主题是无顺序的，那么这个时候就会导致对于消费者消费消息的时候没有按照生产者的发送顺序消费，比如这个时候我们消费的顺序为修改删除增加，如果该记录涉及到金额的话是不是会出大事情？</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">那么，又 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">如何解决消息的顺序消费问题</strong> 呢？</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">就拿我们上面所讲的分布式系统来说，用户购票完成之后是不是需要增加账户积分？在同一个系统中我们一般会使用事务来进行解决，如果用 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Spring</code> 的话我们在上面伪代码中加入 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">@Transactional</code> 注解就好了。但是在不同系统中如何保证事务呢？总不能这个系统我扣钱成功了你那积分系统积分没加吧？或者说我这扣钱明明失败了，你那积分系统给我加了积分。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">那么，又如何 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">解决分布式事务问题</strong> 呢？</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">我们刚刚说了，消息队列可以进行削峰操作，那如果我的消费者如果消费很慢或者生产者生产消息很快，这样是不是会将消息堆积在消息队列中？</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">那么，又如何 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">解决消息堆积的问题</strong> 呢？</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">可用性降低，复杂度上升，又带来一系列的重复消费，顺序消费，分布式事务，消息堆积的问题，这消息队列还怎么用啊😵？</p>\n<figure style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><img src=\"https://user-gold-cdn.xitu.io/2019/12/11/16ef382d709abc9d?w=255&amp;h=255&amp;f=jpeg&amp;s=8169\" alt=\"\" title=\"\" style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;\"><figcaption style=\"line-height: inherit; margin: 0px; padding: 0px; margin-top: 10px; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;\"></figcaption></figure>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">别急，办法总是有的。</p>\n<h2 id=\"hrocketmq\" style=\"color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px; font-weight: bold; font-size: 1.5em; border-bottom: 2.2px solid rgb(255, 111, 0);\"><span style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; background: rgb(255, 111, 0); padding: 5px 15px; display: inline-block;\">RocketMQ是什么？</span></h2>\n<figure style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><img src=\"https://user-gold-cdn.xitu.io/2019/12/11/16ef383014430799?w=1450&amp;h=430&amp;f=jpeg&amp;s=103646\" alt=\"\" title=\"\" style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;\"><figcaption style=\"line-height: inherit; margin: 0px; padding: 0px; margin-top: 10px; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;\"></figcaption></figure>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">哇，你个混蛋！上面给我抛出那么多问题，你现在又讲 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> ，还让不让人活了？！🤬</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">别急别急，话说你现在清楚 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">MQ</code> 的构造吗，我还没讲呢，我们先搞明白 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">MQ</code> 的内部构造，再来看看如何解决上面的一系列问题吧，不过你最好带着问题去阅读和了解喔。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\"><code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 是一个 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">队列模型</strong> 的消息中间件，具有<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">高性能、高可靠、高实时、分布式</strong> 的特点。它是一个采用 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Java</code> 语言开发的分布式的消息系统，由阿里巴巴团队开发，在2016年底贡献给 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Apache</code>，成为了 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Apache</code> 的一个顶级项目。 在阿里内部，<code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 很好地服务了集团大大小小上千个应用，在每年的双十一当天，更有不可思议的万亿级消息通过 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 流转。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">废话不多说，想要了解 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 历史的同学可以自己去搜寻资料。听完上面的介绍，你只要知道 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 很快、很牛、而且经历过双十一的实践就行了！</p>\n<h2 id=\"h-9\" style=\"color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px; font-weight: bold; font-size: 1.5em; border-bottom: 2.2px solid rgb(255, 111, 0);\"><span style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; background: rgb(255, 111, 0); padding: 5px 15px; display: inline-block;\">队列模型和主题模型</span></h2>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">在谈 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 的技术架构之前，我们先来了解一下两个名词概念——<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">队列模型</strong> 和 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">主题模型</strong> 。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">首先我问一个问题，消息队列为什么要叫消息队列？</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">你可能觉得很弱智，这玩意不就是存放消息的队列嘛？不叫消息队列叫什么？</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">的确，早期的消息中间件是通过 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">队列</strong> 这一模型来实现的，可能是历史原因，我们都习惯把消息中间件成为消息队列。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">但是，如今例如 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 、<code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Kafka</code> 这些优秀的消息中间件不仅仅是通过一个 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">队列</strong> 来实现消息存储的。</p>\n<h3 id=\"h-10\" style=\"color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px; font-weight: bold; font-size: 1.3em;\"><span style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\">队列模型</span></h3>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">就像我们理解队列一样，消息中间件的队列模型就真的只是一个队列。。。我画一张图给大家理解。</p>\n<figure style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><img src=\"https://user-gold-cdn.xitu.io/2019/12/11/16ef3834ae653469?w=760&amp;h=142&amp;f=jpeg&amp;s=22424\" alt=\"\" title=\"\" style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;\"><figcaption style=\"line-height: inherit; margin: 0px; padding: 0px; margin-top: 10px; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;\"></figcaption></figure>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">在一开始我跟你提到了一个 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">“广播”</strong> 的概念，也就是说如果我们此时我们需要将一个消息发送给多个消费者(比如此时我需要将信息发送给短信系统和邮件系统)，这个时候单个队列即不能满足需求了。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">当然你可以让 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Producer</code> 生产消息放入多个队列中，然后每个队列去对应每一个消费者。问题是可以解决，创建多个队列并且复制多份消息是会很影响资源和性能的。而且，这样子就会导致生产者需要知道具体消费者个数然后去复制对应数量的消息队列，这就违背我们消息中间件的 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">解耦</strong> 这一原则。</p>\n<h3 id=\"h-11\" style=\"color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px; font-weight: bold; font-size: 1.3em;\"><span style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\">主题模型</span></h3>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">那么有没有好的方法去解决这一个问题呢？有，那就是 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">主题模型</strong> 或者可以称为 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">发布订阅模型</strong> 。</p>\n<blockquote style=\"line-height: inherit; display: block; padding: 15px 15px 15px 1rem; font-size: 1em; margin: 1em 0px; color: rgb(129, 145, 152); border-left: 8px solid rgb(255, 138, 101); background: rgb(224, 242, 241); overflow: auto; overflow-wrap: normal; word-break: normal; letter-spacing: 1.5px; font-family: YouYuan;\">\n  <p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 0px;\">感兴趣的同学可以去了解一下设计模式里面的观察者模式并且手动实现一下，我相信你会有所收获的。</p>\n</blockquote>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">在主题模型中，消息的生产者称为 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">发布者(Publisher)</strong> ，消息的消费者称为 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">订阅者(Subscriber)</strong> ，存放消息的容器称为 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">主题(Topic)</strong> 。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">其中，发布者将消息发送到指定主题中，订阅者需要 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">提前订阅主题</strong> 才能接受特定主题的消息。</p>\n<figure style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><img src=\"https://user-gold-cdn.xitu.io/2019/12/11/16ef3837887d9a54?w=760&amp;h=341&amp;f=jpeg&amp;s=47404\" alt=\"\" title=\"\" style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;\"><figcaption style=\"line-height: inherit; margin: 0px; padding: 0px; margin-top: 10px; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;\"></figcaption></figure>\n<h3 id=\"hrocketmq-1\" style=\"color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px; font-weight: bold; font-size: 1.3em;\"><span style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\">RocketMQ中的消息模型</span></h3>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\"><code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RockerMQ</code> 中的消息模型就是按照 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">主题模型</strong> 所实现的。你可能会好奇这个 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">主题</strong> 到底是怎么实现的呢？你上面也没有讲到呀！</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">其实对于主题模型的实现来说每个消息中间件的底层设计都是不一样的，就比如 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Kafka</code> 中的 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">分区</strong> ，<code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 中的 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">队列</strong> ，<code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RabbitMQ</code> 中的 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Exchange</code> 。我们可以理解为 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">主题模型/发布订阅模型</strong> 就是一个标准，那些中间件只不过照着这个标准去实现而已。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">所以，<code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 中的 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">主题模型</strong> 到底是如何实现的呢？首先我画一张图，大家尝试着去理解一下。</p>\n<figure style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><img src=\"https://user-gold-cdn.xitu.io/2019/12/11/16ef383d3e8c9788?w=1391&amp;h=555&amp;f=jpeg&amp;s=116552\" alt=\"\" title=\"\" style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;\"><figcaption style=\"line-height: inherit; margin: 0px; padding: 0px; margin-top: 10px; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;\"></figcaption></figure>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">我们可以看到在整个图中有 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Producer Group</code> 、<code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Topic</code> 、<code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Consumer Group</code>  三个角色，我来分别介绍一下他们。</p>\n<ul style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px; padding-left: 32px; list-style-type: disc;\">\n<li style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px; margin-bottom: 0.5em;\"><code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Producer Group</code> 生产者组： 代表某一类的生产者，比如我们有多个秒杀系统作为生产者，这多个合在一起就是一个 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Producer Group</code> 生产者组，它们一般生产相同的消息。</li>\n<li style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px; margin-bottom: 0.5em;\"><code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Consumer Group</code> 消费者组： 代表某一类的消费者，比如我们有多个短信系统作为消费者，这多个合在一起就是一个 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Consumer Group</code> 消费者组，它们一般消费相同的消息。</li>\n<li style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px; margin-bottom: 0.5em;\"><code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Topic</code> 主题： 代表一类消息，比如订单消息，物流消息等等。</li>\n</ul>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">你可以看到图中生产者组中的生产者会向主题发送消息，而 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">主题中存在多个队列</strong>，生产者每次生产消息之后是指定主题中的某个队列发送消息的。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">每个主题中都有多个队列(这里还不涉及到 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code>)，集群消费模式下，一个消费者集群多台机器共同消费一个 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">topic</code> 的多个队列，<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">一个队列只会被一个消费者消费</strong>。如果某个消费者挂掉，分组内其它消费者会接替挂掉的消费者继续消费。就像上图中 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Consumer1</code> 和 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Consumer2</code> 分别对应着两个队列，而 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Consuer3</code> 是没有队列对应的，所以一般来讲要控制 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">消费者组中的消费者个数和主题中队列个数相同</strong> 。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">当然也可以消费者个数小于队列个数，只不过不太建议。如下图。</p>\n<figure style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><img src=\"https://user-gold-cdn.xitu.io/2019/12/11/16ef3850c808d707?w=910&amp;h=261&amp;f=jpeg&amp;s=43637\" alt=\"\" title=\"\" style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;\"><figcaption style=\"line-height: inherit; margin: 0px; padding: 0px; margin-top: 10px; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;\"></figcaption></figure>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\"><strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">每个消费组在每个队列上维护一个消费位置</strong> ，为什么呢？</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">因为我们刚刚画的仅仅是一个消费者组，我们知道在发布订阅模式中一般会涉及到多个消费者组，而每个消费者组在每个队列中的消费位置都是不同的。如果此时有多个消费者组，那么消息被一个消费者组消费完之后是不会删除的(因为其它消费者组也需要呀)，它仅仅是为每个消费者组维护一个 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">消费位移(offset)</strong> ，每次消费者组消费完会返回一个成功的响应，然后队列再把维护的消费位移加一，这样就不会出现刚刚消费过的消息再一次被消费了。</p>\n<figure style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><img src=\"https://user-gold-cdn.xitu.io/2019/12/11/16ef3857fefaa079?w=1251&amp;h=599&amp;f=jpeg&amp;s=130119\" alt=\"\" title=\"\" style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;\"><figcaption style=\"line-height: inherit; margin: 0px; padding: 0px; margin-top: 10px; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;\"></figcaption></figure>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">可能你还有一个问题，<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">为什么一个主题中需要维护多个队列</strong> ？</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">答案是 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">提高并发能力</strong> 。的确，每个主题中只存在一个队列也是可行的。你想一下，如果每个主题中只存在一个队列，这个队列中也维护着每个消费者组的消费位置，这样也可以做到 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">发布订阅模式</strong> 。如下图。</p>\n<figure style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><img src=\"https://user-gold-cdn.xitu.io/2019/12/11/16ef38600cdb6d4b?w=1271&amp;h=632&amp;f=jpeg&amp;s=128950\" alt=\"\" title=\"\" style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;\"><figcaption style=\"line-height: inherit; margin: 0px; padding: 0px; margin-top: 10px; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;\"></figcaption></figure>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">但是，这样我生产者是不是只能向一个队列发送消息？又因为需要维护消费位置所以一个队列只能对应一个消费者组中的消费者，这样是不是其他的 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Consumer</code> 就没有用武之地了？从这两个角度来讲，并发度一下子就小了很多。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">所以总结来说，<code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 通过<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">使用在一个 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Topic</code> 中配置多个队列并且每个队列维护每个消费者组的消费位置</strong> 实现了 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">主题模式/发布订阅模式</strong> 。</p>\n<h2 id=\"hrocketmq-2\" style=\"color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px; font-weight: bold; font-size: 1.5em; border-bottom: 2.2px solid rgb(255, 111, 0);\"><span style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; background: rgb(255, 111, 0); padding: 5px 15px; display: inline-block;\">RocketMQ的架构图</span></h2>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">讲完了消息模型，我们理解起 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 的技术架构起来就容易多了。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\"><code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 技术架构中有四大角色 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">NameServer</code> 、<code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 、<code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Producer</code> 、<code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Consumer</code> 。我来向大家分别解释一下这四个角色是干啥的。</p>\n<ul style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px; padding-left: 32px; list-style-type: disc;\">\n<li style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px; margin-bottom: 0.5em;\"><p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\"><code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code>： 主要负责消息的存储、投递和查询以及服务高可用保证。说白了就是消息队列服务器嘛，生产者生产消息到 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> ，消费者从 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 拉取消息并消费。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">这里，我还得普及一下关于 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 、<code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Topic</code> 和 队列的关系。上面我讲解了 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Topic</code> 和队列的关系——一个 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Topic</code> 中存在多个队列，那么这个 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Topic</code> 和队列存放在哪呢？</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\"><strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">一个 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Topic</code> 分布在多个 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code>上，一个 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 可以配置多个 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Topic</code> ，它们是多对多的关系</strong>。 </p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">如果某个 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Topic</code> 消息量很大，应该给它多配置几个队列(上文中提到了提高并发能力)，并且 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">尽量多分布在不同 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 上，以减轻某个 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 的压力</strong> 。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\"><code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Topic</code> 消息量都比较均匀的情况下，如果某个 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">broker</code> 上的队列越多，则该 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">broker</code> 压力越大。</p>\n<figure style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><img src=\"https://user-gold-cdn.xitu.io/2019/12/11/16ef38687488a5a4?w=936&amp;h=673&amp;f=jpeg&amp;s=93578\" alt=\"\" title=\"\" style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;\"><figcaption style=\"line-height: inherit; margin: 0px; padding: 0px; margin-top: 10px; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;\"></figcaption></figure></li>\n</ul>\n<blockquote style=\"line-height: inherit; display: block; padding: 15px 15px 15px 1rem; font-size: 1em; margin: 1em 0px; color: rgb(129, 145, 152); border-left: 8px solid rgb(255, 138, 101); background: rgb(224, 242, 241); overflow: auto; overflow-wrap: normal; word-break: normal; letter-spacing: 1.5px; font-family: YouYuan;\">\n  <p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 0px;\">所以说我们需要配置多个Broker。</p>\n</blockquote>\n<ul style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px; padding-left: 32px; list-style-type: disc;\">\n<li style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px; margin-bottom: 0.5em;\"><p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\"><code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">NameServer</code>： 不知道你们有没有接触过 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">ZooKeeper</code> 和 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Spring Cloud</code> 中的 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Eureka</code> ，它其实也是一个 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">注册中心</strong> ，主要提供两个功能：<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">Broker管理</strong> 和 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">路由信息管理</strong> 。说白了就是 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 会将自己的信息注册到 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">NameServer</code> 中，此时 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">NameServer</code> 就存放了很多 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 的信息(Broker的路由表)，消费者和生产者就从 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">NameServer</code> 中获取路由表然后照着路由表的信息和对应的 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 进行通信(生产者和消费者定期会向 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">NameServer</code> 去查询相关的 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 的信息)。</p></li>\n<li style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px; margin-bottom: 0.5em;\"><p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\"><code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Producer</code>： 消息发布的角色，支持分布式集群方式部署。说白了就是生产者。</p></li>\n<li style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px; margin-bottom: 0.5em;\"><p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\"><code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Consumer</code>： 消息消费的角色，支持分布式集群方式部署。支持以push推，pull拉两种模式对消息进行消费。同时也支持集群方式和广播方式的消费，它提供实时消息订阅机制。说白了就是消费者。</p></li>\n</ul>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">听完了上面的解释你可能会觉得，这玩意好简单。不就是这样的么？</p>\n<figure style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><img src=\"https://user-gold-cdn.xitu.io/2019/12/11/16ef386c6d1e8bdb?w=1237&amp;h=454&amp;f=jpeg&amp;s=93637\" alt=\"\" title=\"\" style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;\"><figcaption style=\"line-height: inherit; margin: 0px; padding: 0px; margin-top: 10px; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;\"></figcaption></figure>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">嗯？你可能会发现一个问题，这老家伙 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">NameServer</code> 干啥用的，这不多余吗？直接 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Producer</code> 、<code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Consumer</code> 和 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 直接进行生产消息，消费消息不就好了么？</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">但是，我们上文提到过 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 是需要保证高可用的，如果整个系统仅仅靠着一个 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 来维持的话，那么这个 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 的压力会不会很大？所以我们需要使用多个 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 来保证 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">负载均衡</strong> 。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">如果说，我们的消费者和生产者直接和多个 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 相连，那么当 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 修改的时候必定会牵连着每个生产者和消费者，这样就会产生耦合问题，而 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">NameServer</code> 注册中心就是用来解决这个问题的。</p>\n<blockquote style=\"line-height: inherit; display: block; padding: 15px 15px 15px 1rem; font-size: 1em; margin: 1em 0px; color: rgb(129, 145, 152); border-left: 8px solid rgb(255, 138, 101); background: rgb(224, 242, 241); overflow: auto; overflow-wrap: normal; word-break: normal; letter-spacing: 1.5px; font-family: YouYuan;\">\n  <p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 0px;\">如果还不是很理解的话，可以去看我介绍 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Spring Cloud</code> 的那篇文章，其中介绍了 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Eureka</code> 注册中心。</p>\n</blockquote>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">当然，<code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 中的技术架构肯定不止前面那么简单，因为上面图中的四个角色都是需要做集群的。我给出一张官网的架构图，大家尝试理解一下。</p>\n<figure style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><img src=\"https://user-gold-cdn.xitu.io/2019/12/11/16ef386fa3be1e53?w=1281&amp;h=522&amp;f=jpeg&amp;s=66376\" alt=\"\" title=\"\" style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;\"><figcaption style=\"line-height: inherit; margin: 0px; padding: 0px; margin-top: 10px; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;\"></figcaption></figure>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">其实和我们最开始画的那张乞丐版的架构图也没什么区别，主要是一些细节上的差别。听我细细道来🤨。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">第一、我们的 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">做了集群并且还进行了主从部署</strong> ，由于消息分布在各个 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 上，一旦某个 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 宕机，则该<code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 上的消息读写都会受到影响。所以 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Rocketmq</code> 提供了 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">master/slave</code> 的结构，<code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">salve</code> 定时从 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">master</code> 同步数据(同步刷盘或者异步刷盘)，如果 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">master</code> 宕机，<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">则 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">slave</code> 提供消费服务，但是不能写入消息</strong> (后面我还会提到哦)。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">第二、为了保证 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">HA</code> ，我们的 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">NameServer</code> 也做了集群部署，但是请注意它是 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">去中心化</strong> 的。也就意味着它没有主节点，你可以很明显地看出 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">NameServer</code> 的所有节点是没有进行 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Info Replicate</code> 的，在 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 中是通过 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">单个Broker和所有NameServer保持长连接</strong> ，并且在每隔30秒 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 会向所有 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Nameserver</code> 发送心跳，心跳包含了自身的 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Topic</code> 配置信息，这个步骤就对应这上面的 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Routing Info</code> 。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">第三、在生产者需要向 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 发送消息的时候，<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">需要先从 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">NameServer</code> 获取关于 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 的路由信息</strong>，然后通过 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">轮询</strong> 的方法去向每个队列中生产数据以达到 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">负载均衡</strong> 的效果。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">第四、消费者通过 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">NameServer</code> 获取所有 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 的路由信息后，向 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 发送 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Pull</code> 请求来获取消息数据。<code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Consumer</code> 可以以两种模式启动—— <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">广播（Broadcast）和集群（Cluster）</strong>。广播模式下，一条消息会发送给 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">同一个消费组中的所有消费者</strong> ，集群模式下消息只会发送给一个消费者。</p>\n<h2 id=\"h-12\" style=\"color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px; font-weight: bold; font-size: 1.5em; border-bottom: 2.2px solid rgb(255, 111, 0);\"><span style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; background: rgb(255, 111, 0); padding: 5px 15px; display: inline-block;\">如何解决 顺序消费、重复消费</span></h2>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">其实，这些东西都是我在介绍消息队列带来的一些副作用的时候提到的，也就是说，这些问题不仅仅挂钩于 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> ，而是应该每个消息中间件都需要去解决的。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">在上面我介绍 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 的技术架构的时候我已经向你展示了 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">它是如何保证高可用的</strong> ，这里不涉及运维方面的搭建，如果你感兴趣可以自己去官网上照着例子搭建属于你自己的 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 集群。</p>\n<blockquote style=\"line-height: inherit; display: block; padding: 15px 15px 15px 1rem; font-size: 1em; margin: 1em 0px; color: rgb(129, 145, 152); border-left: 8px solid rgb(255, 138, 101); background: rgb(224, 242, 241); overflow: auto; overflow-wrap: normal; word-break: normal; letter-spacing: 1.5px; font-family: YouYuan;\">\n  <p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 0px;\">其实 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Kafka</code> 的架构基本和 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 类似，只是它注册中心使用了 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Zookeeper</code> 、它的 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">分区</strong> 就相当于 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 中的 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">队列</strong> 。还有一些小细节不同会在后面提到。</p>\n</blockquote>\n<h3 id=\"h-13\" style=\"color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px; font-weight: bold; font-size: 1.3em;\"><span style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\">顺序消费</span></h3>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">在上面的技术架构介绍中，我们已经知道了 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\"><code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 在主题上是无序的、它只有在队列层面才是保证有序</strong> 的。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">这又扯到两个概念——<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">普通顺序</strong> 和 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">严格顺序</strong> 。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">所谓普通顺序是指 消费者通过 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">同一个消费队列收到的消息是有顺序的</strong> ，不同消息队列收到的消息则可能是无顺序的。普通顺序消息在 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">重启情况下不会保证消息顺序性</strong> (短暂时间) 。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">所谓严格顺序是指  消费者收到的 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">所有消息</strong> 均是有顺序的。严格顺序消息 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">即使在异常情况下也会保证消息的顺序性</strong> 。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">但是，严格顺序看起来虽好，实现它可会付出巨大的代价。如果你使用严格顺序模式，<code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 集群中只要有一台机器不可用，则整个集群都不可用。你还用啥？现在主要场景也就在 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">binlog</code> 同步。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">一般而言，我们的 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">MQ</code> 都是能容忍短暂的乱序，所以推荐使用普通顺序模式。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">那么，我们现在使用了 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">普通顺序模式</strong> ，我们从上面学习知道了在 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Producer</code> 生产消息的时候会进行轮询(取决你的负载均衡策略)来向同一主题的不同消息队列发送消息。那么如果此时我有几个消息分别是同一个订单的创建、支付、发货，在轮询的策略下这 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">三个消息会被发送到不同队列</strong> ，因为在不同的队列此时就无法使用 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 带来的队列有序特性来保证消息有序性了。</p>\n<figure style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><img src=\"https://user-gold-cdn.xitu.io/2019/12/11/16ef3874585e096e?w=1258&amp;h=484&amp;f=jpeg&amp;s=90329\" alt=\"\" title=\"\" style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;\"><figcaption style=\"line-height: inherit; margin: 0px; padding: 0px; margin-top: 10px; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;\"></figcaption></figure>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">那么，怎么解决呢？</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">其实很简单，我们需要处理的仅仅是将同一语义下的消息放入同一个队列(比如这里是同一个订单)，那我们就可以使用 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">Hash取模法</strong> 来保证同一个订单在同一个队列中就行了。</p>\n<h3 id=\"h-14\" style=\"color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px; font-weight: bold; font-size: 1.3em;\"><span style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\">重复消费</span></h3>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">emmm，就两个字—— <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">幂等</strong> 。在编程中一个<em style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px; font-style: italic;\">幂等</em> 操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。比如说，这个时候我们有一个订单的处理积分的系统，每当来一个消息的时候它就负责为创建这个订单的用户的积分加上相应的数值。可是有一次，消息队列发送给订单系统 FrancisQ 的订单信息，其要求是给 FrancisQ 的积分加上 500。但是积分系统在收到 FrancisQ 的订单信息处理完成之后返回给消息队列处理成功的信息的时候出现了网络波动(当然还有很多种情况，比如Broker意外重启等等)，这条回应没有发送成功。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">那么，消息队列没收到积分系统的回应会不会尝试重发这个消息？问题就来了，我再发这个消息，万一它又给 FrancisQ 的账户加上 500 积分怎么办呢？</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">所以我们需要给我们的消费者实现 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">幂等</strong> ，也就是对同一个消息的处理结果，执行多少次都不变。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">那么如何给业务实现幂等呢？这个还是需要结合具体的业务的。你可以使用 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">写入 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Redis</code></strong> 来保证，因为 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Redis</code> 的 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">key</code> 和 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">value</code> 就是天然支持幂等的。当然还有使用 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">数据库插入法</strong> ，基于数据库的唯一键来保证重复数据不会被插入多条。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">不过最主要的还是需要 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">根据特定场景使用特定的解决方案</strong> ，你要知道你的消息消费是否是完全不可重复消费还是可以忍受重复消费的，然后再选择强校验和弱校验的方式。毕竟在 CS 领域还是很少有技术银弹的说法。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">而在整个互联网领域，幂等不仅仅适用于消息队列的重复消费问题，这些实现幂等的方法，也同样适用于，<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">在其他场景中来解决重复请求或者重复调用的问题</strong> 。比如将HTTP服务设计成幂等的，<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">解决前端或者APP重复提交表单数据的问题</strong> ，也可以将一个微服务设计成幂等的，解决 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RPC</code> 框架自动重试导致的 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">重复调用问题</strong> 。</p>\n<h2 id=\"h-15\" style=\"color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px; font-weight: bold; font-size: 1.5em; border-bottom: 2.2px solid rgb(255, 111, 0);\"><span style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; background: rgb(255, 111, 0); padding: 5px 15px; display: inline-block;\">分布式事务</span></h2>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">如何解释分布式事务呢？事务大家都知道吧？<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">要么都执行要么都不执行</strong> 。在同一个系统中我们可以轻松地实现事务，但是在分布式架构中，我们有很多服务是部署在不同系统之间的，而不同服务之间又需要进行调用。比如此时我下订单然后增加积分，如果保证不了分布式事务的话，就会出现A系统下了订单，但是B系统增加积分失败或者A系统没有下订单，B系统却增加了积分。前者对用户不友好，后者对运营商不利，这是我们都不愿意见到的。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">那么，如何去解决这个问题呢？</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">如今比较常见的分布式事务实现有 2PC、TCC 和事务消息(half 半消息机制)。每一种实现都有其特定的使用场景，但是也有各自的问题，<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">都不是完美的解决方案</strong>。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">在 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 中使用的是 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">事务消息加上事务反查机制</strong> 来解决分布式事务问题的。我画了张图，大家可以对照着图进行理解。</p>\n<figure style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><img src=\"https://user-gold-cdn.xitu.io/2019/12/11/16ef38798d7a987f?w=1355&amp;h=360&amp;f=jpeg&amp;s=107566\" alt=\"\" title=\"\" style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;\"><figcaption style=\"line-height: inherit; margin: 0px; padding: 0px; margin-top: 10px; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;\"></figcaption></figure>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">在第一步发送的 half 消息 ，它的意思是 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">在事务提交之前，对于消费者来说，这个消息是不可见的</strong> 。</p>\n<blockquote style=\"line-height: inherit; display: block; padding: 15px 15px 15px 1rem; font-size: 1em; margin: 1em 0px; color: rgb(129, 145, 152); border-left: 8px solid rgb(255, 138, 101); background: rgb(224, 242, 241); overflow: auto; overflow-wrap: normal; word-break: normal; letter-spacing: 1.5px; font-family: YouYuan;\">\n  <p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 0px;\">那么，如何做到写入消息但是对用户不可见呢？RocketMQ事务消息的做法是：如果消息是half消息，将备份原消息的主题与消息消费队列，然后 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">改变主题</strong> 为RMQ_SYS_TRANS_HALF_TOPIC。由于消费组未订阅该主题，故消费端无法消费half类型的消息，<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">然后RocketMQ会开启一个定时任务，从Topic为RMQ_SYS_TRANS_HALF_TOPIC中拉取消息进行消费</strong>，根据生产者组获取一个服务提供者发送回查事务状态请求，根据事务状态来决定是提交或回滚消息。</p>\n</blockquote>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">你可以试想一下，如果没有从第5步开始的 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">事务反查机制</strong> ，如果出现网路波动第4步没有发送成功，这样就会产生 MQ 不知道是不是需要给消费者消费的问题，他就像一个无头苍蝇一样。在 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 中就是使用的上述的事务反查来解决的，而在 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Kafka</code> 中通常是直接抛出一个异常让用户来自行解决。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">你还需要注意的是，在 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">MQ Server</code> 指向系统B的操作已经和系统A不相关了，也就是说在消息队列中的分布式事务是——<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">本地事务和存储消息到消息队列才是同一个事务</strong>。这样也就产生了事务的<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">最终一致性</strong>，因为整个过程是异步的，<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">每个系统只要保证它自己那一部分的事务就行了</strong>。</p>\n<h2 id=\"h-16\" style=\"color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px; font-weight: bold; font-size: 1.5em; border-bottom: 2.2px solid rgb(255, 111, 0);\"><span style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; background: rgb(255, 111, 0); padding: 5px 15px; display: inline-block;\">消息堆积问题</span></h2>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">在上面我们提到了消息队列一个很重要的功能——<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">削峰</strong> 。那么如果这个峰值太大了导致消息堆积在队列中怎么办呢？</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">其实这个问题可以将它广义化，因为产生消息堆积的根源其实就只有两个——生产者生产太快或者消费者消费太慢。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">我们可以从多个角度去思考解决这个问题，当流量到峰值的时候是因为生产者生产太快，我们可以使用一些 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">限流降级</strong> 的方法，当然你也可以增加多个消费者实例去水平扩展增加消费能力来匹配生产的激增。如果消费者消费过慢的话，我们可以先检查 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">是否是消费者出现了大量的消费错误</strong> ，或者打印一下日志查看是否是哪一个线程卡死，出现了锁资源不释放等等的问题。</p>\n<blockquote style=\"line-height: inherit; display: block; padding: 15px 15px 15px 1rem; font-size: 1em; margin: 1em 0px; color: rgb(129, 145, 152); border-left: 8px solid rgb(255, 138, 101); background: rgb(224, 242, 241); overflow: auto; overflow-wrap: normal; word-break: normal; letter-spacing: 1.5px; font-family: YouYuan;\">\n  <p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 0px;\">当然，最快速解决消息堆积问题的方法还是增加消费者实例，不过 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">同时你还需要增加每个主题的队列数量</strong> 。</p>\n  <p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 0px;\">别忘了在 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 中，<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">一个队列只会被一个消费者消费</strong> ，如果你仅仅是增加消费者实例就会出现我一开始给你画架构图的那种情况。</p>\n</blockquote>\n<figure style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><img src=\"https://user-gold-cdn.xitu.io/2019/12/11/16ef387d939ab66d?w=1391&amp;h=555&amp;f=jpeg&amp;s=116552\" alt=\"\" title=\"\" style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;\"><figcaption style=\"line-height: inherit; margin: 0px; padding: 0px; margin-top: 10px; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;\"></figcaption></figure>\n<h2 id=\"h-17\" style=\"color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px; font-weight: bold; font-size: 1.5em; border-bottom: 2.2px solid rgb(255, 111, 0);\"><span style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; background: rgb(255, 111, 0); padding: 5px 15px; display: inline-block;\">回溯消费</span></h2>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">回溯消费是指 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Consumer</code> 已经消费成功的消息，由于业务上需求需要重新消费，在<code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 中， <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 在向<code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Consumer</code> 投递成功消息后，<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">消息仍然需要保留</strong> 。并且重新消费一般是按照时间维度，例如由于 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Consumer</code> 系统故障，恢复后需要重新消费1小时前的数据，那么 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 要提供一种机制，可以按照时间维度来回退消费进度。<code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 支持按照时间回溯消费，时间维度精确到毫秒。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">这是官方文档的解释，我直接照搬过来就当科普了😁😁😁。</p>\n<h2 id=\"hrocketmq-3\" style=\"color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px; font-weight: bold; font-size: 1.5em; border-bottom: 2.2px solid rgb(255, 111, 0);\"><span style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; background: rgb(255, 111, 0); padding: 5px 15px; display: inline-block;\">RocketMQ 的刷盘机制</span></h2>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">上面我讲了那么多的 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 的架构和设计原理，你有没有好奇</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">在 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Topic</code> 中的 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">队列是以什么样的形式存在的？</strong></p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\"><strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">队列中的消息又是如何进行存储持久化的呢？</strong></p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">我在上文中提到的 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">同步刷盘</strong> 和 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">异步刷盘</strong> 又是什么呢？它们会给持久化带来什么样的影响呢？</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">下面我将给你们一一解释。</p>\n<h3 id=\"h-18\" style=\"color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px; font-weight: bold; font-size: 1.3em;\"><span style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\">同步刷盘和异步刷盘</span></h3>\n<figure style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><img src=\"https://user-gold-cdn.xitu.io/2019/12/11/16ef387fba311cda?w=1101&amp;h=874&amp;f=jpeg&amp;s=101763\" alt=\"\" title=\"\" style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;\"><figcaption style=\"line-height: inherit; margin: 0px; padding: 0px; margin-top: 10px; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;\"></figcaption></figure>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">如上图所示，在同步刷盘中需要等待一个刷盘成功的 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">ACK</code> ，同步刷盘对 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">MQ</code> 消息可靠性来说是一种不错的保障，但是 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">性能上会有较大影响</strong> ，一般地适用于金融等特定业务场景。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">而异步刷盘往往是开启一个线程去异步地执行刷盘操作。消息刷盘采用后台异步线程提交的方式进行， <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">降低了读写延迟</strong> ，提高了 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">MQ</code> 的性能和吞吐量，一般适用于如发验证码等对于消息保证要求不太高的业务场景。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">一般地，<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">异步刷盘只有在 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 意外宕机的时候会丢失部分数据</strong>，你可以设置 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 的参数 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">FlushDiskType</code> 来调整你的刷盘策略(ASYNC_FLUSH 或者 SYNC_FLUSH)。</p>\n<h3 id=\"h-19\" style=\"color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px; font-weight: bold; font-size: 1.3em;\"><span style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\">同步复制和异步复制</span></h3>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">上面的同步刷盘和异步刷盘是在单个结点层面的，而同步复制和异步复制主要是指的 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Borker</code> 主从模式下，主节点返回消息给客户端的时候是否需要同步从节点。</p>\n<ul style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px; padding-left: 32px; list-style-type: disc;\">\n<li style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px; margin-bottom: 0.5em;\">同步复制： 也叫 “同步双写”，也就是说，<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">只有消息同步双写到主从结点上时才返回写入成功</strong> 。</li>\n<li style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px; margin-bottom: 0.5em;\">异步复制： <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">消息写入主节点之后就直接返回写入成功</strong> 。</li>\n</ul>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">然而，很多事情是没有完美的方案的，就比如我们进行消息写入的节点越多就更能保证消息的可靠性，但是随之的性能也会下降，所以需要程序员根据特定业务场景去选择适应的主从复制方案。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">那么，<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">异步复制会不会也像异步刷盘那样影响消息的可靠性呢？</strong></p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">答案是不会的，因为两者就是不同的概念，对于消息可靠性是通过不同的刷盘策略保证的，而像异步同步复制策略仅仅是影响到了 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">可用性</strong> 。为什么呢？其主要原因<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">是 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 是不支持自动主从切换的，当主节点挂掉之后，生产者就不能再给这个主节点生产消息了</strong>。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">比如这个时候采用异步复制的方式，在主节点还未发送完需要同步的消息的时候主节点挂掉了，这个时候从节点就少了一部分消息。但是此时生产者无法再给主节点生产消息了，<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">消费者可以自动切换到从节点进行消费</strong>(仅仅是消费)，所以在主节点挂掉的时间只会产生主从结点短暂的消息不一致的情况，降低了可用性，而当主节点重启之后，从节点那部分未来得及复制的消息还会继续复制。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">在单主从架构中，如果一个主节点挂掉了，那么也就意味着整个系统不能再生产了。那么这个可用性的问题能否解决呢？<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">一个主从不行那就多个主从的呗</strong>，别忘了在我们最初的架构图中，每个 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Topic</code> 是分布在不同 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 中的。</p>\n<figure style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><img src=\"https://user-gold-cdn.xitu.io/2019/12/11/16ef38823b165817?w=936&amp;h=673&amp;f=jpeg&amp;s=93578\" alt=\"\" title=\"\" style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;\"><figcaption style=\"line-height: inherit; margin: 0px; padding: 0px; margin-top: 10px; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;\"></figcaption></figure>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">但是这种复制方式同样也会带来一个问题，那就是无法保证 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">严格顺序</strong> 。在上文中我们提到了如何保证的消息顺序性是通过将一个语义的消息发送在同一个队列中，使用 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Topic</code> 下的队列来保证顺序性的。如果此时我们主节点A负责的是订单A的一系列语义消息，然后它挂了，这样其他节点是无法代替主节点A的，如果我们任意节点都可以存入任何消息，那就没有顺序性可言了。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">而在 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 中采用了 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Dledger</code> 解决这个问题。他要求在写入消息的时候，要求<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">至少消息复制到半数以上的节点之后</strong>，才给客⼾端返回写⼊成功，并且它是⽀持通过选举来动态切换主节点的。这里我就不展开说明了，读者可以自己去了解。</p>\n<blockquote style=\"line-height: inherit; display: block; padding: 15px 15px 15px 1rem; font-size: 1em; margin: 1em 0px; color: rgb(129, 145, 152); border-left: 8px solid rgb(255, 138, 101); background: rgb(224, 242, 241); overflow: auto; overflow-wrap: normal; word-break: normal; letter-spacing: 1.5px; font-family: YouYuan;\">\n  <p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 0px;\">也不是说 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Dledger</code> 是个完美的方案，至少在 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Dledger</code> 选举过程中是无法提供服务的，而且他必须要使用三个节点或以上，如果多数节点同时挂掉他也是无法保证可用性的，而且要求消息复制板书以上节点的效率和直接异步复制还是有一定的差距的。</p>\n</blockquote>\n<h3 id=\"h-20\" style=\"color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px; font-weight: bold; font-size: 1.3em;\"><span style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\">存储机制</span></h3>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">还记得上面我们一开始的三个问题吗？到这里第三个问题已经解决了。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">但是，在 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Topic</code> 中的 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">队列是以什么样的形式存在的？队列中的消息又是如何进行存储持久化的呢？</strong> 还未解决，其实这里涉及到了 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 是如何设计它的存储结构了。我首先想大家介绍 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 消息存储架构中的三大角色——<code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">CommitLog</code> 、<code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">ConsumeQueue</code> 和 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">IndexFile</code> 。</p>\n<ul style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px; padding-left: 32px; list-style-type: disc;\">\n<li style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px; margin-bottom: 0.5em;\"><code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">CommitLog</code>： <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">消息主体以及元数据的存储主体</strong>，存储 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Producer</code> 端写入的消息主体内容,消息内容不是定长的。单个文件大小默认1G ，文件名长度为20位，左边补零，剩余为起始偏移量，比如00000000000000000000代表了第一个文件，起始偏移量为0，文件大小为1G=1073741824；当第一个文件写满了，第二个文件为00000000001073741824，起始偏移量为1073741824，以此类推。消息主要是<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">顺序写入日志文件</strong>，当文件满了，写入下一个文件。</li>\n<li style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px; margin-bottom: 0.5em;\"><code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">ConsumeQueue</code>： 消息消费队列，<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">引入的目的主要是提高消息消费的性能</strong>(我们再前面也讲了)，由于<code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 是基于主题 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Topic</code> 的订阅模式，消息消费是针对主题进行的，如果要遍历 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">commitlog</code> 文件中根据 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Topic</code> 检索消息是非常低效的。<code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Consumer</code> 即可根据 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">ConsumeQueue</code> 来查找待消费的消息。其中，<code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">ConsumeQueue</code>（逻辑消费队列）<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">作为消费消息的索引</strong>，保存了指定 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Topic</code> 下的队列消息在 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">CommitLog</code> 中的 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">起始物理偏移量</strong> <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">offset</code>，<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">消息大小</strong><code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">size</code> 和消息 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Tag</code> 的 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">HashCode</code> 值。<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">consumequeue文件</strong> 可以看成是基于topic的 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">commitlog索引文件</strong> ，故 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">consumequeue</code> 文件夹的组织方式如下：topic/queue/file三层组织结构，具体存储路径为：$HOME/store/consumequeue/{topic}/{queueId}/{fileName}。同样 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">consumequeue</code> 文件采取定长设计，每一个条目共20个字节，分别为8字节的 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">commitlog</code> 物理偏移量、4字节的消息长度、8字节tag <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">hashcode</code>，单个文件由30W个条目组成，可以像数组一样随机访问每一个条目，每个 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">ConsumeQueue</code>文件大小约5.72M；</li>\n<li style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px; margin-bottom: 0.5em;\"><code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">IndexFile</code>： <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">IndexFile</code>（索引文件）提供了一种可以通过key或时间区间来查询消息的方法。这里只做科普不做详细介绍。</li>\n</ul>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">总结来说，整个消息存储的结构，最主要的就是 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">CommitLoq</code> 和 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">ConsumeQueue</code> 。而 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">ConsumeQueue</code> 你可以大概理解为 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Topic</code> 中的队列。</p>\n<figure style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><img src=\"https://user-gold-cdn.xitu.io/2019/12/11/16ef3884c02acc72?w=745&amp;h=341&amp;f=jpeg&amp;s=51683\" alt=\"\" title=\"\" style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;\"><figcaption style=\"line-height: inherit; margin: 0px; padding: 0px; margin-top: 10px; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;\"></figcaption></figure>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\"><code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 采用的是 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">混合型的存储结构</strong> ，即为 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 单个实例下所有的队列共用一个日志数据文件来存储消息。有意思的是在同样高并发的 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Kafka</code> 中会为每个 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Topic</code> 分配一个存储文件。这就有点类似于我们有一大堆书需要装上书架，<code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RockeMQ</code> 是不分书的种类直接成批的塞上去的，而 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Kafka</code> 是将书本放入指定的分类区域的。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">而 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 为什么要这么做呢？原因是 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">提高数据的写入效率</strong> ，不分 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Topic</code> 意味着我们有更大的几率获取 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">成批</strong> 的消息进行数据写入，但也会带来一个麻烦就是读取消息的时候需要遍历整个大文件，这是非常耗时的。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">所以，在 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 中又使用了 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">ConsumeQueue</code> 作为每个队列的索引文件来 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">提升读取消息的效率</strong>。我们可以直接根据队列的消息序号，计算出索引的全局位置（索引序号*索引固定⻓度20），然后直接读取这条索引，再根据索引中记录的消息的全局位置，找到消息。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">讲到这里，你可能对 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RockeMQ</code> 的存储架构还有些模糊，没事，我们结合着图来理解一下。</p>\n<figure style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><img src=\"https://user-gold-cdn.xitu.io/2019/12/11/16ef388763c25c62?w=1142&amp;h=896&amp;f=png&amp;s=111170\" alt=\"\" title=\"\" style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;\"><figcaption style=\"line-height: inherit; margin: 0px; padding: 0px; margin-top: 10px; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;\"></figcaption></figure>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">emmm，是不是有一点复杂🤣，看英文图片和英文文档的时候就不要怂，硬着头皮往下看就行。</p>\n<blockquote style=\"line-height: inherit; display: block; padding: 15px 15px 15px 1rem; font-size: 1em; margin: 1em 0px; color: rgb(129, 145, 152); border-left: 8px solid rgb(255, 138, 101); background: rgb(224, 242, 241); overflow: auto; overflow-wrap: normal; word-break: normal; letter-spacing: 1.5px; font-family: YouYuan;\">\n  <p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 0px;\">如果上面没看懂的读者一定要认真看下面的流程分析！</p>\n</blockquote>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">首先，在最上面的那一块就是我刚刚讲的你现在可以直接 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">把 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">ConsumerQueue</code> 理解为 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Queue</code></strong>。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">在图中最左边说明了 <font color=\"red\" style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\">红色方块 </font> 代表被写入的消息，虚线方块代表等待被写入的。左边的生产者发送消息会指定 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Topic</code> 、<code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">QueueId</code> 和具体消息内容，而在 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 中管你是哪门子消息，他直接 **全部顺序存储到了 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">CommitLog</code> **。而根据生产者指定的 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Topic</code> 和 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">QueueId</code> 将这条消息本身在 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">CommitLog</code> 的偏移(offset)，消息本身大小，和tag的hash值存入对应的 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">ConsumeQueue</code> 索引文件中。而在每个队列中都保存了 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">ConsumeOffset</code> 即每个消费者组的消费位置(我在架构那里提到了，忘了的同学可以回去看一下)，而消费者拉取消息进行消费的时候只需要根据 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">ConsumeOffset</code> 获取下一个未被消费的消息就行了。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">上述就是我对于整个消息存储架构的大概理解(这里不涉及到一些细节讨论，比如稀疏索引等等问题)，希望对你有帮助。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">因为有一个知识点因为写嗨了忘讲了，想想在哪里加也不好，所以我留给大家去思考🤔🤔一下吧。</p>\n<figure style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><img src=\"https://user-gold-cdn.xitu.io/2019/12/11/16ef38894e8ff697?w=255&amp;h=255&amp;f=jpeg&amp;s=8769\" alt=\"\" title=\"\" style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;\"><figcaption style=\"line-height: inherit; margin: 0px; padding: 0px; margin-top: 10px; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;\"></figcaption></figure>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">为什么 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">CommitLog</code> 文件要设计成固定大小的长度呢？提醒：<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">内存映射机制</strong>。</p>\n<h2 id=\"h-21\" style=\"color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px; font-weight: bold; font-size: 1.5em; border-bottom: 2.2px solid rgb(255, 111, 0);\"><span style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; background: rgb(255, 111, 0); padding: 5px 15px; display: inline-block;\">总结</span></h2>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">总算把这篇博客写完了。我讲的你们还记得吗😅？</p>\n<figure style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><img src=\"https://user-gold-cdn.xitu.io/2019/12/11/16ef388ad16144f1?w=255&amp;h=255&amp;f=jpeg&amp;s=10422\" alt=\"\" title=\"\" style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;\"><figcaption style=\"line-height: inherit; margin: 0px; padding: 0px; margin-top: 10px; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;\"></figcaption></figure>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">这篇文章中我主要想大家介绍了</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">消息队列出现的原因</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">消息队列的作用(异步，解耦，削峰)</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">消息队列带来的一系列问题(消息堆积、重复消费、顺序消费、分布式事务等等)</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">消息队列的两种消息模型——队列和主题模式</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">分析了 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 的技术架构(<code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">NameServer</code> 、<code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 、<code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Producer</code> 、<code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Comsumer</code>)</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">结合着 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 回答了消息队列副作用的解决方案</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">介绍了 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 的存储机制和刷盘策略。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">等等。。。</p>\n<blockquote style=\"line-height: inherit; display: block; padding: 15px 15px 15px 1rem; font-size: 1em; margin: 1em 0px; color: rgb(129, 145, 152); border-left: 8px solid rgb(255, 138, 101); background: rgb(224, 242, 241); overflow: auto; overflow-wrap: normal; word-break: normal; letter-spacing: 1.5px; font-family: YouYuan;\">\n  <p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 0px;\">如果喜欢可以点赞哟👍👍👍。</p>\n</blockquote></div>","blogCover":"","blogId":3,"blogTitle":"👉冒着挂科的风险也要给你看的消息队列和RocketMQ入门总结"}
2019-12-30 12:18:35.252 [http-nio-8080-exec-9] INFO  com.lgq.controller.BlogController - FrancisBlog: getBlogList:1
2019-12-30 12:18:38.804 [http-nio-8080-exec-4] INFO  com.lgq.controller.TokenController - FrancisBlog: getToken
2019-12-30 12:18:38.813 [http-nio-8080-exec-10] INFO  com.lgq.controller.BlogController - FrancisBlog: getBlogById: blog_id:3
2019-12-30 12:18:38.816 [http-nio-8080-exec-7] INFO  com.lgq.controller.CategoryController - FrancisBlog: getAllCategory
2019-12-30 12:18:38.817 [http-nio-8080-exec-6] INFO  com.lgq.controller.TagController - FrancisBlog: getAllTag
2019-12-30 12:18:38.822 [http-nio-8080-exec-10] INFO  com.lgq.service.impl.BlogServiceImpl - null
2019-12-30 12:18:38.932 [http-nio-8080-exec-10] INFO  com.lgq.service.impl.BlogServiceImpl - 13
2019-12-30 12:18:45.775 [http-nio-8080-exec-3] INFO  com.lgq.controller.BlogController - FrancisBlog: updateBlogById -> {"blogCategoryId":1,"blogContent":"<div class=\"output_wrapper\" id=\"output_wrapper_id\" style=\"font-size: 16px; color: rgb(62, 62, 62); line-height: 1.7; word-spacing: 0px; letter-spacing: 0px; font-family: 'Helvetica Neue', Helvetica, 'Hiragino Sans GB', 'Microsoft YaHei', Arial, sans-serif; background-image: linear-gradient(90deg, rgba(50, 0, 0, 0.05) 3%, rgba(0, 0, 0, 0) 3%), linear-gradient(360deg, rgba(50, 0, 0, 0.05) 3%, rgba(0, 0, 0, 0) 3%); background-size: 20px 20px; background-position: center center;\"><h2 id=\"h\" style=\"color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px; font-weight: bold; font-size: 1.5em; border-bottom: 2.2px solid rgb(255, 111, 0);\"><span style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; background: rgb(255, 111, 0); padding: 5px 15px; display: inline-block;\">吐槽</span></h2>\n<blockquote style=\"line-height: inherit; display: block; padding: 15px 15px 15px 1rem; font-size: 1em; margin: 1em 0px; color: rgb(129, 145, 152); border-left: 8px solid rgb(255, 138, 101); background: rgb(224, 242, 241); overflow: auto; overflow-wrap: normal; word-break: normal; letter-spacing: 1.5px; font-family: YouYuan;\">\n  <p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 0px;\">文章很长，点赞再看，养成好习惯😋😋😋</p>\n</blockquote>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">这真的是考前的最后一篇博客，再写真的要挂科了。</p>\n<figure style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><img src=\"https://user-gold-cdn.xitu.io/2019/12/11/16ef37eaae5f8d42?w=255&amp;h=255&amp;f=jpeg&amp;s=11940\" alt=\"\" title=\"\" style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;\"><figcaption style=\"line-height: inherit; margin: 0px; padding: 0px; margin-top: 10px; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;\"></figcaption></figure>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">其实一直想吐槽现在很多大学的计算机教育的，我从大二开始入门 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Java</code>后端，其实我觉得我的学习效率很低，中间也走了很多歪路。但是，如今和同龄人比较，我发现大部分同学竟然连基本的代码都不会敲，尤其到了课程设计大家都是水水过的，让他们做一个管理系统简直要他们命。包括现在大三了，很多人希望本科就出来就业的开始报培训班，培机构开始大把大把地捞金，学生在那疯狂吐槽三四年里没有从学校学到任何东西，这可能是大部分大学计算机教育的通病吧。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">当然还有很多师资力量的问题，不知道清北的，但在我认识的一些 211 或者某些 985 的同学，他们学校的老师或者所教的一些知识也已经落伍了好多年了(当然不是指一些操作系统类似的基础学科，我觉得它们是几十年都不变的)。如果一个数据库老师会告诉你 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">MySQL</code> 不支持事务，一个数据结构老师说 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">B+树</code> 是二叉树，甚至在学生提到一些新的东西的时候没有了解过并且不想去了解，你们会怎么想。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">但很庆幸，在大二的时候加入了我们学校最牛的技术组织 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">TECH F5VE</code> ，这是一个学生组织的创业型技术团队，成立五年目前成员四十人不到，但里面不乏各种大厂的大牛，我在里面获得了很多很多。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">当然，参加过一些小公司的实习或者和他们合作过做一些外包项目，但发现他们的技术选型也已经 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">out</code> 了，我们团队的成员戏称 \"考古式开发\"。我想这也是大部分人挤破了头皮想要进大厂的理由吧。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">可能观点有点偏激，希望大家理解🤐🤐🤐。</p>\n<h2 id=\"h-1\" style=\"color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px; font-weight: bold; font-size: 1.5em; border-bottom: 2.2px solid rgb(255, 111, 0);\"><span style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; background: rgb(255, 111, 0); padding: 5px 15px; display: inline-block;\">消息队列扫盲</span></h2>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">消息队列顾名思义就是存放消息的队列，队列我就不解释了，别告诉我你连队列都不知道似啥吧？</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">所以问题并不是消息队列是什么，而是 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">消息队列为什么会出现？消息队列能用来干什么？用它来干这些事会带来什么好处？消息队列会带来副作用吗？</strong></p>\n<h3 id=\"h-2\" style=\"color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px; font-weight: bold; font-size: 1.3em;\"><span style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\">消息队列为什么会出现？</span></h3>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">消息队列算是作为后端程序员的一个必备技能吧，因为<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">分布式应用必定涉及到各个系统之间的通信问题</strong>，这个时候消息队列也应运而生了。可以说分布式的产生是消息队列的基础，而分布式怕是一个很古老的概念了吧，所以消息队列也是一个很古老的中间件了。</p>\n<h3 id=\"h-3\" style=\"color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px; font-weight: bold; font-size: 1.3em;\"><span style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\">消息队列能用来干什么？</span></h3>\n<h4 id=\"h-4\" style=\"color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px; font-weight: bold; font-size: 1.2em;\"><span style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\">异步</span></h4>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">你可能会反驳我，应用之间的通信又不是只能由消息队列解决，好好的通信为什么中间非要插一个消息队列呢？我不能直接进行通信吗？</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">很好👍，你又提出了一个概念，<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">同步通信</strong>。就比如现在业界使用比较多的 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Dubbo</code> 就是一个适用于各个系统之间同步通信的 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RPC</code> 框架。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">我来举个🌰吧，比如我们有一个购票系统，需求是用户在购买完之后能接收到购买完成的短信。</p>\n<figure style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><img src=\"https://user-gold-cdn.xitu.io/2019/12/11/16ef37fee7e09230?w=951&amp;h=209&amp;f=jpeg&amp;s=20202\" alt=\"\" title=\"\" style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;\"><figcaption style=\"line-height: inherit; margin: 0px; padding: 0px; margin-top: 10px; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;\"></figcaption></figure>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">我们省略中间的网络通信时间消耗，假如购票系统处理需要 150ms ，短信系统处理需要 200ms ，那么整个处理流程的时间消耗就是 150ms + 200ms = 350ms。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">当然，乍看没什么问题。可是仔细一想你就感觉有点问题，我用户购票在购票系统的时候其实就已经完成了购买，而我现在通过同步调用非要让整个请求拉长时间，而短息系统这玩意又不是很有必要，它仅仅是一个辅助功能增强用户体验感而已。我现在整个调用流程就有点 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">头重脚轻</strong> 的感觉了，购票是一个不太耗时的流程，而我现在因为同步调用，非要等待发送短信这个比较耗时的操作才返回结果。那我如果再加一个发送邮件呢？</p>\n<figure style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><img src=\"https://user-gold-cdn.xitu.io/2019/12/11/16ef380429cf373e?w=1364&amp;h=210&amp;f=jpeg&amp;s=28357\" alt=\"\" title=\"\" style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;\"><figcaption style=\"line-height: inherit; margin: 0px; padding: 0px; margin-top: 10px; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;\"></figcaption></figure>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">这样整个系统的调用链又变长了，整个时间就变成了550ms。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">当我们在学生时代需要在食堂排队的时候，我们和食堂大妈就是一个同步的模型。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">我们需要告诉食堂大妈：“姐姐，给我加个鸡腿，再加个酸辣土豆丝，帮我浇点汁上去，多打点饭哦😋😋😋”  咦~~~ 为了多吃点，真恶心。</p>\n<figure style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><img src=\"https://user-gold-cdn.xitu.io/2019/12/11/16ef3807de75dce5?w=170&amp;h=220&amp;f=gif&amp;s=489646\" alt=\"\" title=\"\" style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;\"><figcaption style=\"line-height: inherit; margin: 0px; padding: 0px; margin-top: 10px; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;\"></figcaption></figure>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">然后大妈帮我们打饭配菜，我们看着大妈那颤抖的手和掉落的土豆丝不禁咽了咽口水。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">最终我们从大妈手中接过饭菜然后去寻找座位了…</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">回想一下，我们在给大妈发送需要的信息之后我们是 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">同步等待大妈给我配好饭菜</strong> 的，上面我们只是加了鸡腿和土豆丝，万一我再加一个番茄牛腩，韭菜鸡蛋，这样是不是大妈打饭配菜的流程就会变长，我们等待的时间也会相应的变长。</p>\n<figure style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><img src=\"https://user-gold-cdn.xitu.io/2019/12/11/16ef380ae4f8be5b?w=250&amp;h=221&amp;f=jpeg&amp;s=8279\" alt=\"\" title=\"\" style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;\"><figcaption style=\"line-height: inherit; margin: 0px; padding: 0px; margin-top: 10px; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;\"></figcaption></figure>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">那后来，我们工作赚钱了有钱去饭店吃饭了，我们告诉服务员来一碗牛肉面加个荷包蛋 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">(传达一个消息)</strong> ，然后我们就可以在饭桌上安心的玩手机了 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">(干自己其他事情)</strong> ，等到我们的牛肉面上了我们就可以吃了。这其中我们也就传达了一个消息，然后我们又转过头干其他事情了。这其中虽然做面的时间没有变短，但是我们只需要传达一个消息就可以看其他事情了，这是一个 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">异步</strong> 的概念。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">所以，为了解决这一个问题，聪明的程序员在中间也加了个类似于服务员的中间件——消息队列。这个时候我们就可以把模型给改造了。</p>\n<figure style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><img src=\"https://user-gold-cdn.xitu.io/2019/12/11/16ef38124f55eaea?w=1194&amp;h=326&amp;f=jpeg&amp;s=47622\" alt=\"\" title=\"\" style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;\"><figcaption style=\"line-height: inherit; margin: 0px; padding: 0px; margin-top: 10px; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;\"></figcaption></figure>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">这样，我们在将消息存入消息队列之后我们就可以直接返回了(我们告诉服务员我们要吃什么然后玩手机)，所以整个耗时只是 150ms + 10ms = 160ms。</p>\n<blockquote style=\"line-height: inherit; display: block; padding: 15px 15px 15px 1rem; font-size: 1em; margin: 1em 0px; color: rgb(129, 145, 152); border-left: 8px solid rgb(255, 138, 101); background: rgb(224, 242, 241); overflow: auto; overflow-wrap: normal; word-break: normal; letter-spacing: 1.5px; font-family: YouYuan;\">\n  <p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 0px;\">但是你需要注意的是，整个流程的时长是没变的，就像你仅仅告诉服务员要吃什么是不会影响到做面的速度的。</p>\n</blockquote>\n<h4 id=\"h-5\" style=\"color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px; font-weight: bold; font-size: 1.2em;\"><span style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\">解耦</span></h4>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">回到最初同步调用的过程，我们写个伪代码简单概括一下。</p>\n<figure style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><img src=\"https://user-gold-cdn.xitu.io/2019/12/11/16ef381a505d3e1f?w=538&amp;h=337&amp;f=png&amp;s=42350\" alt=\"\" title=\"\" style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;\"><figcaption style=\"line-height: inherit; margin: 0px; padding: 0px; margin-top: 10px; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;\"></figcaption></figure>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">那么第二步，我们又添加了一个发送邮件，我们就得重新去修改代码，如果我们又加一个需求：用户购买完还需要给他加积分，这个时候我们是不是又得改代码？</p>\n<figure style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><img src=\"https://user-gold-cdn.xitu.io/2019/12/11/16ef381c4e1b1ac7?w=538&amp;h=463&amp;f=png&amp;s=53705\" alt=\"\" title=\"\" style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;\"><figcaption style=\"line-height: inherit; margin: 0px; padding: 0px; margin-top: 10px; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;\"></figcaption></figure>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">如果你觉得还行，那么我这个时候不要发邮件这个服务了呢，我是不是又得改代码，又得重启应用？</p>\n<figure style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><img src=\"https://user-gold-cdn.xitu.io/2019/12/11/16ef381f273a66bd?w=200&amp;h=200&amp;f=jpeg&amp;s=8544\" alt=\"\" title=\"\" style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;\"><figcaption style=\"line-height: inherit; margin: 0px; padding: 0px; margin-top: 10px; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;\"></figcaption></figure>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">这样改来改去是不是很麻烦，那么 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">此时我们就用一个消息队列在中间进行解耦</strong> 。你需要注意的是，我们后面的发送短信、发送邮件、添加积分等一些操作都依赖于上面的 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">result</code> ，这东西抽象出来就是购票的处理结果呀，比如订单号，用户账号等等，也就是说我们后面的一系列服务都是需要同样的消息来进行处理。既然这样，我们是不是可以通过 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">“广播消息”</strong> 来实现。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">我上面所讲的“广播”并不是真正的广播，而是接下来的系统作为消费者去 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">订阅</strong> 特定的主题。比如我们这里的主题就可以叫做 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">订票</code> ，我们购买系统作为一个生产者去生产这条消息放入消息队列，然后消费者订阅了这个主题，会从消息队列中拉取消息并消费。就比如我们刚刚画的那张图，你会发现，在生产者这边我们只需要关注 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">生产消息到指定主题中</strong> ，而 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">消费者只需要关注从指定主题中拉取消息</strong> 就行了。</p>\n<figure style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><img src=\"https://user-gold-cdn.xitu.io/2019/12/11/16ef382674b66892?w=1194&amp;h=326&amp;f=jpeg&amp;s=47622\" alt=\"\" title=\"\" style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;\"><figcaption style=\"line-height: inherit; margin: 0px; padding: 0px; margin-top: 10px; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;\"></figcaption></figure>\n<blockquote style=\"line-height: inherit; display: block; padding: 15px 15px 15px 1rem; font-size: 1em; margin: 1em 0px; color: rgb(129, 145, 152); border-left: 8px solid rgb(255, 138, 101); background: rgb(224, 242, 241); overflow: auto; overflow-wrap: normal; word-break: normal; letter-spacing: 1.5px; font-family: YouYuan;\">\n  <p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 0px;\">如果没有消息队列，每当一个新的业务接入，我们都要在主系统调用新接口、或者当我们取消某些业务，我们也得在主系统删除某些接口调用。有了消息队列，我们只需要关心消息是否送达了队列，至于谁希望订阅，接下来收到消息如何处理，是下游的事情，无疑极大地减少了开发和联调的工作量。</p>\n</blockquote>\n<h4 id=\"h-6\" style=\"color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px; font-weight: bold; font-size: 1.2em;\"><span style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\">削峰</span></h4>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">我们再次回到一开始我们使用同步调用系统的情况，并且思考一下，如果此时有大量用户请求购票整个系统会变成什么样？</p>\n<figure style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><img src=\"https://user-gold-cdn.xitu.io/2019/12/11/16ef382a9756bb1c?w=1048&amp;h=469&amp;f=jpeg&amp;s=38175\" alt=\"\" title=\"\" style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;\"><figcaption style=\"line-height: inherit; margin: 0px; padding: 0px; margin-top: 10px; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;\"></figcaption></figure>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">如果，此时有一万的请求进入购票系统，我们知道运行我们主业务的服务器配置一般会比较好，所以这里我们假设购票系统能承受这一万的用户请求，那么也就意味着我们同时也会出现一万调用发短信服务的请求。而对于短信系统来说并不是我们的主要业务，所以我们配备的硬件资源并不会太高，那么你觉得现在这个短信系统能承受这一万的峰值么，且不说能不能承受，系统会不会 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">直接崩溃</strong> 了？</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">短信业务又不是我们的主业务，我们能不能 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">折中处理</strong> 呢？如果我们把购买完成的信息发送到消息队列中，而短信系统 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">尽自己所能地去消息队列中取消息和消费消息</strong> ，即使处理速度慢一点也无所谓，只要我们的系统没有崩溃就行了。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">留得江山在，还怕没柴烧？你敢说每次发送验证码的时候是一发你就收到了的么？</p>\n<h4 id=\"h-7\" style=\"color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px; font-weight: bold; font-size: 1.2em;\"><span style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\">消息队列能带来什么好处？</span></h4>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">其实上面我已经说了。<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">异步、解耦、削峰。</strong> 哪怕你上面的都没看懂也千万要记住这六个字，因为他不仅是消息队列的精华，更是编程和架构的精华。</p>\n<h4 id=\"h-8\" style=\"color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px; font-weight: bold; font-size: 1.2em;\"><span style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\">消息队列会带来副作用吗？</span></h4>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">没有哪一门技术是“银弹”，消息队列也有它的副作用。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">比如，本来好好的两个系统之间的调用，我中间加了个消息队列，如果消息队列挂了怎么办呢？是不是 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">降低了系统的可用性</strong> ？</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">那这样是不是要保证HA(高可用)？是不是要搞集群？那么我 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">整个系统的复杂度是不是上升了</strong> ？</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">抛开上面的问题不讲，万一我发送方发送失败了，然后执行重试，这样就可能产生重复的消息。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">或者我消费端处理失败了，请求重发，这样也会产生重复的消息。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">对于一些微服务来说，消费重复消息会带来更大的麻烦，比如增加积分，这个时候我加了多次是不是对其他用户不公平？</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">那么，又 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">如何解决重复消费消息的问题</strong> 呢？</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">如果我们此时的消息需要保证严格的顺序性怎么办呢？比如生产者生产了一系列的有序消息(对一个id为1的记录进行删除增加修改)，但是我们知道在发布订阅模型中，对于主题是无顺序的，那么这个时候就会导致对于消费者消费消息的时候没有按照生产者的发送顺序消费，比如这个时候我们消费的顺序为修改删除增加，如果该记录涉及到金额的话是不是会出大事情？</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">那么，又 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">如何解决消息的顺序消费问题</strong> 呢？</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">就拿我们上面所讲的分布式系统来说，用户购票完成之后是不是需要增加账户积分？在同一个系统中我们一般会使用事务来进行解决，如果用 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Spring</code> 的话我们在上面伪代码中加入 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">@Transactional</code> 注解就好了。但是在不同系统中如何保证事务呢？总不能这个系统我扣钱成功了你那积分系统积分没加吧？或者说我这扣钱明明失败了，你那积分系统给我加了积分。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">那么，又如何 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">解决分布式事务问题</strong> 呢？</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">我们刚刚说了，消息队列可以进行削峰操作，那如果我的消费者如果消费很慢或者生产者生产消息很快，这样是不是会将消息堆积在消息队列中？</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">那么，又如何 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">解决消息堆积的问题</strong> 呢？</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">可用性降低，复杂度上升，又带来一系列的重复消费，顺序消费，分布式事务，消息堆积的问题，这消息队列还怎么用啊😵？</p>\n<figure style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><img src=\"https://user-gold-cdn.xitu.io/2019/12/11/16ef382d709abc9d?w=255&amp;h=255&amp;f=jpeg&amp;s=8169\" alt=\"\" title=\"\" style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;\"><figcaption style=\"line-height: inherit; margin: 0px; padding: 0px; margin-top: 10px; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;\"></figcaption></figure>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">别急，办法总是有的。</p>\n<h2 id=\"hrocketmq\" style=\"color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px; font-weight: bold; font-size: 1.5em; border-bottom: 2.2px solid rgb(255, 111, 0);\"><span style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; background: rgb(255, 111, 0); padding: 5px 15px; display: inline-block;\">RocketMQ是什么？</span></h2>\n<figure style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><img src=\"https://user-gold-cdn.xitu.io/2019/12/11/16ef383014430799?w=1450&amp;h=430&amp;f=jpeg&amp;s=103646\" alt=\"\" title=\"\" style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;\"><figcaption style=\"line-height: inherit; margin: 0px; padding: 0px; margin-top: 10px; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;\"></figcaption></figure>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">哇，你个混蛋！上面给我抛出那么多问题，你现在又讲 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> ，还让不让人活了？！🤬</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">别急别急，话说你现在清楚 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">MQ</code> 的构造吗，我还没讲呢，我们先搞明白 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">MQ</code> 的内部构造，再来看看如何解决上面的一系列问题吧，不过你最好带着问题去阅读和了解喔。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\"><code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 是一个 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">队列模型</strong> 的消息中间件，具有<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">高性能、高可靠、高实时、分布式</strong> 的特点。它是一个采用 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Java</code> 语言开发的分布式的消息系统，由阿里巴巴团队开发，在2016年底贡献给 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Apache</code>，成为了 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Apache</code> 的一个顶级项目。 在阿里内部，<code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 很好地服务了集团大大小小上千个应用，在每年的双十一当天，更有不可思议的万亿级消息通过 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 流转。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">废话不多说，想要了解 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 历史的同学可以自己去搜寻资料。听完上面的介绍，你只要知道 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 很快、很牛、而且经历过双十一的实践就行了！</p>\n<h2 id=\"h-9\" style=\"color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px; font-weight: bold; font-size: 1.5em; border-bottom: 2.2px solid rgb(255, 111, 0);\"><span style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; background: rgb(255, 111, 0); padding: 5px 15px; display: inline-block;\">队列模型和主题模型</span></h2>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">在谈 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 的技术架构之前，我们先来了解一下两个名词概念——<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">队列模型</strong> 和 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">主题模型</strong> 。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">首先我问一个问题，消息队列为什么要叫消息队列？</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">你可能觉得很弱智，这玩意不就是存放消息的队列嘛？不叫消息队列叫什么？</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">的确，早期的消息中间件是通过 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">队列</strong> 这一模型来实现的，可能是历史原因，我们都习惯把消息中间件成为消息队列。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">但是，如今例如 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 、<code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Kafka</code> 这些优秀的消息中间件不仅仅是通过一个 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">队列</strong> 来实现消息存储的。</p>\n<h3 id=\"h-10\" style=\"color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px; font-weight: bold; font-size: 1.3em;\"><span style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\">队列模型</span></h3>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">就像我们理解队列一样，消息中间件的队列模型就真的只是一个队列。。。我画一张图给大家理解。</p>\n<figure style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><img src=\"https://user-gold-cdn.xitu.io/2019/12/11/16ef3834ae653469?w=760&amp;h=142&amp;f=jpeg&amp;s=22424\" alt=\"\" title=\"\" style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;\"><figcaption style=\"line-height: inherit; margin: 0px; padding: 0px; margin-top: 10px; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;\"></figcaption></figure>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">在一开始我跟你提到了一个 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">“广播”</strong> 的概念，也就是说如果我们此时我们需要将一个消息发送给多个消费者(比如此时我需要将信息发送给短信系统和邮件系统)，这个时候单个队列即不能满足需求了。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">当然你可以让 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Producer</code> 生产消息放入多个队列中，然后每个队列去对应每一个消费者。问题是可以解决，创建多个队列并且复制多份消息是会很影响资源和性能的。而且，这样子就会导致生产者需要知道具体消费者个数然后去复制对应数量的消息队列，这就违背我们消息中间件的 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">解耦</strong> 这一原则。</p>\n<h3 id=\"h-11\" style=\"color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px; font-weight: bold; font-size: 1.3em;\"><span style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\">主题模型</span></h3>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">那么有没有好的方法去解决这一个问题呢？有，那就是 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">主题模型</strong> 或者可以称为 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">发布订阅模型</strong> 。</p>\n<blockquote style=\"line-height: inherit; display: block; padding: 15px 15px 15px 1rem; font-size: 1em; margin: 1em 0px; color: rgb(129, 145, 152); border-left: 8px solid rgb(255, 138, 101); background: rgb(224, 242, 241); overflow: auto; overflow-wrap: normal; word-break: normal; letter-spacing: 1.5px; font-family: YouYuan;\">\n  <p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 0px;\">感兴趣的同学可以去了解一下设计模式里面的观察者模式并且手动实现一下，我相信你会有所收获的。</p>\n</blockquote>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">在主题模型中，消息的生产者称为 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">发布者(Publisher)</strong> ，消息的消费者称为 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">订阅者(Subscriber)</strong> ，存放消息的容器称为 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">主题(Topic)</strong> 。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">其中，发布者将消息发送到指定主题中，订阅者需要 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">提前订阅主题</strong> 才能接受特定主题的消息。</p>\n<figure style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><img src=\"https://user-gold-cdn.xitu.io/2019/12/11/16ef3837887d9a54?w=760&amp;h=341&amp;f=jpeg&amp;s=47404\" alt=\"\" title=\"\" style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;\"><figcaption style=\"line-height: inherit; margin: 0px; padding: 0px; margin-top: 10px; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;\"></figcaption></figure>\n<h3 id=\"hrocketmq-1\" style=\"color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px; font-weight: bold; font-size: 1.3em;\"><span style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\">RocketMQ中的消息模型</span></h3>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\"><code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RockerMQ</code> 中的消息模型就是按照 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">主题模型</strong> 所实现的。你可能会好奇这个 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">主题</strong> 到底是怎么实现的呢？你上面也没有讲到呀！</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">其实对于主题模型的实现来说每个消息中间件的底层设计都是不一样的，就比如 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Kafka</code> 中的 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">分区</strong> ，<code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 中的 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">队列</strong> ，<code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RabbitMQ</code> 中的 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Exchange</code> 。我们可以理解为 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">主题模型/发布订阅模型</strong> 就是一个标准，那些中间件只不过照着这个标准去实现而已。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">所以，<code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 中的 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">主题模型</strong> 到底是如何实现的呢？首先我画一张图，大家尝试着去理解一下。</p>\n<figure style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><img src=\"https://user-gold-cdn.xitu.io/2019/12/11/16ef383d3e8c9788?w=1391&amp;h=555&amp;f=jpeg&amp;s=116552\" alt=\"\" title=\"\" style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;\"><figcaption style=\"line-height: inherit; margin: 0px; padding: 0px; margin-top: 10px; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;\"></figcaption></figure>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">我们可以看到在整个图中有 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Producer Group</code> 、<code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Topic</code> 、<code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Consumer Group</code>  三个角色，我来分别介绍一下他们。</p>\n<ul style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px; padding-left: 32px; list-style-type: disc;\">\n<li style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px; margin-bottom: 0.5em;\"><code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Producer Group</code> 生产者组： 代表某一类的生产者，比如我们有多个秒杀系统作为生产者，这多个合在一起就是一个 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Producer Group</code> 生产者组，它们一般生产相同的消息。</li>\n<li style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px; margin-bottom: 0.5em;\"><code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Consumer Group</code> 消费者组： 代表某一类的消费者，比如我们有多个短信系统作为消费者，这多个合在一起就是一个 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Consumer Group</code> 消费者组，它们一般消费相同的消息。</li>\n<li style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px; margin-bottom: 0.5em;\"><code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Topic</code> 主题： 代表一类消息，比如订单消息，物流消息等等。</li>\n</ul>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">你可以看到图中生产者组中的生产者会向主题发送消息，而 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">主题中存在多个队列</strong>，生产者每次生产消息之后是指定主题中的某个队列发送消息的。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">每个主题中都有多个队列(这里还不涉及到 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code>)，集群消费模式下，一个消费者集群多台机器共同消费一个 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">topic</code> 的多个队列，<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">一个队列只会被一个消费者消费</strong>。如果某个消费者挂掉，分组内其它消费者会接替挂掉的消费者继续消费。就像上图中 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Consumer1</code> 和 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Consumer2</code> 分别对应着两个队列，而 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Consuer3</code> 是没有队列对应的，所以一般来讲要控制 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">消费者组中的消费者个数和主题中队列个数相同</strong> 。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">当然也可以消费者个数小于队列个数，只不过不太建议。如下图。</p>\n<figure style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><img src=\"https://user-gold-cdn.xitu.io/2019/12/11/16ef3850c808d707?w=910&amp;h=261&amp;f=jpeg&amp;s=43637\" alt=\"\" title=\"\" style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;\"><figcaption style=\"line-height: inherit; margin: 0px; padding: 0px; margin-top: 10px; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;\"></figcaption></figure>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\"><strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">每个消费组在每个队列上维护一个消费位置</strong> ，为什么呢？</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">因为我们刚刚画的仅仅是一个消费者组，我们知道在发布订阅模式中一般会涉及到多个消费者组，而每个消费者组在每个队列中的消费位置都是不同的。如果此时有多个消费者组，那么消息被一个消费者组消费完之后是不会删除的(因为其它消费者组也需要呀)，它仅仅是为每个消费者组维护一个 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">消费位移(offset)</strong> ，每次消费者组消费完会返回一个成功的响应，然后队列再把维护的消费位移加一，这样就不会出现刚刚消费过的消息再一次被消费了。</p>\n<figure style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><img src=\"https://user-gold-cdn.xitu.io/2019/12/11/16ef3857fefaa079?w=1251&amp;h=599&amp;f=jpeg&amp;s=130119\" alt=\"\" title=\"\" style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;\"><figcaption style=\"line-height: inherit; margin: 0px; padding: 0px; margin-top: 10px; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;\"></figcaption></figure>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">可能你还有一个问题，<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">为什么一个主题中需要维护多个队列</strong> ？</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">答案是 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">提高并发能力</strong> 。的确，每个主题中只存在一个队列也是可行的。你想一下，如果每个主题中只存在一个队列，这个队列中也维护着每个消费者组的消费位置，这样也可以做到 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">发布订阅模式</strong> 。如下图。</p>\n<figure style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><img src=\"https://user-gold-cdn.xitu.io/2019/12/11/16ef38600cdb6d4b?w=1271&amp;h=632&amp;f=jpeg&amp;s=128950\" alt=\"\" title=\"\" style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;\"><figcaption style=\"line-height: inherit; margin: 0px; padding: 0px; margin-top: 10px; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;\"></figcaption></figure>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">但是，这样我生产者是不是只能向一个队列发送消息？又因为需要维护消费位置所以一个队列只能对应一个消费者组中的消费者，这样是不是其他的 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Consumer</code> 就没有用武之地了？从这两个角度来讲，并发度一下子就小了很多。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">所以总结来说，<code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 通过<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">使用在一个 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Topic</code> 中配置多个队列并且每个队列维护每个消费者组的消费位置</strong> 实现了 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">主题模式/发布订阅模式</strong> 。</p>\n<h2 id=\"hrocketmq-2\" style=\"color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px; font-weight: bold; font-size: 1.5em; border-bottom: 2.2px solid rgb(255, 111, 0);\"><span style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; background: rgb(255, 111, 0); padding: 5px 15px; display: inline-block;\">RocketMQ的架构图</span></h2>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">讲完了消息模型，我们理解起 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 的技术架构起来就容易多了。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\"><code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 技术架构中有四大角色 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">NameServer</code> 、<code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 、<code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Producer</code> 、<code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Consumer</code> 。我来向大家分别解释一下这四个角色是干啥的。</p>\n<ul style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px; padding-left: 32px; list-style-type: disc;\">\n<li style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px; margin-bottom: 0.5em;\"><p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\"><code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code>： 主要负责消息的存储、投递和查询以及服务高可用保证。说白了就是消息队列服务器嘛，生产者生产消息到 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> ，消费者从 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 拉取消息并消费。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">这里，我还得普及一下关于 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 、<code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Topic</code> 和 队列的关系。上面我讲解了 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Topic</code> 和队列的关系——一个 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Topic</code> 中存在多个队列，那么这个 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Topic</code> 和队列存放在哪呢？</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\"><strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">一个 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Topic</code> 分布在多个 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code>上，一个 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 可以配置多个 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Topic</code> ，它们是多对多的关系</strong>。 </p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">如果某个 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Topic</code> 消息量很大，应该给它多配置几个队列(上文中提到了提高并发能力)，并且 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">尽量多分布在不同 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 上，以减轻某个 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 的压力</strong> 。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\"><code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Topic</code> 消息量都比较均匀的情况下，如果某个 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">broker</code> 上的队列越多，则该 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">broker</code> 压力越大。</p>\n<figure style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><img src=\"https://user-gold-cdn.xitu.io/2019/12/11/16ef38687488a5a4?w=936&amp;h=673&amp;f=jpeg&amp;s=93578\" alt=\"\" title=\"\" style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;\"><figcaption style=\"line-height: inherit; margin: 0px; padding: 0px; margin-top: 10px; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;\"></figcaption></figure></li>\n</ul>\n<blockquote style=\"line-height: inherit; display: block; padding: 15px 15px 15px 1rem; font-size: 1em; margin: 1em 0px; color: rgb(129, 145, 152); border-left: 8px solid rgb(255, 138, 101); background: rgb(224, 242, 241); overflow: auto; overflow-wrap: normal; word-break: normal; letter-spacing: 1.5px; font-family: YouYuan;\">\n  <p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 0px;\">所以说我们需要配置多个Broker。</p>\n</blockquote>\n<ul style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px; padding-left: 32px; list-style-type: disc;\">\n<li style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px; margin-bottom: 0.5em;\"><p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\"><code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">NameServer</code>： 不知道你们有没有接触过 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">ZooKeeper</code> 和 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Spring Cloud</code> 中的 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Eureka</code> ，它其实也是一个 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">注册中心</strong> ，主要提供两个功能：<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">Broker管理</strong> 和 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">路由信息管理</strong> 。说白了就是 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 会将自己的信息注册到 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">NameServer</code> 中，此时 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">NameServer</code> 就存放了很多 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 的信息(Broker的路由表)，消费者和生产者就从 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">NameServer</code> 中获取路由表然后照着路由表的信息和对应的 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 进行通信(生产者和消费者定期会向 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">NameServer</code> 去查询相关的 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 的信息)。</p></li>\n<li style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px; margin-bottom: 0.5em;\"><p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\"><code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Producer</code>： 消息发布的角色，支持分布式集群方式部署。说白了就是生产者。</p></li>\n<li style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px; margin-bottom: 0.5em;\"><p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\"><code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Consumer</code>： 消息消费的角色，支持分布式集群方式部署。支持以push推，pull拉两种模式对消息进行消费。同时也支持集群方式和广播方式的消费，它提供实时消息订阅机制。说白了就是消费者。</p></li>\n</ul>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">听完了上面的解释你可能会觉得，这玩意好简单。不就是这样的么？</p>\n<figure style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><img src=\"https://user-gold-cdn.xitu.io/2019/12/11/16ef386c6d1e8bdb?w=1237&amp;h=454&amp;f=jpeg&amp;s=93637\" alt=\"\" title=\"\" style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;\"><figcaption style=\"line-height: inherit; margin: 0px; padding: 0px; margin-top: 10px; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;\"></figcaption></figure>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">嗯？你可能会发现一个问题，这老家伙 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">NameServer</code> 干啥用的，这不多余吗？直接 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Producer</code> 、<code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Consumer</code> 和 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 直接进行生产消息，消费消息不就好了么？</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">但是，我们上文提到过 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 是需要保证高可用的，如果整个系统仅仅靠着一个 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 来维持的话，那么这个 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 的压力会不会很大？所以我们需要使用多个 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 来保证 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">负载均衡</strong> 。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">如果说，我们的消费者和生产者直接和多个 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 相连，那么当 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 修改的时候必定会牵连着每个生产者和消费者，这样就会产生耦合问题，而 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">NameServer</code> 注册中心就是用来解决这个问题的。</p>\n<blockquote style=\"line-height: inherit; display: block; padding: 15px 15px 15px 1rem; font-size: 1em; margin: 1em 0px; color: rgb(129, 145, 152); border-left: 8px solid rgb(255, 138, 101); background: rgb(224, 242, 241); overflow: auto; overflow-wrap: normal; word-break: normal; letter-spacing: 1.5px; font-family: YouYuan;\">\n  <p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 0px;\">如果还不是很理解的话，可以去看我介绍 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Spring Cloud</code> 的那篇文章，其中介绍了 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Eureka</code> 注册中心。</p>\n</blockquote>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">当然，<code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 中的技术架构肯定不止前面那么简单，因为上面图中的四个角色都是需要做集群的。我给出一张官网的架构图，大家尝试理解一下。</p>\n<figure style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><img src=\"https://user-gold-cdn.xitu.io/2019/12/11/16ef386fa3be1e53?w=1281&amp;h=522&amp;f=jpeg&amp;s=66376\" alt=\"\" title=\"\" style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;\"><figcaption style=\"line-height: inherit; margin: 0px; padding: 0px; margin-top: 10px; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;\"></figcaption></figure>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">其实和我们最开始画的那张乞丐版的架构图也没什么区别，主要是一些细节上的差别。听我细细道来🤨。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">第一、我们的 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">做了集群并且还进行了主从部署</strong> ，由于消息分布在各个 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 上，一旦某个 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 宕机，则该<code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 上的消息读写都会受到影响。所以 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Rocketmq</code> 提供了 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">master/slave</code> 的结构，<code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">salve</code> 定时从 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">master</code> 同步数据(同步刷盘或者异步刷盘)，如果 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">master</code> 宕机，<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">则 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">slave</code> 提供消费服务，但是不能写入消息</strong> (后面我还会提到哦)。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">第二、为了保证 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">HA</code> ，我们的 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">NameServer</code> 也做了集群部署，但是请注意它是 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">去中心化</strong> 的。也就意味着它没有主节点，你可以很明显地看出 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">NameServer</code> 的所有节点是没有进行 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Info Replicate</code> 的，在 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 中是通过 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">单个Broker和所有NameServer保持长连接</strong> ，并且在每隔30秒 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 会向所有 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Nameserver</code> 发送心跳，心跳包含了自身的 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Topic</code> 配置信息，这个步骤就对应这上面的 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Routing Info</code> 。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">第三、在生产者需要向 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 发送消息的时候，<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">需要先从 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">NameServer</code> 获取关于 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 的路由信息</strong>，然后通过 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">轮询</strong> 的方法去向每个队列中生产数据以达到 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">负载均衡</strong> 的效果。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">第四、消费者通过 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">NameServer</code> 获取所有 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 的路由信息后，向 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 发送 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Pull</code> 请求来获取消息数据。<code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Consumer</code> 可以以两种模式启动—— <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">广播（Broadcast）和集群（Cluster）</strong>。广播模式下，一条消息会发送给 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">同一个消费组中的所有消费者</strong> ，集群模式下消息只会发送给一个消费者。</p>\n<h2 id=\"h-12\" style=\"color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px; font-weight: bold; font-size: 1.5em; border-bottom: 2.2px solid rgb(255, 111, 0);\"><span style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; background: rgb(255, 111, 0); padding: 5px 15px; display: inline-block;\">如何解决 顺序消费、重复消费</span></h2>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">其实，这些东西都是我在介绍消息队列带来的一些副作用的时候提到的，也就是说，这些问题不仅仅挂钩于 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> ，而是应该每个消息中间件都需要去解决的。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">在上面我介绍 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 的技术架构的时候我已经向你展示了 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">它是如何保证高可用的</strong> ，这里不涉及运维方面的搭建，如果你感兴趣可以自己去官网上照着例子搭建属于你自己的 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 集群。</p>\n<blockquote style=\"line-height: inherit; display: block; padding: 15px 15px 15px 1rem; font-size: 1em; margin: 1em 0px; color: rgb(129, 145, 152); border-left: 8px solid rgb(255, 138, 101); background: rgb(224, 242, 241); overflow: auto; overflow-wrap: normal; word-break: normal; letter-spacing: 1.5px; font-family: YouYuan;\">\n  <p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 0px;\">其实 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Kafka</code> 的架构基本和 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 类似，只是它注册中心使用了 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Zookeeper</code> 、它的 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">分区</strong> 就相当于 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 中的 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">队列</strong> 。还有一些小细节不同会在后面提到。</p>\n</blockquote>\n<h3 id=\"h-13\" style=\"color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px; font-weight: bold; font-size: 1.3em;\"><span style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\">顺序消费</span></h3>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">在上面的技术架构介绍中，我们已经知道了 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\"><code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 在主题上是无序的、它只有在队列层面才是保证有序</strong> 的。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">这又扯到两个概念——<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">普通顺序</strong> 和 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">严格顺序</strong> 。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">所谓普通顺序是指 消费者通过 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">同一个消费队列收到的消息是有顺序的</strong> ，不同消息队列收到的消息则可能是无顺序的。普通顺序消息在 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">重启情况下不会保证消息顺序性</strong> (短暂时间) 。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">所谓严格顺序是指  消费者收到的 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">所有消息</strong> 均是有顺序的。严格顺序消息 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">即使在异常情况下也会保证消息的顺序性</strong> 。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">但是，严格顺序看起来虽好，实现它可会付出巨大的代价。如果你使用严格顺序模式，<code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 集群中只要有一台机器不可用，则整个集群都不可用。你还用啥？现在主要场景也就在 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">binlog</code> 同步。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">一般而言，我们的 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">MQ</code> 都是能容忍短暂的乱序，所以推荐使用普通顺序模式。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">那么，我们现在使用了 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">普通顺序模式</strong> ，我们从上面学习知道了在 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Producer</code> 生产消息的时候会进行轮询(取决你的负载均衡策略)来向同一主题的不同消息队列发送消息。那么如果此时我有几个消息分别是同一个订单的创建、支付、发货，在轮询的策略下这 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">三个消息会被发送到不同队列</strong> ，因为在不同的队列此时就无法使用 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 带来的队列有序特性来保证消息有序性了。</p>\n<figure style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><img src=\"https://user-gold-cdn.xitu.io/2019/12/11/16ef3874585e096e?w=1258&amp;h=484&amp;f=jpeg&amp;s=90329\" alt=\"\" title=\"\" style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;\"><figcaption style=\"line-height: inherit; margin: 0px; padding: 0px; margin-top: 10px; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;\"></figcaption></figure>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">那么，怎么解决呢？</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">其实很简单，我们需要处理的仅仅是将同一语义下的消息放入同一个队列(比如这里是同一个订单)，那我们就可以使用 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">Hash取模法</strong> 来保证同一个订单在同一个队列中就行了。</p>\n<h3 id=\"h-14\" style=\"color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px; font-weight: bold; font-size: 1.3em;\"><span style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\">重复消费</span></h3>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">emmm，就两个字—— <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">幂等</strong> 。在编程中一个<em style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px; font-style: italic;\">幂等</em> 操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。比如说，这个时候我们有一个订单的处理积分的系统，每当来一个消息的时候它就负责为创建这个订单的用户的积分加上相应的数值。可是有一次，消息队列发送给订单系统 FrancisQ 的订单信息，其要求是给 FrancisQ 的积分加上 500。但是积分系统在收到 FrancisQ 的订单信息处理完成之后返回给消息队列处理成功的信息的时候出现了网络波动(当然还有很多种情况，比如Broker意外重启等等)，这条回应没有发送成功。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">那么，消息队列没收到积分系统的回应会不会尝试重发这个消息？问题就来了，我再发这个消息，万一它又给 FrancisQ 的账户加上 500 积分怎么办呢？</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">所以我们需要给我们的消费者实现 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">幂等</strong> ，也就是对同一个消息的处理结果，执行多少次都不变。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">那么如何给业务实现幂等呢？这个还是需要结合具体的业务的。你可以使用 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">写入 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Redis</code></strong> 来保证，因为 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Redis</code> 的 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">key</code> 和 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">value</code> 就是天然支持幂等的。当然还有使用 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">数据库插入法</strong> ，基于数据库的唯一键来保证重复数据不会被插入多条。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">不过最主要的还是需要 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">根据特定场景使用特定的解决方案</strong> ，你要知道你的消息消费是否是完全不可重复消费还是可以忍受重复消费的，然后再选择强校验和弱校验的方式。毕竟在 CS 领域还是很少有技术银弹的说法。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">而在整个互联网领域，幂等不仅仅适用于消息队列的重复消费问题，这些实现幂等的方法，也同样适用于，<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">在其他场景中来解决重复请求或者重复调用的问题</strong> 。比如将HTTP服务设计成幂等的，<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">解决前端或者APP重复提交表单数据的问题</strong> ，也可以将一个微服务设计成幂等的，解决 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RPC</code> 框架自动重试导致的 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">重复调用问题</strong> 。</p>\n<h2 id=\"h-15\" style=\"color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px; font-weight: bold; font-size: 1.5em; border-bottom: 2.2px solid rgb(255, 111, 0);\"><span style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; background: rgb(255, 111, 0); padding: 5px 15px; display: inline-block;\">分布式事务</span></h2>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">如何解释分布式事务呢？事务大家都知道吧？<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">要么都执行要么都不执行</strong> 。在同一个系统中我们可以轻松地实现事务，但是在分布式架构中，我们有很多服务是部署在不同系统之间的，而不同服务之间又需要进行调用。比如此时我下订单然后增加积分，如果保证不了分布式事务的话，就会出现A系统下了订单，但是B系统增加积分失败或者A系统没有下订单，B系统却增加了积分。前者对用户不友好，后者对运营商不利，这是我们都不愿意见到的。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">那么，如何去解决这个问题呢？</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">如今比较常见的分布式事务实现有 2PC、TCC 和事务消息(half 半消息机制)。每一种实现都有其特定的使用场景，但是也有各自的问题，<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">都不是完美的解决方案</strong>。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">在 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 中使用的是 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">事务消息加上事务反查机制</strong> 来解决分布式事务问题的。我画了张图，大家可以对照着图进行理解。</p>\n<figure style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><img src=\"https://user-gold-cdn.xitu.io/2019/12/11/16ef38798d7a987f?w=1355&amp;h=360&amp;f=jpeg&amp;s=107566\" alt=\"\" title=\"\" style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;\"><figcaption style=\"line-height: inherit; margin: 0px; padding: 0px; margin-top: 10px; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;\"></figcaption></figure>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">在第一步发送的 half 消息 ，它的意思是 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">在事务提交之前，对于消费者来说，这个消息是不可见的</strong> 。</p>\n<blockquote style=\"line-height: inherit; display: block; padding: 15px 15px 15px 1rem; font-size: 1em; margin: 1em 0px; color: rgb(129, 145, 152); border-left: 8px solid rgb(255, 138, 101); background: rgb(224, 242, 241); overflow: auto; overflow-wrap: normal; word-break: normal; letter-spacing: 1.5px; font-family: YouYuan;\">\n  <p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 0px;\">那么，如何做到写入消息但是对用户不可见呢？RocketMQ事务消息的做法是：如果消息是half消息，将备份原消息的主题与消息消费队列，然后 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">改变主题</strong> 为RMQ_SYS_TRANS_HALF_TOPIC。由于消费组未订阅该主题，故消费端无法消费half类型的消息，<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">然后RocketMQ会开启一个定时任务，从Topic为RMQ_SYS_TRANS_HALF_TOPIC中拉取消息进行消费</strong>，根据生产者组获取一个服务提供者发送回查事务状态请求，根据事务状态来决定是提交或回滚消息。</p>\n</blockquote>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">你可以试想一下，如果没有从第5步开始的 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">事务反查机制</strong> ，如果出现网路波动第4步没有发送成功，这样就会产生 MQ 不知道是不是需要给消费者消费的问题，他就像一个无头苍蝇一样。在 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 中就是使用的上述的事务反查来解决的，而在 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Kafka</code> 中通常是直接抛出一个异常让用户来自行解决。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">你还需要注意的是，在 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">MQ Server</code> 指向系统B的操作已经和系统A不相关了，也就是说在消息队列中的分布式事务是——<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">本地事务和存储消息到消息队列才是同一个事务</strong>。这样也就产生了事务的<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">最终一致性</strong>，因为整个过程是异步的，<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">每个系统只要保证它自己那一部分的事务就行了</strong>。</p>\n<h2 id=\"h-16\" style=\"color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px; font-weight: bold; font-size: 1.5em; border-bottom: 2.2px solid rgb(255, 111, 0);\"><span style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; background: rgb(255, 111, 0); padding: 5px 15px; display: inline-block;\">消息堆积问题</span></h2>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">在上面我们提到了消息队列一个很重要的功能——<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">削峰</strong> 。那么如果这个峰值太大了导致消息堆积在队列中怎么办呢？</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">其实这个问题可以将它广义化，因为产生消息堆积的根源其实就只有两个——生产者生产太快或者消费者消费太慢。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">我们可以从多个角度去思考解决这个问题，当流量到峰值的时候是因为生产者生产太快，我们可以使用一些 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">限流降级</strong> 的方法，当然你也可以增加多个消费者实例去水平扩展增加消费能力来匹配生产的激增。如果消费者消费过慢的话，我们可以先检查 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">是否是消费者出现了大量的消费错误</strong> ，或者打印一下日志查看是否是哪一个线程卡死，出现了锁资源不释放等等的问题。</p>\n<blockquote style=\"line-height: inherit; display: block; padding: 15px 15px 15px 1rem; font-size: 1em; margin: 1em 0px; color: rgb(129, 145, 152); border-left: 8px solid rgb(255, 138, 101); background: rgb(224, 242, 241); overflow: auto; overflow-wrap: normal; word-break: normal; letter-spacing: 1.5px; font-family: YouYuan;\">\n  <p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 0px;\">当然，最快速解决消息堆积问题的方法还是增加消费者实例，不过 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">同时你还需要增加每个主题的队列数量</strong> 。</p>\n  <p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 0px;\">别忘了在 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 中，<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">一个队列只会被一个消费者消费</strong> ，如果你仅仅是增加消费者实例就会出现我一开始给你画架构图的那种情况。</p>\n</blockquote>\n<figure style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><img src=\"https://user-gold-cdn.xitu.io/2019/12/11/16ef387d939ab66d?w=1391&amp;h=555&amp;f=jpeg&amp;s=116552\" alt=\"\" title=\"\" style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;\"><figcaption style=\"line-height: inherit; margin: 0px; padding: 0px; margin-top: 10px; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;\"></figcaption></figure>\n<h2 id=\"h-17\" style=\"color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px; font-weight: bold; font-size: 1.5em; border-bottom: 2.2px solid rgb(255, 111, 0);\"><span style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; background: rgb(255, 111, 0); padding: 5px 15px; display: inline-block;\">回溯消费</span></h2>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">回溯消费是指 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Consumer</code> 已经消费成功的消息，由于业务上需求需要重新消费，在<code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 中， <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 在向<code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Consumer</code> 投递成功消息后，<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">消息仍然需要保留</strong> 。并且重新消费一般是按照时间维度，例如由于 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Consumer</code> 系统故障，恢复后需要重新消费1小时前的数据，那么 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 要提供一种机制，可以按照时间维度来回退消费进度。<code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 支持按照时间回溯消费，时间维度精确到毫秒。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">这是官方文档的解释，我直接照搬过来就当科普了😁😁😁。</p>\n<h2 id=\"hrocketmq-3\" style=\"color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px; font-weight: bold; font-size: 1.5em; border-bottom: 2.2px solid rgb(255, 111, 0);\"><span style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; background: rgb(255, 111, 0); padding: 5px 15px; display: inline-block;\">RocketMQ 的刷盘机制</span></h2>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">上面我讲了那么多的 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 的架构和设计原理，你有没有好奇</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">在 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Topic</code> 中的 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">队列是以什么样的形式存在的？</strong></p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\"><strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">队列中的消息又是如何进行存储持久化的呢？</strong></p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">我在上文中提到的 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">同步刷盘</strong> 和 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">异步刷盘</strong> 又是什么呢？它们会给持久化带来什么样的影响呢？</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">下面我将给你们一一解释。</p>\n<h3 id=\"h-18\" style=\"color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px; font-weight: bold; font-size: 1.3em;\"><span style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\">同步刷盘和异步刷盘</span></h3>\n<figure style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><img src=\"https://user-gold-cdn.xitu.io/2019/12/11/16ef387fba311cda?w=1101&amp;h=874&amp;f=jpeg&amp;s=101763\" alt=\"\" title=\"\" style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;\"><figcaption style=\"line-height: inherit; margin: 0px; padding: 0px; margin-top: 10px; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;\"></figcaption></figure>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">如上图所示，在同步刷盘中需要等待一个刷盘成功的 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">ACK</code> ，同步刷盘对 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">MQ</code> 消息可靠性来说是一种不错的保障，但是 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">性能上会有较大影响</strong> ，一般地适用于金融等特定业务场景。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">而异步刷盘往往是开启一个线程去异步地执行刷盘操作。消息刷盘采用后台异步线程提交的方式进行， <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">降低了读写延迟</strong> ，提高了 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">MQ</code> 的性能和吞吐量，一般适用于如发验证码等对于消息保证要求不太高的业务场景。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">一般地，<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">异步刷盘只有在 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 意外宕机的时候会丢失部分数据</strong>，你可以设置 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 的参数 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">FlushDiskType</code> 来调整你的刷盘策略(ASYNC_FLUSH 或者 SYNC_FLUSH)。</p>\n<h3 id=\"h-19\" style=\"color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px; font-weight: bold; font-size: 1.3em;\"><span style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\">同步复制和异步复制</span></h3>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">上面的同步刷盘和异步刷盘是在单个结点层面的，而同步复制和异步复制主要是指的 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Borker</code> 主从模式下，主节点返回消息给客户端的时候是否需要同步从节点。</p>\n<ul style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px; padding-left: 32px; list-style-type: disc;\">\n<li style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px; margin-bottom: 0.5em;\">同步复制： 也叫 “同步双写”，也就是说，<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">只有消息同步双写到主从结点上时才返回写入成功</strong> 。</li>\n<li style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px; margin-bottom: 0.5em;\">异步复制： <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">消息写入主节点之后就直接返回写入成功</strong> 。</li>\n</ul>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">然而，很多事情是没有完美的方案的，就比如我们进行消息写入的节点越多就更能保证消息的可靠性，但是随之的性能也会下降，所以需要程序员根据特定业务场景去选择适应的主从复制方案。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">那么，<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">异步复制会不会也像异步刷盘那样影响消息的可靠性呢？</strong></p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">答案是不会的，因为两者就是不同的概念，对于消息可靠性是通过不同的刷盘策略保证的，而像异步同步复制策略仅仅是影响到了 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">可用性</strong> 。为什么呢？其主要原因<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">是 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 是不支持自动主从切换的，当主节点挂掉之后，生产者就不能再给这个主节点生产消息了</strong>。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">比如这个时候采用异步复制的方式，在主节点还未发送完需要同步的消息的时候主节点挂掉了，这个时候从节点就少了一部分消息。但是此时生产者无法再给主节点生产消息了，<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">消费者可以自动切换到从节点进行消费</strong>(仅仅是消费)，所以在主节点挂掉的时间只会产生主从结点短暂的消息不一致的情况，降低了可用性，而当主节点重启之后，从节点那部分未来得及复制的消息还会继续复制。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">在单主从架构中，如果一个主节点挂掉了，那么也就意味着整个系统不能再生产了。那么这个可用性的问题能否解决呢？<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">一个主从不行那就多个主从的呗</strong>，别忘了在我们最初的架构图中，每个 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Topic</code> 是分布在不同 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 中的。</p>\n<figure style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><img src=\"https://user-gold-cdn.xitu.io/2019/12/11/16ef38823b165817?w=936&amp;h=673&amp;f=jpeg&amp;s=93578\" alt=\"\" title=\"\" style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;\"><figcaption style=\"line-height: inherit; margin: 0px; padding: 0px; margin-top: 10px; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;\"></figcaption></figure>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">但是这种复制方式同样也会带来一个问题，那就是无法保证 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">严格顺序</strong> 。在上文中我们提到了如何保证的消息顺序性是通过将一个语义的消息发送在同一个队列中，使用 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Topic</code> 下的队列来保证顺序性的。如果此时我们主节点A负责的是订单A的一系列语义消息，然后它挂了，这样其他节点是无法代替主节点A的，如果我们任意节点都可以存入任何消息，那就没有顺序性可言了。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">而在 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 中采用了 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Dledger</code> 解决这个问题。他要求在写入消息的时候，要求<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">至少消息复制到半数以上的节点之后</strong>，才给客⼾端返回写⼊成功，并且它是⽀持通过选举来动态切换主节点的。这里我就不展开说明了，读者可以自己去了解。</p>\n<blockquote style=\"line-height: inherit; display: block; padding: 15px 15px 15px 1rem; font-size: 1em; margin: 1em 0px; color: rgb(129, 145, 152); border-left: 8px solid rgb(255, 138, 101); background: rgb(224, 242, 241); overflow: auto; overflow-wrap: normal; word-break: normal; letter-spacing: 1.5px; font-family: YouYuan;\">\n  <p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 0px;\">也不是说 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Dledger</code> 是个完美的方案，至少在 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Dledger</code> 选举过程中是无法提供服务的，而且他必须要使用三个节点或以上，如果多数节点同时挂掉他也是无法保证可用性的，而且要求消息复制板书以上节点的效率和直接异步复制还是有一定的差距的。</p>\n</blockquote>\n<h3 id=\"h-20\" style=\"color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px; font-weight: bold; font-size: 1.3em;\"><span style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\">存储机制</span></h3>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">还记得上面我们一开始的三个问题吗？到这里第三个问题已经解决了。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">但是，在 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Topic</code> 中的 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">队列是以什么样的形式存在的？队列中的消息又是如何进行存储持久化的呢？</strong> 还未解决，其实这里涉及到了 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 是如何设计它的存储结构了。我首先想大家介绍 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 消息存储架构中的三大角色——<code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">CommitLog</code> 、<code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">ConsumeQueue</code> 和 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">IndexFile</code> 。</p>\n<ul style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px; padding-left: 32px; list-style-type: disc;\">\n<li style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px; margin-bottom: 0.5em;\"><code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">CommitLog</code>： <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">消息主体以及元数据的存储主体</strong>，存储 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Producer</code> 端写入的消息主体内容,消息内容不是定长的。单个文件大小默认1G ，文件名长度为20位，左边补零，剩余为起始偏移量，比如00000000000000000000代表了第一个文件，起始偏移量为0，文件大小为1G=1073741824；当第一个文件写满了，第二个文件为00000000001073741824，起始偏移量为1073741824，以此类推。消息主要是<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">顺序写入日志文件</strong>，当文件满了，写入下一个文件。</li>\n<li style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px; margin-bottom: 0.5em;\"><code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">ConsumeQueue</code>： 消息消费队列，<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">引入的目的主要是提高消息消费的性能</strong>(我们再前面也讲了)，由于<code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 是基于主题 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Topic</code> 的订阅模式，消息消费是针对主题进行的，如果要遍历 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">commitlog</code> 文件中根据 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Topic</code> 检索消息是非常低效的。<code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Consumer</code> 即可根据 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">ConsumeQueue</code> 来查找待消费的消息。其中，<code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">ConsumeQueue</code>（逻辑消费队列）<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">作为消费消息的索引</strong>，保存了指定 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Topic</code> 下的队列消息在 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">CommitLog</code> 中的 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">起始物理偏移量</strong> <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">offset</code>，<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">消息大小</strong><code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">size</code> 和消息 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Tag</code> 的 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">HashCode</code> 值。<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">consumequeue文件</strong> 可以看成是基于topic的 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">commitlog索引文件</strong> ，故 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">consumequeue</code> 文件夹的组织方式如下：topic/queue/file三层组织结构，具体存储路径为：$HOME/store/consumequeue/{topic}/{queueId}/{fileName}。同样 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">consumequeue</code> 文件采取定长设计，每一个条目共20个字节，分别为8字节的 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">commitlog</code> 物理偏移量、4字节的消息长度、8字节tag <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">hashcode</code>，单个文件由30W个条目组成，可以像数组一样随机访问每一个条目，每个 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">ConsumeQueue</code>文件大小约5.72M；</li>\n<li style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px; margin-bottom: 0.5em;\"><code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">IndexFile</code>： <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">IndexFile</code>（索引文件）提供了一种可以通过key或时间区间来查询消息的方法。这里只做科普不做详细介绍。</li>\n</ul>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">总结来说，整个消息存储的结构，最主要的就是 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">CommitLoq</code> 和 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">ConsumeQueue</code> 。而 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">ConsumeQueue</code> 你可以大概理解为 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Topic</code> 中的队列。</p>\n<figure style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><img src=\"https://user-gold-cdn.xitu.io/2019/12/11/16ef3884c02acc72?w=745&amp;h=341&amp;f=jpeg&amp;s=51683\" alt=\"\" title=\"\" style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;\"><figcaption style=\"line-height: inherit; margin: 0px; padding: 0px; margin-top: 10px; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;\"></figcaption></figure>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\"><code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 采用的是 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">混合型的存储结构</strong> ，即为 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 单个实例下所有的队列共用一个日志数据文件来存储消息。有意思的是在同样高并发的 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Kafka</code> 中会为每个 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Topic</code> 分配一个存储文件。这就有点类似于我们有一大堆书需要装上书架，<code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RockeMQ</code> 是不分书的种类直接成批的塞上去的，而 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Kafka</code> 是将书本放入指定的分类区域的。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">而 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 为什么要这么做呢？原因是 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">提高数据的写入效率</strong> ，不分 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Topic</code> 意味着我们有更大的几率获取 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">成批</strong> 的消息进行数据写入，但也会带来一个麻烦就是读取消息的时候需要遍历整个大文件，这是非常耗时的。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">所以，在 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 中又使用了 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">ConsumeQueue</code> 作为每个队列的索引文件来 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">提升读取消息的效率</strong>。我们可以直接根据队列的消息序号，计算出索引的全局位置（索引序号*索引固定⻓度20），然后直接读取这条索引，再根据索引中记录的消息的全局位置，找到消息。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">讲到这里，你可能对 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RockeMQ</code> 的存储架构还有些模糊，没事，我们结合着图来理解一下。</p>\n<figure style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><img src=\"https://user-gold-cdn.xitu.io/2019/12/11/16ef388763c25c62?w=1142&amp;h=896&amp;f=png&amp;s=111170\" alt=\"\" title=\"\" style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;\"><figcaption style=\"line-height: inherit; margin: 0px; padding: 0px; margin-top: 10px; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;\"></figcaption></figure>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">emmm，是不是有一点复杂🤣，看英文图片和英文文档的时候就不要怂，硬着头皮往下看就行。</p>\n<blockquote style=\"line-height: inherit; display: block; padding: 15px 15px 15px 1rem; font-size: 1em; margin: 1em 0px; color: rgb(129, 145, 152); border-left: 8px solid rgb(255, 138, 101); background: rgb(224, 242, 241); overflow: auto; overflow-wrap: normal; word-break: normal; letter-spacing: 1.5px; font-family: YouYuan;\">\n  <p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 0px;\">如果上面没看懂的读者一定要认真看下面的流程分析！</p>\n</blockquote>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">首先，在最上面的那一块就是我刚刚讲的你现在可以直接 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">把 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">ConsumerQueue</code> 理解为 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Queue</code></strong>。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">在图中最左边说明了 <font color=\"red\" style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\">红色方块 </font> 代表被写入的消息，虚线方块代表等待被写入的。左边的生产者发送消息会指定 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Topic</code> 、<code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">QueueId</code> 和具体消息内容，而在 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 中管你是哪门子消息，他直接 **全部顺序存储到了 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">CommitLog</code> **。而根据生产者指定的 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Topic</code> 和 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">QueueId</code> 将这条消息本身在 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">CommitLog</code> 的偏移(offset)，消息本身大小，和tag的hash值存入对应的 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">ConsumeQueue</code> 索引文件中。而在每个队列中都保存了 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">ConsumeOffset</code> 即每个消费者组的消费位置(我在架构那里提到了，忘了的同学可以回去看一下)，而消费者拉取消息进行消费的时候只需要根据 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">ConsumeOffset</code> 获取下一个未被消费的消息就行了。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">上述就是我对于整个消息存储架构的大概理解(这里不涉及到一些细节讨论，比如稀疏索引等等问题)，希望对你有帮助。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">因为有一个知识点因为写嗨了忘讲了，想想在哪里加也不好，所以我留给大家去思考🤔🤔一下吧。</p>\n<figure style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><img src=\"https://user-gold-cdn.xitu.io/2019/12/11/16ef38894e8ff697?w=255&amp;h=255&amp;f=jpeg&amp;s=8769\" alt=\"\" title=\"\" style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;\"><figcaption style=\"line-height: inherit; margin: 0px; padding: 0px; margin-top: 10px; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;\"></figcaption></figure>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">为什么 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">CommitLog</code> 文件要设计成固定大小的长度呢？提醒：<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">内存映射机制</strong>。</p>\n<h2 id=\"h-21\" style=\"color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px; font-weight: bold; font-size: 1.5em; border-bottom: 2.2px solid rgb(255, 111, 0);\"><span style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; background: rgb(255, 111, 0); padding: 5px 15px; display: inline-block;\">总结</span></h2>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">总算把这篇博客写完了。我讲的你们还记得吗😅？</p>\n<figure style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><img src=\"https://user-gold-cdn.xitu.io/2019/12/11/16ef388ad16144f1?w=255&amp;h=255&amp;f=jpeg&amp;s=10422\" alt=\"\" title=\"\" style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;\"><figcaption style=\"line-height: inherit; margin: 0px; padding: 0px; margin-top: 10px; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;\"></figcaption></figure>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">这篇文章中我主要想大家介绍了</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">消息队列出现的原因</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">消息队列的作用(异步，解耦，削峰)</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">消息队列带来的一系列问题(消息堆积、重复消费、顺序消费、分布式事务等等)</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">消息队列的两种消息模型——队列和主题模式</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">分析了 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 的技术架构(<code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">NameServer</code> 、<code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 、<code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Producer</code> 、<code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Comsumer</code>)</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">结合着 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 回答了消息队列副作用的解决方案</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">介绍了 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 的存储机制和刷盘策略。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">等等。。。</p>\n<blockquote style=\"line-height: inherit; display: block; padding: 15px 15px 15px 1rem; font-size: 1em; margin: 1em 0px; color: rgb(129, 145, 152); border-left: 8px solid rgb(255, 138, 101); background: rgb(224, 242, 241); overflow: auto; overflow-wrap: normal; word-break: normal; letter-spacing: 1.5px; font-family: YouYuan;\">\n  <p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 0px;\">如果喜欢可以点赞哟👍👍👍。</p>\n</blockquote></div>","blogCover":"http://img.francisqiang.top/1577679519","blogId":3,"blogTitle":"👉冒着挂科的风险也要给你看的消息队列和RocketMQ入门总结"}
2019-12-30 12:18:46.101 [http-nio-8080-exec-5] INFO  com.lgq.controller.BlogController - FrancisBlog: getBlogList:1
2019-12-30 12:18:53.241 [http-nio-8080-exec-2] INFO  com.lgq.controller.TagController - FrancisBlog: getAllTag
2019-12-30 12:20:00.334 [http-nio-8080-exec-8] INFO  com.lgq.controller.TagController - FrancisBlog: addTag -> {"tagAlias":"消息队列","tagColor":"rgba(0, 186, 189, 0.58)","tagDescription":"阿里巴巴消息队列","tagName":"RocketMQ"}
2019-12-30 12:20:00.830 [http-nio-8080-exec-9] INFO  com.lgq.controller.TagController - FrancisBlog: getAllTag
2019-12-30 12:20:27.591 [http-nio-8080-exec-1] INFO  com.lgq.controller.TagController - FrancisBlog: addTag -> {"tagAlias":"消息队列","tagColor":"rgba(255, 120, 0, 0.43)","tagDescription":"服务调用","tagName":"消息队列"}
2019-12-30 12:20:27.838 [http-nio-8080-exec-4] INFO  com.lgq.controller.TagController - FrancisBlog: getAllTag
2019-12-30 12:20:32.473 [http-nio-8080-exec-7] INFO  com.lgq.controller.BlogController - FrancisBlog: getBlogList:1
2019-12-30 12:20:34.169 [http-nio-8080-exec-6] INFO  com.lgq.controller.TokenController - FrancisBlog: getToken
2019-12-30 12:20:34.179 [http-nio-8080-exec-3] INFO  com.lgq.controller.CategoryController - FrancisBlog: getAllCategory
2019-12-30 12:20:34.179 [http-nio-8080-exec-10] INFO  com.lgq.controller.BlogController - FrancisBlog: getBlogById: blog_id:3
2019-12-30 12:20:34.189 [http-nio-8080-exec-5] INFO  com.lgq.controller.TagController - FrancisBlog: getAllTag
2019-12-30 12:20:34.190 [http-nio-8080-exec-10] INFO  com.lgq.service.impl.BlogServiceImpl - null
2019-12-30 12:20:34.347 [http-nio-8080-exec-10] INFO  com.lgq.service.impl.BlogServiceImpl - 14
2019-12-30 12:21:10.605 [http-nio-8080-exec-2] INFO  com.lgq.controller.BlogController - FrancisBlog: updateBlogById -> {"blogCategoryId":1,"blogContent":"<div class=\"output_wrapper\" id=\"output_wrapper_id\" style=\"font-size: 16px; color: rgb(62, 62, 62); line-height: 1.7; word-spacing: 0px; letter-spacing: 0px; font-family: 'Helvetica Neue', Helvetica, 'Hiragino Sans GB', 'Microsoft YaHei', Arial, sans-serif; background-image: linear-gradient(90deg, rgba(50, 0, 0, 0.05) 3%, rgba(0, 0, 0, 0) 3%), linear-gradient(360deg, rgba(50, 0, 0, 0.05) 3%, rgba(0, 0, 0, 0) 3%); background-size: 20px 20px; background-position: center center;\"><h2 id=\"h\" style=\"color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px; font-weight: bold; font-size: 1.5em; border-bottom: 2.2px solid rgb(255, 111, 0);\"><span style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; background: rgb(255, 111, 0); padding: 5px 15px; display: inline-block;\">吐槽</span></h2>\n<blockquote style=\"line-height: inherit; display: block; padding: 15px 15px 15px 1rem; font-size: 1em; margin: 1em 0px; color: rgb(129, 145, 152); border-left: 8px solid rgb(255, 138, 101); background: rgb(224, 242, 241); overflow: auto; overflow-wrap: normal; word-break: normal; letter-spacing: 1.5px; font-family: YouYuan;\">\n  <p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 0px;\">文章很长，点赞再看，养成好习惯😋😋😋</p>\n</blockquote>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">这真的是考前的最后一篇博客，再写真的要挂科了。</p>\n<figure style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><img src=\"https://user-gold-cdn.xitu.io/2019/12/11/16ef37eaae5f8d42?w=255&amp;h=255&amp;f=jpeg&amp;s=11940\" alt=\"\" title=\"\" style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;\"><figcaption style=\"line-height: inherit; margin: 0px; padding: 0px; margin-top: 10px; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;\"></figcaption></figure>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">其实一直想吐槽现在很多大学的计算机教育的，我从大二开始入门 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Java</code>后端，其实我觉得我的学习效率很低，中间也走了很多歪路。但是，如今和同龄人比较，我发现大部分同学竟然连基本的代码都不会敲，尤其到了课程设计大家都是水水过的，让他们做一个管理系统简直要他们命。包括现在大三了，很多人希望本科就出来就业的开始报培训班，培机构开始大把大把地捞金，学生在那疯狂吐槽三四年里没有从学校学到任何东西，这可能是大部分大学计算机教育的通病吧。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">当然还有很多师资力量的问题，不知道清北的，但在我认识的一些 211 或者某些 985 的同学，他们学校的老师或者所教的一些知识也已经落伍了好多年了(当然不是指一些操作系统类似的基础学科，我觉得它们是几十年都不变的)。如果一个数据库老师会告诉你 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">MySQL</code> 不支持事务，一个数据结构老师说 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">B+树</code> 是二叉树，甚至在学生提到一些新的东西的时候没有了解过并且不想去了解，你们会怎么想。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">但很庆幸，在大二的时候加入了我们学校最牛的技术组织 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">TECH F5VE</code> ，这是一个学生组织的创业型技术团队，成立五年目前成员四十人不到，但里面不乏各种大厂的大牛，我在里面获得了很多很多。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">当然，参加过一些小公司的实习或者和他们合作过做一些外包项目，但发现他们的技术选型也已经 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">out</code> 了，我们团队的成员戏称 \"考古式开发\"。我想这也是大部分人挤破了头皮想要进大厂的理由吧。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">可能观点有点偏激，希望大家理解🤐🤐🤐。</p>\n<h2 id=\"h-1\" style=\"color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px; font-weight: bold; font-size: 1.5em; border-bottom: 2.2px solid rgb(255, 111, 0);\"><span style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; background: rgb(255, 111, 0); padding: 5px 15px; display: inline-block;\">消息队列扫盲</span></h2>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">消息队列顾名思义就是存放消息的队列，队列我就不解释了，别告诉我你连队列都不知道似啥吧？</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">所以问题并不是消息队列是什么，而是 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">消息队列为什么会出现？消息队列能用来干什么？用它来干这些事会带来什么好处？消息队列会带来副作用吗？</strong></p>\n<h3 id=\"h-2\" style=\"color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px; font-weight: bold; font-size: 1.3em;\"><span style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\">消息队列为什么会出现？</span></h3>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">消息队列算是作为后端程序员的一个必备技能吧，因为<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">分布式应用必定涉及到各个系统之间的通信问题</strong>，这个时候消息队列也应运而生了。可以说分布式的产生是消息队列的基础，而分布式怕是一个很古老的概念了吧，所以消息队列也是一个很古老的中间件了。</p>\n<h3 id=\"h-3\" style=\"color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px; font-weight: bold; font-size: 1.3em;\"><span style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\">消息队列能用来干什么？</span></h3>\n<h4 id=\"h-4\" style=\"color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px; font-weight: bold; font-size: 1.2em;\"><span style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\">异步</span></h4>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">你可能会反驳我，应用之间的通信又不是只能由消息队列解决，好好的通信为什么中间非要插一个消息队列呢？我不能直接进行通信吗？</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">很好👍，你又提出了一个概念，<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">同步通信</strong>。就比如现在业界使用比较多的 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Dubbo</code> 就是一个适用于各个系统之间同步通信的 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RPC</code> 框架。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">我来举个🌰吧，比如我们有一个购票系统，需求是用户在购买完之后能接收到购买完成的短信。</p>\n<figure style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><img src=\"https://user-gold-cdn.xitu.io/2019/12/11/16ef37fee7e09230?w=951&amp;h=209&amp;f=jpeg&amp;s=20202\" alt=\"\" title=\"\" style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;\"><figcaption style=\"line-height: inherit; margin: 0px; padding: 0px; margin-top: 10px; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;\"></figcaption></figure>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">我们省略中间的网络通信时间消耗，假如购票系统处理需要 150ms ，短信系统处理需要 200ms ，那么整个处理流程的时间消耗就是 150ms + 200ms = 350ms。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">当然，乍看没什么问题。可是仔细一想你就感觉有点问题，我用户购票在购票系统的时候其实就已经完成了购买，而我现在通过同步调用非要让整个请求拉长时间，而短息系统这玩意又不是很有必要，它仅仅是一个辅助功能增强用户体验感而已。我现在整个调用流程就有点 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">头重脚轻</strong> 的感觉了，购票是一个不太耗时的流程，而我现在因为同步调用，非要等待发送短信这个比较耗时的操作才返回结果。那我如果再加一个发送邮件呢？</p>\n<figure style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><img src=\"https://user-gold-cdn.xitu.io/2019/12/11/16ef380429cf373e?w=1364&amp;h=210&amp;f=jpeg&amp;s=28357\" alt=\"\" title=\"\" style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;\"><figcaption style=\"line-height: inherit; margin: 0px; padding: 0px; margin-top: 10px; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;\"></figcaption></figure>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">这样整个系统的调用链又变长了，整个时间就变成了550ms。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">当我们在学生时代需要在食堂排队的时候，我们和食堂大妈就是一个同步的模型。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">我们需要告诉食堂大妈：“姐姐，给我加个鸡腿，再加个酸辣土豆丝，帮我浇点汁上去，多打点饭哦😋😋😋”  咦~~~ 为了多吃点，真恶心。</p>\n<figure style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><img src=\"https://user-gold-cdn.xitu.io/2019/12/11/16ef3807de75dce5?w=170&amp;h=220&amp;f=gif&amp;s=489646\" alt=\"\" title=\"\" style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;\"><figcaption style=\"line-height: inherit; margin: 0px; padding: 0px; margin-top: 10px; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;\"></figcaption></figure>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">然后大妈帮我们打饭配菜，我们看着大妈那颤抖的手和掉落的土豆丝不禁咽了咽口水。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">最终我们从大妈手中接过饭菜然后去寻找座位了…</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">回想一下，我们在给大妈发送需要的信息之后我们是 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">同步等待大妈给我配好饭菜</strong> 的，上面我们只是加了鸡腿和土豆丝，万一我再加一个番茄牛腩，韭菜鸡蛋，这样是不是大妈打饭配菜的流程就会变长，我们等待的时间也会相应的变长。</p>\n<figure style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><img src=\"https://user-gold-cdn.xitu.io/2019/12/11/16ef380ae4f8be5b?w=250&amp;h=221&amp;f=jpeg&amp;s=8279\" alt=\"\" title=\"\" style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;\"><figcaption style=\"line-height: inherit; margin: 0px; padding: 0px; margin-top: 10px; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;\"></figcaption></figure>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">那后来，我们工作赚钱了有钱去饭店吃饭了，我们告诉服务员来一碗牛肉面加个荷包蛋 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">(传达一个消息)</strong> ，然后我们就可以在饭桌上安心的玩手机了 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">(干自己其他事情)</strong> ，等到我们的牛肉面上了我们就可以吃了。这其中我们也就传达了一个消息，然后我们又转过头干其他事情了。这其中虽然做面的时间没有变短，但是我们只需要传达一个消息就可以看其他事情了，这是一个 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">异步</strong> 的概念。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">所以，为了解决这一个问题，聪明的程序员在中间也加了个类似于服务员的中间件——消息队列。这个时候我们就可以把模型给改造了。</p>\n<figure style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><img src=\"https://user-gold-cdn.xitu.io/2019/12/11/16ef38124f55eaea?w=1194&amp;h=326&amp;f=jpeg&amp;s=47622\" alt=\"\" title=\"\" style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;\"><figcaption style=\"line-height: inherit; margin: 0px; padding: 0px; margin-top: 10px; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;\"></figcaption></figure>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">这样，我们在将消息存入消息队列之后我们就可以直接返回了(我们告诉服务员我们要吃什么然后玩手机)，所以整个耗时只是 150ms + 10ms = 160ms。</p>\n<blockquote style=\"line-height: inherit; display: block; padding: 15px 15px 15px 1rem; font-size: 1em; margin: 1em 0px; color: rgb(129, 145, 152); border-left: 8px solid rgb(255, 138, 101); background: rgb(224, 242, 241); overflow: auto; overflow-wrap: normal; word-break: normal; letter-spacing: 1.5px; font-family: YouYuan;\">\n  <p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 0px;\">但是你需要注意的是，整个流程的时长是没变的，就像你仅仅告诉服务员要吃什么是不会影响到做面的速度的。</p>\n</blockquote>\n<h4 id=\"h-5\" style=\"color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px; font-weight: bold; font-size: 1.2em;\"><span style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\">解耦</span></h4>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">回到最初同步调用的过程，我们写个伪代码简单概括一下。</p>\n<figure style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><img src=\"https://user-gold-cdn.xitu.io/2019/12/11/16ef381a505d3e1f?w=538&amp;h=337&amp;f=png&amp;s=42350\" alt=\"\" title=\"\" style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;\"><figcaption style=\"line-height: inherit; margin: 0px; padding: 0px; margin-top: 10px; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;\"></figcaption></figure>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">那么第二步，我们又添加了一个发送邮件，我们就得重新去修改代码，如果我们又加一个需求：用户购买完还需要给他加积分，这个时候我们是不是又得改代码？</p>\n<figure style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><img src=\"https://user-gold-cdn.xitu.io/2019/12/11/16ef381c4e1b1ac7?w=538&amp;h=463&amp;f=png&amp;s=53705\" alt=\"\" title=\"\" style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;\"><figcaption style=\"line-height: inherit; margin: 0px; padding: 0px; margin-top: 10px; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;\"></figcaption></figure>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">如果你觉得还行，那么我这个时候不要发邮件这个服务了呢，我是不是又得改代码，又得重启应用？</p>\n<figure style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><img src=\"https://user-gold-cdn.xitu.io/2019/12/11/16ef381f273a66bd?w=200&amp;h=200&amp;f=jpeg&amp;s=8544\" alt=\"\" title=\"\" style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;\"><figcaption style=\"line-height: inherit; margin: 0px; padding: 0px; margin-top: 10px; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;\"></figcaption></figure>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">这样改来改去是不是很麻烦，那么 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">此时我们就用一个消息队列在中间进行解耦</strong> 。你需要注意的是，我们后面的发送短信、发送邮件、添加积分等一些操作都依赖于上面的 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">result</code> ，这东西抽象出来就是购票的处理结果呀，比如订单号，用户账号等等，也就是说我们后面的一系列服务都是需要同样的消息来进行处理。既然这样，我们是不是可以通过 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">“广播消息”</strong> 来实现。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">我上面所讲的“广播”并不是真正的广播，而是接下来的系统作为消费者去 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">订阅</strong> 特定的主题。比如我们这里的主题就可以叫做 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">订票</code> ，我们购买系统作为一个生产者去生产这条消息放入消息队列，然后消费者订阅了这个主题，会从消息队列中拉取消息并消费。就比如我们刚刚画的那张图，你会发现，在生产者这边我们只需要关注 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">生产消息到指定主题中</strong> ，而 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">消费者只需要关注从指定主题中拉取消息</strong> 就行了。</p>\n<figure style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><img src=\"https://user-gold-cdn.xitu.io/2019/12/11/16ef382674b66892?w=1194&amp;h=326&amp;f=jpeg&amp;s=47622\" alt=\"\" title=\"\" style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;\"><figcaption style=\"line-height: inherit; margin: 0px; padding: 0px; margin-top: 10px; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;\"></figcaption></figure>\n<blockquote style=\"line-height: inherit; display: block; padding: 15px 15px 15px 1rem; font-size: 1em; margin: 1em 0px; color: rgb(129, 145, 152); border-left: 8px solid rgb(255, 138, 101); background: rgb(224, 242, 241); overflow: auto; overflow-wrap: normal; word-break: normal; letter-spacing: 1.5px; font-family: YouYuan;\">\n  <p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 0px;\">如果没有消息队列，每当一个新的业务接入，我们都要在主系统调用新接口、或者当我们取消某些业务，我们也得在主系统删除某些接口调用。有了消息队列，我们只需要关心消息是否送达了队列，至于谁希望订阅，接下来收到消息如何处理，是下游的事情，无疑极大地减少了开发和联调的工作量。</p>\n</blockquote>\n<h4 id=\"h-6\" style=\"color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px; font-weight: bold; font-size: 1.2em;\"><span style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\">削峰</span></h4>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">我们再次回到一开始我们使用同步调用系统的情况，并且思考一下，如果此时有大量用户请求购票整个系统会变成什么样？</p>\n<figure style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><img src=\"https://user-gold-cdn.xitu.io/2019/12/11/16ef382a9756bb1c?w=1048&amp;h=469&amp;f=jpeg&amp;s=38175\" alt=\"\" title=\"\" style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;\"><figcaption style=\"line-height: inherit; margin: 0px; padding: 0px; margin-top: 10px; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;\"></figcaption></figure>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">如果，此时有一万的请求进入购票系统，我们知道运行我们主业务的服务器配置一般会比较好，所以这里我们假设购票系统能承受这一万的用户请求，那么也就意味着我们同时也会出现一万调用发短信服务的请求。而对于短信系统来说并不是我们的主要业务，所以我们配备的硬件资源并不会太高，那么你觉得现在这个短信系统能承受这一万的峰值么，且不说能不能承受，系统会不会 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">直接崩溃</strong> 了？</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">短信业务又不是我们的主业务，我们能不能 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">折中处理</strong> 呢？如果我们把购买完成的信息发送到消息队列中，而短信系统 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">尽自己所能地去消息队列中取消息和消费消息</strong> ，即使处理速度慢一点也无所谓，只要我们的系统没有崩溃就行了。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">留得江山在，还怕没柴烧？你敢说每次发送验证码的时候是一发你就收到了的么？</p>\n<h4 id=\"h-7\" style=\"color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px; font-weight: bold; font-size: 1.2em;\"><span style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\">消息队列能带来什么好处？</span></h4>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">其实上面我已经说了。<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">异步、解耦、削峰。</strong> 哪怕你上面的都没看懂也千万要记住这六个字，因为他不仅是消息队列的精华，更是编程和架构的精华。</p>\n<h4 id=\"h-8\" style=\"color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px; font-weight: bold; font-size: 1.2em;\"><span style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\">消息队列会带来副作用吗？</span></h4>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">没有哪一门技术是“银弹”，消息队列也有它的副作用。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">比如，本来好好的两个系统之间的调用，我中间加了个消息队列，如果消息队列挂了怎么办呢？是不是 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">降低了系统的可用性</strong> ？</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">那这样是不是要保证HA(高可用)？是不是要搞集群？那么我 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">整个系统的复杂度是不是上升了</strong> ？</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">抛开上面的问题不讲，万一我发送方发送失败了，然后执行重试，这样就可能产生重复的消息。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">或者我消费端处理失败了，请求重发，这样也会产生重复的消息。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">对于一些微服务来说，消费重复消息会带来更大的麻烦，比如增加积分，这个时候我加了多次是不是对其他用户不公平？</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">那么，又 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">如何解决重复消费消息的问题</strong> 呢？</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">如果我们此时的消息需要保证严格的顺序性怎么办呢？比如生产者生产了一系列的有序消息(对一个id为1的记录进行删除增加修改)，但是我们知道在发布订阅模型中，对于主题是无顺序的，那么这个时候就会导致对于消费者消费消息的时候没有按照生产者的发送顺序消费，比如这个时候我们消费的顺序为修改删除增加，如果该记录涉及到金额的话是不是会出大事情？</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">那么，又 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">如何解决消息的顺序消费问题</strong> 呢？</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">就拿我们上面所讲的分布式系统来说，用户购票完成之后是不是需要增加账户积分？在同一个系统中我们一般会使用事务来进行解决，如果用 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Spring</code> 的话我们在上面伪代码中加入 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">@Transactional</code> 注解就好了。但是在不同系统中如何保证事务呢？总不能这个系统我扣钱成功了你那积分系统积分没加吧？或者说我这扣钱明明失败了，你那积分系统给我加了积分。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">那么，又如何 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">解决分布式事务问题</strong> 呢？</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">我们刚刚说了，消息队列可以进行削峰操作，那如果我的消费者如果消费很慢或者生产者生产消息很快，这样是不是会将消息堆积在消息队列中？</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">那么，又如何 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">解决消息堆积的问题</strong> 呢？</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">可用性降低，复杂度上升，又带来一系列的重复消费，顺序消费，分布式事务，消息堆积的问题，这消息队列还怎么用啊😵？</p>\n<figure style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><img src=\"https://user-gold-cdn.xitu.io/2019/12/11/16ef382d709abc9d?w=255&amp;h=255&amp;f=jpeg&amp;s=8169\" alt=\"\" title=\"\" style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;\"><figcaption style=\"line-height: inherit; margin: 0px; padding: 0px; margin-top: 10px; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;\"></figcaption></figure>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">别急，办法总是有的。</p>\n<h2 id=\"hrocketmq\" style=\"color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px; font-weight: bold; font-size: 1.5em; border-bottom: 2.2px solid rgb(255, 111, 0);\"><span style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; background: rgb(255, 111, 0); padding: 5px 15px; display: inline-block;\">RocketMQ是什么？</span></h2>\n<figure style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><img src=\"https://user-gold-cdn.xitu.io/2019/12/11/16ef383014430799?w=1450&amp;h=430&amp;f=jpeg&amp;s=103646\" alt=\"\" title=\"\" style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;\"><figcaption style=\"line-height: inherit; margin: 0px; padding: 0px; margin-top: 10px; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;\"></figcaption></figure>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">哇，你个混蛋！上面给我抛出那么多问题，你现在又讲 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> ，还让不让人活了？！🤬</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">别急别急，话说你现在清楚 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">MQ</code> 的构造吗，我还没讲呢，我们先搞明白 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">MQ</code> 的内部构造，再来看看如何解决上面的一系列问题吧，不过你最好带着问题去阅读和了解喔。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\"><code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 是一个 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">队列模型</strong> 的消息中间件，具有<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">高性能、高可靠、高实时、分布式</strong> 的特点。它是一个采用 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Java</code> 语言开发的分布式的消息系统，由阿里巴巴团队开发，在2016年底贡献给 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Apache</code>，成为了 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Apache</code> 的一个顶级项目。 在阿里内部，<code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 很好地服务了集团大大小小上千个应用，在每年的双十一当天，更有不可思议的万亿级消息通过 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 流转。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">废话不多说，想要了解 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 历史的同学可以自己去搜寻资料。听完上面的介绍，你只要知道 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 很快、很牛、而且经历过双十一的实践就行了！</p>\n<h2 id=\"h-9\" style=\"color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px; font-weight: bold; font-size: 1.5em; border-bottom: 2.2px solid rgb(255, 111, 0);\"><span style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; background: rgb(255, 111, 0); padding: 5px 15px; display: inline-block;\">队列模型和主题模型</span></h2>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">在谈 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 的技术架构之前，我们先来了解一下两个名词概念——<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">队列模型</strong> 和 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">主题模型</strong> 。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">首先我问一个问题，消息队列为什么要叫消息队列？</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">你可能觉得很弱智，这玩意不就是存放消息的队列嘛？不叫消息队列叫什么？</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">的确，早期的消息中间件是通过 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">队列</strong> 这一模型来实现的，可能是历史原因，我们都习惯把消息中间件成为消息队列。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">但是，如今例如 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 、<code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Kafka</code> 这些优秀的消息中间件不仅仅是通过一个 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">队列</strong> 来实现消息存储的。</p>\n<h3 id=\"h-10\" style=\"color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px; font-weight: bold; font-size: 1.3em;\"><span style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\">队列模型</span></h3>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">就像我们理解队列一样，消息中间件的队列模型就真的只是一个队列。。。我画一张图给大家理解。</p>\n<figure style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><img src=\"https://user-gold-cdn.xitu.io/2019/12/11/16ef3834ae653469?w=760&amp;h=142&amp;f=jpeg&amp;s=22424\" alt=\"\" title=\"\" style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;\"><figcaption style=\"line-height: inherit; margin: 0px; padding: 0px; margin-top: 10px; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;\"></figcaption></figure>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">在一开始我跟你提到了一个 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">“广播”</strong> 的概念，也就是说如果我们此时我们需要将一个消息发送给多个消费者(比如此时我需要将信息发送给短信系统和邮件系统)，这个时候单个队列即不能满足需求了。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">当然你可以让 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Producer</code> 生产消息放入多个队列中，然后每个队列去对应每一个消费者。问题是可以解决，创建多个队列并且复制多份消息是会很影响资源和性能的。而且，这样子就会导致生产者需要知道具体消费者个数然后去复制对应数量的消息队列，这就违背我们消息中间件的 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">解耦</strong> 这一原则。</p>\n<h3 id=\"h-11\" style=\"color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px; font-weight: bold; font-size: 1.3em;\"><span style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\">主题模型</span></h3>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">那么有没有好的方法去解决这一个问题呢？有，那就是 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">主题模型</strong> 或者可以称为 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">发布订阅模型</strong> 。</p>\n<blockquote style=\"line-height: inherit; display: block; padding: 15px 15px 15px 1rem; font-size: 1em; margin: 1em 0px; color: rgb(129, 145, 152); border-left: 8px solid rgb(255, 138, 101); background: rgb(224, 242, 241); overflow: auto; overflow-wrap: normal; word-break: normal; letter-spacing: 1.5px; font-family: YouYuan;\">\n  <p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 0px;\">感兴趣的同学可以去了解一下设计模式里面的观察者模式并且手动实现一下，我相信你会有所收获的。</p>\n</blockquote>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">在主题模型中，消息的生产者称为 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">发布者(Publisher)</strong> ，消息的消费者称为 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">订阅者(Subscriber)</strong> ，存放消息的容器称为 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">主题(Topic)</strong> 。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">其中，发布者将消息发送到指定主题中，订阅者需要 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">提前订阅主题</strong> 才能接受特定主题的消息。</p>\n<figure style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><img src=\"https://user-gold-cdn.xitu.io/2019/12/11/16ef3837887d9a54?w=760&amp;h=341&amp;f=jpeg&amp;s=47404\" alt=\"\" title=\"\" style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;\"><figcaption style=\"line-height: inherit; margin: 0px; padding: 0px; margin-top: 10px; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;\"></figcaption></figure>\n<h3 id=\"hrocketmq-1\" style=\"color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px; font-weight: bold; font-size: 1.3em;\"><span style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\">RocketMQ中的消息模型</span></h3>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\"><code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RockerMQ</code> 中的消息模型就是按照 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">主题模型</strong> 所实现的。你可能会好奇这个 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">主题</strong> 到底是怎么实现的呢？你上面也没有讲到呀！</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">其实对于主题模型的实现来说每个消息中间件的底层设计都是不一样的，就比如 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Kafka</code> 中的 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">分区</strong> ，<code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 中的 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">队列</strong> ，<code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RabbitMQ</code> 中的 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Exchange</code> 。我们可以理解为 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">主题模型/发布订阅模型</strong> 就是一个标准，那些中间件只不过照着这个标准去实现而已。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">所以，<code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 中的 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">主题模型</strong> 到底是如何实现的呢？首先我画一张图，大家尝试着去理解一下。</p>\n<figure style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><img src=\"https://user-gold-cdn.xitu.io/2019/12/11/16ef383d3e8c9788?w=1391&amp;h=555&amp;f=jpeg&amp;s=116552\" alt=\"\" title=\"\" style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;\"><figcaption style=\"line-height: inherit; margin: 0px; padding: 0px; margin-top: 10px; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;\"></figcaption></figure>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">我们可以看到在整个图中有 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Producer Group</code> 、<code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Topic</code> 、<code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Consumer Group</code>  三个角色，我来分别介绍一下他们。</p>\n<ul style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px; padding-left: 32px; list-style-type: disc;\">\n<li style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px; margin-bottom: 0.5em;\"><code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Producer Group</code> 生产者组： 代表某一类的生产者，比如我们有多个秒杀系统作为生产者，这多个合在一起就是一个 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Producer Group</code> 生产者组，它们一般生产相同的消息。</li>\n<li style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px; margin-bottom: 0.5em;\"><code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Consumer Group</code> 消费者组： 代表某一类的消费者，比如我们有多个短信系统作为消费者，这多个合在一起就是一个 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Consumer Group</code> 消费者组，它们一般消费相同的消息。</li>\n<li style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px; margin-bottom: 0.5em;\"><code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Topic</code> 主题： 代表一类消息，比如订单消息，物流消息等等。</li>\n</ul>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">你可以看到图中生产者组中的生产者会向主题发送消息，而 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">主题中存在多个队列</strong>，生产者每次生产消息之后是指定主题中的某个队列发送消息的。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">每个主题中都有多个队列(这里还不涉及到 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code>)，集群消费模式下，一个消费者集群多台机器共同消费一个 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">topic</code> 的多个队列，<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">一个队列只会被一个消费者消费</strong>。如果某个消费者挂掉，分组内其它消费者会接替挂掉的消费者继续消费。就像上图中 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Consumer1</code> 和 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Consumer2</code> 分别对应着两个队列，而 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Consuer3</code> 是没有队列对应的，所以一般来讲要控制 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">消费者组中的消费者个数和主题中队列个数相同</strong> 。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">当然也可以消费者个数小于队列个数，只不过不太建议。如下图。</p>\n<figure style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><img src=\"https://user-gold-cdn.xitu.io/2019/12/11/16ef3850c808d707?w=910&amp;h=261&amp;f=jpeg&amp;s=43637\" alt=\"\" title=\"\" style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;\"><figcaption style=\"line-height: inherit; margin: 0px; padding: 0px; margin-top: 10px; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;\"></figcaption></figure>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\"><strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">每个消费组在每个队列上维护一个消费位置</strong> ，为什么呢？</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">因为我们刚刚画的仅仅是一个消费者组，我们知道在发布订阅模式中一般会涉及到多个消费者组，而每个消费者组在每个队列中的消费位置都是不同的。如果此时有多个消费者组，那么消息被一个消费者组消费完之后是不会删除的(因为其它消费者组也需要呀)，它仅仅是为每个消费者组维护一个 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">消费位移(offset)</strong> ，每次消费者组消费完会返回一个成功的响应，然后队列再把维护的消费位移加一，这样就不会出现刚刚消费过的消息再一次被消费了。</p>\n<figure style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><img src=\"https://user-gold-cdn.xitu.io/2019/12/11/16ef3857fefaa079?w=1251&amp;h=599&amp;f=jpeg&amp;s=130119\" alt=\"\" title=\"\" style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;\"><figcaption style=\"line-height: inherit; margin: 0px; padding: 0px; margin-top: 10px; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;\"></figcaption></figure>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">可能你还有一个问题，<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">为什么一个主题中需要维护多个队列</strong> ？</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">答案是 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">提高并发能力</strong> 。的确，每个主题中只存在一个队列也是可行的。你想一下，如果每个主题中只存在一个队列，这个队列中也维护着每个消费者组的消费位置，这样也可以做到 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">发布订阅模式</strong> 。如下图。</p>\n<figure style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><img src=\"https://user-gold-cdn.xitu.io/2019/12/11/16ef38600cdb6d4b?w=1271&amp;h=632&amp;f=jpeg&amp;s=128950\" alt=\"\" title=\"\" style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;\"><figcaption style=\"line-height: inherit; margin: 0px; padding: 0px; margin-top: 10px; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;\"></figcaption></figure>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">但是，这样我生产者是不是只能向一个队列发送消息？又因为需要维护消费位置所以一个队列只能对应一个消费者组中的消费者，这样是不是其他的 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Consumer</code> 就没有用武之地了？从这两个角度来讲，并发度一下子就小了很多。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">所以总结来说，<code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 通过<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">使用在一个 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Topic</code> 中配置多个队列并且每个队列维护每个消费者组的消费位置</strong> 实现了 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">主题模式/发布订阅模式</strong> 。</p>\n<h2 id=\"hrocketmq-2\" style=\"color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px; font-weight: bold; font-size: 1.5em; border-bottom: 2.2px solid rgb(255, 111, 0);\"><span style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; background: rgb(255, 111, 0); padding: 5px 15px; display: inline-block;\">RocketMQ的架构图</span></h2>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">讲完了消息模型，我们理解起 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 的技术架构起来就容易多了。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\"><code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 技术架构中有四大角色 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">NameServer</code> 、<code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 、<code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Producer</code> 、<code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Consumer</code> 。我来向大家分别解释一下这四个角色是干啥的。</p>\n<ul style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px; padding-left: 32px; list-style-type: disc;\">\n<li style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px; margin-bottom: 0.5em;\"><p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\"><code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code>： 主要负责消息的存储、投递和查询以及服务高可用保证。说白了就是消息队列服务器嘛，生产者生产消息到 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> ，消费者从 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 拉取消息并消费。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">这里，我还得普及一下关于 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 、<code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Topic</code> 和 队列的关系。上面我讲解了 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Topic</code> 和队列的关系——一个 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Topic</code> 中存在多个队列，那么这个 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Topic</code> 和队列存放在哪呢？</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\"><strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">一个 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Topic</code> 分布在多个 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code>上，一个 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 可以配置多个 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Topic</code> ，它们是多对多的关系</strong>。 </p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">如果某个 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Topic</code> 消息量很大，应该给它多配置几个队列(上文中提到了提高并发能力)，并且 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">尽量多分布在不同 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 上，以减轻某个 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 的压力</strong> 。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\"><code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Topic</code> 消息量都比较均匀的情况下，如果某个 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">broker</code> 上的队列越多，则该 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">broker</code> 压力越大。</p>\n<figure style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><img src=\"https://user-gold-cdn.xitu.io/2019/12/11/16ef38687488a5a4?w=936&amp;h=673&amp;f=jpeg&amp;s=93578\" alt=\"\" title=\"\" style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;\"><figcaption style=\"line-height: inherit; margin: 0px; padding: 0px; margin-top: 10px; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;\"></figcaption></figure></li>\n</ul>\n<blockquote style=\"line-height: inherit; display: block; padding: 15px 15px 15px 1rem; font-size: 1em; margin: 1em 0px; color: rgb(129, 145, 152); border-left: 8px solid rgb(255, 138, 101); background: rgb(224, 242, 241); overflow: auto; overflow-wrap: normal; word-break: normal; letter-spacing: 1.5px; font-family: YouYuan;\">\n  <p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 0px;\">所以说我们需要配置多个Broker。</p>\n</blockquote>\n<ul style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px; padding-left: 32px; list-style-type: disc;\">\n<li style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px; margin-bottom: 0.5em;\"><p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\"><code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">NameServer</code>： 不知道你们有没有接触过 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">ZooKeeper</code> 和 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Spring Cloud</code> 中的 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Eureka</code> ，它其实也是一个 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">注册中心</strong> ，主要提供两个功能：<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">Broker管理</strong> 和 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">路由信息管理</strong> 。说白了就是 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 会将自己的信息注册到 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">NameServer</code> 中，此时 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">NameServer</code> 就存放了很多 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 的信息(Broker的路由表)，消费者和生产者就从 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">NameServer</code> 中获取路由表然后照着路由表的信息和对应的 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 进行通信(生产者和消费者定期会向 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">NameServer</code> 去查询相关的 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 的信息)。</p></li>\n<li style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px; margin-bottom: 0.5em;\"><p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\"><code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Producer</code>： 消息发布的角色，支持分布式集群方式部署。说白了就是生产者。</p></li>\n<li style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px; margin-bottom: 0.5em;\"><p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\"><code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Consumer</code>： 消息消费的角色，支持分布式集群方式部署。支持以push推，pull拉两种模式对消息进行消费。同时也支持集群方式和广播方式的消费，它提供实时消息订阅机制。说白了就是消费者。</p></li>\n</ul>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">听完了上面的解释你可能会觉得，这玩意好简单。不就是这样的么？</p>\n<figure style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><img src=\"https://user-gold-cdn.xitu.io/2019/12/11/16ef386c6d1e8bdb?w=1237&amp;h=454&amp;f=jpeg&amp;s=93637\" alt=\"\" title=\"\" style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;\"><figcaption style=\"line-height: inherit; margin: 0px; padding: 0px; margin-top: 10px; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;\"></figcaption></figure>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">嗯？你可能会发现一个问题，这老家伙 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">NameServer</code> 干啥用的，这不多余吗？直接 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Producer</code> 、<code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Consumer</code> 和 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 直接进行生产消息，消费消息不就好了么？</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">但是，我们上文提到过 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 是需要保证高可用的，如果整个系统仅仅靠着一个 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 来维持的话，那么这个 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 的压力会不会很大？所以我们需要使用多个 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 来保证 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">负载均衡</strong> 。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">如果说，我们的消费者和生产者直接和多个 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 相连，那么当 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 修改的时候必定会牵连着每个生产者和消费者，这样就会产生耦合问题，而 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">NameServer</code> 注册中心就是用来解决这个问题的。</p>\n<blockquote style=\"line-height: inherit; display: block; padding: 15px 15px 15px 1rem; font-size: 1em; margin: 1em 0px; color: rgb(129, 145, 152); border-left: 8px solid rgb(255, 138, 101); background: rgb(224, 242, 241); overflow: auto; overflow-wrap: normal; word-break: normal; letter-spacing: 1.5px; font-family: YouYuan;\">\n  <p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 0px;\">如果还不是很理解的话，可以去看我介绍 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Spring Cloud</code> 的那篇文章，其中介绍了 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Eureka</code> 注册中心。</p>\n</blockquote>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">当然，<code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 中的技术架构肯定不止前面那么简单，因为上面图中的四个角色都是需要做集群的。我给出一张官网的架构图，大家尝试理解一下。</p>\n<figure style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><img src=\"https://user-gold-cdn.xitu.io/2019/12/11/16ef386fa3be1e53?w=1281&amp;h=522&amp;f=jpeg&amp;s=66376\" alt=\"\" title=\"\" style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;\"><figcaption style=\"line-height: inherit; margin: 0px; padding: 0px; margin-top: 10px; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;\"></figcaption></figure>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">其实和我们最开始画的那张乞丐版的架构图也没什么区别，主要是一些细节上的差别。听我细细道来🤨。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">第一、我们的 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">做了集群并且还进行了主从部署</strong> ，由于消息分布在各个 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 上，一旦某个 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 宕机，则该<code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 上的消息读写都会受到影响。所以 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Rocketmq</code> 提供了 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">master/slave</code> 的结构，<code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">salve</code> 定时从 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">master</code> 同步数据(同步刷盘或者异步刷盘)，如果 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">master</code> 宕机，<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">则 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">slave</code> 提供消费服务，但是不能写入消息</strong> (后面我还会提到哦)。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">第二、为了保证 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">HA</code> ，我们的 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">NameServer</code> 也做了集群部署，但是请注意它是 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">去中心化</strong> 的。也就意味着它没有主节点，你可以很明显地看出 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">NameServer</code> 的所有节点是没有进行 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Info Replicate</code> 的，在 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 中是通过 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">单个Broker和所有NameServer保持长连接</strong> ，并且在每隔30秒 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 会向所有 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Nameserver</code> 发送心跳，心跳包含了自身的 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Topic</code> 配置信息，这个步骤就对应这上面的 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Routing Info</code> 。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">第三、在生产者需要向 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 发送消息的时候，<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">需要先从 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">NameServer</code> 获取关于 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 的路由信息</strong>，然后通过 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">轮询</strong> 的方法去向每个队列中生产数据以达到 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">负载均衡</strong> 的效果。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">第四、消费者通过 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">NameServer</code> 获取所有 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 的路由信息后，向 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 发送 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Pull</code> 请求来获取消息数据。<code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Consumer</code> 可以以两种模式启动—— <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">广播（Broadcast）和集群（Cluster）</strong>。广播模式下，一条消息会发送给 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">同一个消费组中的所有消费者</strong> ，集群模式下消息只会发送给一个消费者。</p>\n<h2 id=\"h-12\" style=\"color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px; font-weight: bold; font-size: 1.5em; border-bottom: 2.2px solid rgb(255, 111, 0);\"><span style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; background: rgb(255, 111, 0); padding: 5px 15px; display: inline-block;\">如何解决 顺序消费、重复消费</span></h2>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">其实，这些东西都是我在介绍消息队列带来的一些副作用的时候提到的，也就是说，这些问题不仅仅挂钩于 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> ，而是应该每个消息中间件都需要去解决的。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">在上面我介绍 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 的技术架构的时候我已经向你展示了 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">它是如何保证高可用的</strong> ，这里不涉及运维方面的搭建，如果你感兴趣可以自己去官网上照着例子搭建属于你自己的 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 集群。</p>\n<blockquote style=\"line-height: inherit; display: block; padding: 15px 15px 15px 1rem; font-size: 1em; margin: 1em 0px; color: rgb(129, 145, 152); border-left: 8px solid rgb(255, 138, 101); background: rgb(224, 242, 241); overflow: auto; overflow-wrap: normal; word-break: normal; letter-spacing: 1.5px; font-family: YouYuan;\">\n  <p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 0px;\">其实 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Kafka</code> 的架构基本和 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 类似，只是它注册中心使用了 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Zookeeper</code> 、它的 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">分区</strong> 就相当于 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 中的 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">队列</strong> 。还有一些小细节不同会在后面提到。</p>\n</blockquote>\n<h3 id=\"h-13\" style=\"color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px; font-weight: bold; font-size: 1.3em;\"><span style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\">顺序消费</span></h3>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">在上面的技术架构介绍中，我们已经知道了 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\"><code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 在主题上是无序的、它只有在队列层面才是保证有序</strong> 的。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">这又扯到两个概念——<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">普通顺序</strong> 和 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">严格顺序</strong> 。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">所谓普通顺序是指 消费者通过 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">同一个消费队列收到的消息是有顺序的</strong> ，不同消息队列收到的消息则可能是无顺序的。普通顺序消息在 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">重启情况下不会保证消息顺序性</strong> (短暂时间) 。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">所谓严格顺序是指  消费者收到的 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">所有消息</strong> 均是有顺序的。严格顺序消息 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">即使在异常情况下也会保证消息的顺序性</strong> 。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">但是，严格顺序看起来虽好，实现它可会付出巨大的代价。如果你使用严格顺序模式，<code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 集群中只要有一台机器不可用，则整个集群都不可用。你还用啥？现在主要场景也就在 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">binlog</code> 同步。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">一般而言，我们的 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">MQ</code> 都是能容忍短暂的乱序，所以推荐使用普通顺序模式。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">那么，我们现在使用了 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">普通顺序模式</strong> ，我们从上面学习知道了在 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Producer</code> 生产消息的时候会进行轮询(取决你的负载均衡策略)来向同一主题的不同消息队列发送消息。那么如果此时我有几个消息分别是同一个订单的创建、支付、发货，在轮询的策略下这 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">三个消息会被发送到不同队列</strong> ，因为在不同的队列此时就无法使用 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 带来的队列有序特性来保证消息有序性了。</p>\n<figure style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><img src=\"https://user-gold-cdn.xitu.io/2019/12/11/16ef3874585e096e?w=1258&amp;h=484&amp;f=jpeg&amp;s=90329\" alt=\"\" title=\"\" style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;\"><figcaption style=\"line-height: inherit; margin: 0px; padding: 0px; margin-top: 10px; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;\"></figcaption></figure>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">那么，怎么解决呢？</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">其实很简单，我们需要处理的仅仅是将同一语义下的消息放入同一个队列(比如这里是同一个订单)，那我们就可以使用 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">Hash取模法</strong> 来保证同一个订单在同一个队列中就行了。</p>\n<h3 id=\"h-14\" style=\"color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px; font-weight: bold; font-size: 1.3em;\"><span style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\">重复消费</span></h3>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">emmm，就两个字—— <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">幂等</strong> 。在编程中一个<em style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px; font-style: italic;\">幂等</em> 操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。比如说，这个时候我们有一个订单的处理积分的系统，每当来一个消息的时候它就负责为创建这个订单的用户的积分加上相应的数值。可是有一次，消息队列发送给订单系统 FrancisQ 的订单信息，其要求是给 FrancisQ 的积分加上 500。但是积分系统在收到 FrancisQ 的订单信息处理完成之后返回给消息队列处理成功的信息的时候出现了网络波动(当然还有很多种情况，比如Broker意外重启等等)，这条回应没有发送成功。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">那么，消息队列没收到积分系统的回应会不会尝试重发这个消息？问题就来了，我再发这个消息，万一它又给 FrancisQ 的账户加上 500 积分怎么办呢？</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">所以我们需要给我们的消费者实现 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">幂等</strong> ，也就是对同一个消息的处理结果，执行多少次都不变。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">那么如何给业务实现幂等呢？这个还是需要结合具体的业务的。你可以使用 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">写入 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Redis</code></strong> 来保证，因为 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Redis</code> 的 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">key</code> 和 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">value</code> 就是天然支持幂等的。当然还有使用 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">数据库插入法</strong> ，基于数据库的唯一键来保证重复数据不会被插入多条。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">不过最主要的还是需要 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">根据特定场景使用特定的解决方案</strong> ，你要知道你的消息消费是否是完全不可重复消费还是可以忍受重复消费的，然后再选择强校验和弱校验的方式。毕竟在 CS 领域还是很少有技术银弹的说法。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">而在整个互联网领域，幂等不仅仅适用于消息队列的重复消费问题，这些实现幂等的方法，也同样适用于，<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">在其他场景中来解决重复请求或者重复调用的问题</strong> 。比如将HTTP服务设计成幂等的，<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">解决前端或者APP重复提交表单数据的问题</strong> ，也可以将一个微服务设计成幂等的，解决 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RPC</code> 框架自动重试导致的 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">重复调用问题</strong> 。</p>\n<h2 id=\"h-15\" style=\"color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px; font-weight: bold; font-size: 1.5em; border-bottom: 2.2px solid rgb(255, 111, 0);\"><span style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; background: rgb(255, 111, 0); padding: 5px 15px; display: inline-block;\">分布式事务</span></h2>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">如何解释分布式事务呢？事务大家都知道吧？<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">要么都执行要么都不执行</strong> 。在同一个系统中我们可以轻松地实现事务，但是在分布式架构中，我们有很多服务是部署在不同系统之间的，而不同服务之间又需要进行调用。比如此时我下订单然后增加积分，如果保证不了分布式事务的话，就会出现A系统下了订单，但是B系统增加积分失败或者A系统没有下订单，B系统却增加了积分。前者对用户不友好，后者对运营商不利，这是我们都不愿意见到的。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">那么，如何去解决这个问题呢？</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">如今比较常见的分布式事务实现有 2PC、TCC 和事务消息(half 半消息机制)。每一种实现都有其特定的使用场景，但是也有各自的问题，<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">都不是完美的解决方案</strong>。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">在 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 中使用的是 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">事务消息加上事务反查机制</strong> 来解决分布式事务问题的。我画了张图，大家可以对照着图进行理解。</p>\n<figure style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><img src=\"https://user-gold-cdn.xitu.io/2019/12/11/16ef38798d7a987f?w=1355&amp;h=360&amp;f=jpeg&amp;s=107566\" alt=\"\" title=\"\" style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;\"><figcaption style=\"line-height: inherit; margin: 0px; padding: 0px; margin-top: 10px; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;\"></figcaption></figure>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">在第一步发送的 half 消息 ，它的意思是 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">在事务提交之前，对于消费者来说，这个消息是不可见的</strong> 。</p>\n<blockquote style=\"line-height: inherit; display: block; padding: 15px 15px 15px 1rem; font-size: 1em; margin: 1em 0px; color: rgb(129, 145, 152); border-left: 8px solid rgb(255, 138, 101); background: rgb(224, 242, 241); overflow: auto; overflow-wrap: normal; word-break: normal; letter-spacing: 1.5px; font-family: YouYuan;\">\n  <p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 0px;\">那么，如何做到写入消息但是对用户不可见呢？RocketMQ事务消息的做法是：如果消息是half消息，将备份原消息的主题与消息消费队列，然后 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">改变主题</strong> 为RMQ_SYS_TRANS_HALF_TOPIC。由于消费组未订阅该主题，故消费端无法消费half类型的消息，<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">然后RocketMQ会开启一个定时任务，从Topic为RMQ_SYS_TRANS_HALF_TOPIC中拉取消息进行消费</strong>，根据生产者组获取一个服务提供者发送回查事务状态请求，根据事务状态来决定是提交或回滚消息。</p>\n</blockquote>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">你可以试想一下，如果没有从第5步开始的 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">事务反查机制</strong> ，如果出现网路波动第4步没有发送成功，这样就会产生 MQ 不知道是不是需要给消费者消费的问题，他就像一个无头苍蝇一样。在 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 中就是使用的上述的事务反查来解决的，而在 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Kafka</code> 中通常是直接抛出一个异常让用户来自行解决。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">你还需要注意的是，在 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">MQ Server</code> 指向系统B的操作已经和系统A不相关了，也就是说在消息队列中的分布式事务是——<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">本地事务和存储消息到消息队列才是同一个事务</strong>。这样也就产生了事务的<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">最终一致性</strong>，因为整个过程是异步的，<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">每个系统只要保证它自己那一部分的事务就行了</strong>。</p>\n<h2 id=\"h-16\" style=\"color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px; font-weight: bold; font-size: 1.5em; border-bottom: 2.2px solid rgb(255, 111, 0);\"><span style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; background: rgb(255, 111, 0); padding: 5px 15px; display: inline-block;\">消息堆积问题</span></h2>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">在上面我们提到了消息队列一个很重要的功能——<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">削峰</strong> 。那么如果这个峰值太大了导致消息堆积在队列中怎么办呢？</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">其实这个问题可以将它广义化，因为产生消息堆积的根源其实就只有两个——生产者生产太快或者消费者消费太慢。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">我们可以从多个角度去思考解决这个问题，当流量到峰值的时候是因为生产者生产太快，我们可以使用一些 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">限流降级</strong> 的方法，当然你也可以增加多个消费者实例去水平扩展增加消费能力来匹配生产的激增。如果消费者消费过慢的话，我们可以先检查 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">是否是消费者出现了大量的消费错误</strong> ，或者打印一下日志查看是否是哪一个线程卡死，出现了锁资源不释放等等的问题。</p>\n<blockquote style=\"line-height: inherit; display: block; padding: 15px 15px 15px 1rem; font-size: 1em; margin: 1em 0px; color: rgb(129, 145, 152); border-left: 8px solid rgb(255, 138, 101); background: rgb(224, 242, 241); overflow: auto; overflow-wrap: normal; word-break: normal; letter-spacing: 1.5px; font-family: YouYuan;\">\n  <p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 0px;\">当然，最快速解决消息堆积问题的方法还是增加消费者实例，不过 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">同时你还需要增加每个主题的队列数量</strong> 。</p>\n  <p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 0px;\">别忘了在 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 中，<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">一个队列只会被一个消费者消费</strong> ，如果你仅仅是增加消费者实例就会出现我一开始给你画架构图的那种情况。</p>\n</blockquote>\n<figure style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><img src=\"https://user-gold-cdn.xitu.io/2019/12/11/16ef387d939ab66d?w=1391&amp;h=555&amp;f=jpeg&amp;s=116552\" alt=\"\" title=\"\" style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;\"><figcaption style=\"line-height: inherit; margin: 0px; padding: 0px; margin-top: 10px; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;\"></figcaption></figure>\n<h2 id=\"h-17\" style=\"color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px; font-weight: bold; font-size: 1.5em; border-bottom: 2.2px solid rgb(255, 111, 0);\"><span style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; background: rgb(255, 111, 0); padding: 5px 15px; display: inline-block;\">回溯消费</span></h2>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">回溯消费是指 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Consumer</code> 已经消费成功的消息，由于业务上需求需要重新消费，在<code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 中， <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 在向<code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Consumer</code> 投递成功消息后，<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">消息仍然需要保留</strong> 。并且重新消费一般是按照时间维度，例如由于 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Consumer</code> 系统故障，恢复后需要重新消费1小时前的数据，那么 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 要提供一种机制，可以按照时间维度来回退消费进度。<code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 支持按照时间回溯消费，时间维度精确到毫秒。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">这是官方文档的解释，我直接照搬过来就当科普了😁😁😁。</p>\n<h2 id=\"hrocketmq-3\" style=\"color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px; font-weight: bold; font-size: 1.5em; border-bottom: 2.2px solid rgb(255, 111, 0);\"><span style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; background: rgb(255, 111, 0); padding: 5px 15px; display: inline-block;\">RocketMQ 的刷盘机制</span></h2>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">上面我讲了那么多的 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 的架构和设计原理，你有没有好奇</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">在 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Topic</code> 中的 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">队列是以什么样的形式存在的？</strong></p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\"><strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">队列中的消息又是如何进行存储持久化的呢？</strong></p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">我在上文中提到的 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">同步刷盘</strong> 和 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">异步刷盘</strong> 又是什么呢？它们会给持久化带来什么样的影响呢？</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">下面我将给你们一一解释。</p>\n<h3 id=\"h-18\" style=\"color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px; font-weight: bold; font-size: 1.3em;\"><span style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\">同步刷盘和异步刷盘</span></h3>\n<figure style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><img src=\"https://user-gold-cdn.xitu.io/2019/12/11/16ef387fba311cda?w=1101&amp;h=874&amp;f=jpeg&amp;s=101763\" alt=\"\" title=\"\" style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;\"><figcaption style=\"line-height: inherit; margin: 0px; padding: 0px; margin-top: 10px; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;\"></figcaption></figure>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">如上图所示，在同步刷盘中需要等待一个刷盘成功的 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">ACK</code> ，同步刷盘对 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">MQ</code> 消息可靠性来说是一种不错的保障，但是 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">性能上会有较大影响</strong> ，一般地适用于金融等特定业务场景。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">而异步刷盘往往是开启一个线程去异步地执行刷盘操作。消息刷盘采用后台异步线程提交的方式进行， <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">降低了读写延迟</strong> ，提高了 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">MQ</code> 的性能和吞吐量，一般适用于如发验证码等对于消息保证要求不太高的业务场景。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">一般地，<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">异步刷盘只有在 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 意外宕机的时候会丢失部分数据</strong>，你可以设置 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 的参数 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">FlushDiskType</code> 来调整你的刷盘策略(ASYNC_FLUSH 或者 SYNC_FLUSH)。</p>\n<h3 id=\"h-19\" style=\"color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px; font-weight: bold; font-size: 1.3em;\"><span style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\">同步复制和异步复制</span></h3>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">上面的同步刷盘和异步刷盘是在单个结点层面的，而同步复制和异步复制主要是指的 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Borker</code> 主从模式下，主节点返回消息给客户端的时候是否需要同步从节点。</p>\n<ul style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px; padding-left: 32px; list-style-type: disc;\">\n<li style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px; margin-bottom: 0.5em;\">同步复制： 也叫 “同步双写”，也就是说，<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">只有消息同步双写到主从结点上时才返回写入成功</strong> 。</li>\n<li style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px; margin-bottom: 0.5em;\">异步复制： <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">消息写入主节点之后就直接返回写入成功</strong> 。</li>\n</ul>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">然而，很多事情是没有完美的方案的，就比如我们进行消息写入的节点越多就更能保证消息的可靠性，但是随之的性能也会下降，所以需要程序员根据特定业务场景去选择适应的主从复制方案。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">那么，<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">异步复制会不会也像异步刷盘那样影响消息的可靠性呢？</strong></p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">答案是不会的，因为两者就是不同的概念，对于消息可靠性是通过不同的刷盘策略保证的，而像异步同步复制策略仅仅是影响到了 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">可用性</strong> 。为什么呢？其主要原因<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">是 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 是不支持自动主从切换的，当主节点挂掉之后，生产者就不能再给这个主节点生产消息了</strong>。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">比如这个时候采用异步复制的方式，在主节点还未发送完需要同步的消息的时候主节点挂掉了，这个时候从节点就少了一部分消息。但是此时生产者无法再给主节点生产消息了，<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">消费者可以自动切换到从节点进行消费</strong>(仅仅是消费)，所以在主节点挂掉的时间只会产生主从结点短暂的消息不一致的情况，降低了可用性，而当主节点重启之后，从节点那部分未来得及复制的消息还会继续复制。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">在单主从架构中，如果一个主节点挂掉了，那么也就意味着整个系统不能再生产了。那么这个可用性的问题能否解决呢？<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">一个主从不行那就多个主从的呗</strong>，别忘了在我们最初的架构图中，每个 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Topic</code> 是分布在不同 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 中的。</p>\n<figure style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><img src=\"https://user-gold-cdn.xitu.io/2019/12/11/16ef38823b165817?w=936&amp;h=673&amp;f=jpeg&amp;s=93578\" alt=\"\" title=\"\" style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;\"><figcaption style=\"line-height: inherit; margin: 0px; padding: 0px; margin-top: 10px; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;\"></figcaption></figure>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">但是这种复制方式同样也会带来一个问题，那就是无法保证 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">严格顺序</strong> 。在上文中我们提到了如何保证的消息顺序性是通过将一个语义的消息发送在同一个队列中，使用 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Topic</code> 下的队列来保证顺序性的。如果此时我们主节点A负责的是订单A的一系列语义消息，然后它挂了，这样其他节点是无法代替主节点A的，如果我们任意节点都可以存入任何消息，那就没有顺序性可言了。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">而在 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 中采用了 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Dledger</code> 解决这个问题。他要求在写入消息的时候，要求<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">至少消息复制到半数以上的节点之后</strong>，才给客⼾端返回写⼊成功，并且它是⽀持通过选举来动态切换主节点的。这里我就不展开说明了，读者可以自己去了解。</p>\n<blockquote style=\"line-height: inherit; display: block; padding: 15px 15px 15px 1rem; font-size: 1em; margin: 1em 0px; color: rgb(129, 145, 152); border-left: 8px solid rgb(255, 138, 101); background: rgb(224, 242, 241); overflow: auto; overflow-wrap: normal; word-break: normal; letter-spacing: 1.5px; font-family: YouYuan;\">\n  <p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 0px;\">也不是说 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Dledger</code> 是个完美的方案，至少在 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Dledger</code> 选举过程中是无法提供服务的，而且他必须要使用三个节点或以上，如果多数节点同时挂掉他也是无法保证可用性的，而且要求消息复制板书以上节点的效率和直接异步复制还是有一定的差距的。</p>\n</blockquote>\n<h3 id=\"h-20\" style=\"color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px; font-weight: bold; font-size: 1.3em;\"><span style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\">存储机制</span></h3>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">还记得上面我们一开始的三个问题吗？到这里第三个问题已经解决了。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">但是，在 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Topic</code> 中的 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">队列是以什么样的形式存在的？队列中的消息又是如何进行存储持久化的呢？</strong> 还未解决，其实这里涉及到了 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 是如何设计它的存储结构了。我首先想大家介绍 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 消息存储架构中的三大角色——<code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">CommitLog</code> 、<code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">ConsumeQueue</code> 和 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">IndexFile</code> 。</p>\n<ul style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px; padding-left: 32px; list-style-type: disc;\">\n<li style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px; margin-bottom: 0.5em;\"><code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">CommitLog</code>： <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">消息主体以及元数据的存储主体</strong>，存储 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Producer</code> 端写入的消息主体内容,消息内容不是定长的。单个文件大小默认1G ，文件名长度为20位，左边补零，剩余为起始偏移量，比如00000000000000000000代表了第一个文件，起始偏移量为0，文件大小为1G=1073741824；当第一个文件写满了，第二个文件为00000000001073741824，起始偏移量为1073741824，以此类推。消息主要是<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">顺序写入日志文件</strong>，当文件满了，写入下一个文件。</li>\n<li style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px; margin-bottom: 0.5em;\"><code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">ConsumeQueue</code>： 消息消费队列，<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">引入的目的主要是提高消息消费的性能</strong>(我们再前面也讲了)，由于<code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 是基于主题 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Topic</code> 的订阅模式，消息消费是针对主题进行的，如果要遍历 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">commitlog</code> 文件中根据 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Topic</code> 检索消息是非常低效的。<code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Consumer</code> 即可根据 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">ConsumeQueue</code> 来查找待消费的消息。其中，<code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">ConsumeQueue</code>（逻辑消费队列）<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">作为消费消息的索引</strong>，保存了指定 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Topic</code> 下的队列消息在 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">CommitLog</code> 中的 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">起始物理偏移量</strong> <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">offset</code>，<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">消息大小</strong><code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">size</code> 和消息 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Tag</code> 的 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">HashCode</code> 值。<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">consumequeue文件</strong> 可以看成是基于topic的 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">commitlog索引文件</strong> ，故 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">consumequeue</code> 文件夹的组织方式如下：topic/queue/file三层组织结构，具体存储路径为：$HOME/store/consumequeue/{topic}/{queueId}/{fileName}。同样 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">consumequeue</code> 文件采取定长设计，每一个条目共20个字节，分别为8字节的 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">commitlog</code> 物理偏移量、4字节的消息长度、8字节tag <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">hashcode</code>，单个文件由30W个条目组成，可以像数组一样随机访问每一个条目，每个 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">ConsumeQueue</code>文件大小约5.72M；</li>\n<li style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px; margin-bottom: 0.5em;\"><code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">IndexFile</code>： <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">IndexFile</code>（索引文件）提供了一种可以通过key或时间区间来查询消息的方法。这里只做科普不做详细介绍。</li>\n</ul>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">总结来说，整个消息存储的结构，最主要的就是 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">CommitLoq</code> 和 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">ConsumeQueue</code> 。而 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">ConsumeQueue</code> 你可以大概理解为 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Topic</code> 中的队列。</p>\n<figure style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><img src=\"https://user-gold-cdn.xitu.io/2019/12/11/16ef3884c02acc72?w=745&amp;h=341&amp;f=jpeg&amp;s=51683\" alt=\"\" title=\"\" style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;\"><figcaption style=\"line-height: inherit; margin: 0px; padding: 0px; margin-top: 10px; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;\"></figcaption></figure>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\"><code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 采用的是 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">混合型的存储结构</strong> ，即为 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 单个实例下所有的队列共用一个日志数据文件来存储消息。有意思的是在同样高并发的 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Kafka</code> 中会为每个 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Topic</code> 分配一个存储文件。这就有点类似于我们有一大堆书需要装上书架，<code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RockeMQ</code> 是不分书的种类直接成批的塞上去的，而 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Kafka</code> 是将书本放入指定的分类区域的。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">而 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 为什么要这么做呢？原因是 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">提高数据的写入效率</strong> ，不分 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Topic</code> 意味着我们有更大的几率获取 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">成批</strong> 的消息进行数据写入，但也会带来一个麻烦就是读取消息的时候需要遍历整个大文件，这是非常耗时的。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">所以，在 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 中又使用了 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">ConsumeQueue</code> 作为每个队列的索引文件来 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">提升读取消息的效率</strong>。我们可以直接根据队列的消息序号，计算出索引的全局位置（索引序号*索引固定⻓度20），然后直接读取这条索引，再根据索引中记录的消息的全局位置，找到消息。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">讲到这里，你可能对 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RockeMQ</code> 的存储架构还有些模糊，没事，我们结合着图来理解一下。</p>\n<figure style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><img src=\"https://user-gold-cdn.xitu.io/2019/12/11/16ef388763c25c62?w=1142&amp;h=896&amp;f=png&amp;s=111170\" alt=\"\" title=\"\" style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;\"><figcaption style=\"line-height: inherit; margin: 0px; padding: 0px; margin-top: 10px; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;\"></figcaption></figure>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">emmm，是不是有一点复杂🤣，看英文图片和英文文档的时候就不要怂，硬着头皮往下看就行。</p>\n<blockquote style=\"line-height: inherit; display: block; padding: 15px 15px 15px 1rem; font-size: 1em; margin: 1em 0px; color: rgb(129, 145, 152); border-left: 8px solid rgb(255, 138, 101); background: rgb(224, 242, 241); overflow: auto; overflow-wrap: normal; word-break: normal; letter-spacing: 1.5px; font-family: YouYuan;\">\n  <p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 0px;\">如果上面没看懂的读者一定要认真看下面的流程分析！</p>\n</blockquote>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">首先，在最上面的那一块就是我刚刚讲的你现在可以直接 <strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">把 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">ConsumerQueue</code> 理解为 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Queue</code></strong>。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">在图中最左边说明了 <font color=\"red\" style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\">红色方块 </font> 代表被写入的消息，虚线方块代表等待被写入的。左边的生产者发送消息会指定 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Topic</code> 、<code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">QueueId</code> 和具体消息内容，而在 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 中管你是哪门子消息，他直接 **全部顺序存储到了 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">CommitLog</code> **。而根据生产者指定的 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Topic</code> 和 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">QueueId</code> 将这条消息本身在 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">CommitLog</code> 的偏移(offset)，消息本身大小，和tag的hash值存入对应的 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">ConsumeQueue</code> 索引文件中。而在每个队列中都保存了 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">ConsumeOffset</code> 即每个消费者组的消费位置(我在架构那里提到了，忘了的同学可以回去看一下)，而消费者拉取消息进行消费的时候只需要根据 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">ConsumeOffset</code> 获取下一个未被消费的消息就行了。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">上述就是我对于整个消息存储架构的大概理解(这里不涉及到一些细节讨论，比如稀疏索引等等问题)，希望对你有帮助。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">因为有一个知识点因为写嗨了忘讲了，想想在哪里加也不好，所以我留给大家去思考🤔🤔一下吧。</p>\n<figure style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><img src=\"https://user-gold-cdn.xitu.io/2019/12/11/16ef38894e8ff697?w=255&amp;h=255&amp;f=jpeg&amp;s=8769\" alt=\"\" title=\"\" style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;\"><figcaption style=\"line-height: inherit; margin: 0px; padding: 0px; margin-top: 10px; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;\"></figcaption></figure>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">为什么 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">CommitLog</code> 文件要设计成固定大小的长度呢？提醒：<strong style=\"font-size: inherit; line-height: inherit; margin: 0px; padding: 0px; font-weight: bold; color: rgb(239, 83, 80);\">内存映射机制</strong>。</p>\n<h2 id=\"h-21\" style=\"color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px; font-weight: bold; font-size: 1.5em; border-bottom: 2.2px solid rgb(255, 111, 0);\"><span style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; background: rgb(255, 111, 0); padding: 5px 15px; display: inline-block;\">总结</span></h2>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">总算把这篇博客写完了。我讲的你们还记得吗😅？</p>\n<figure style=\"font-size: inherit; color: inherit; line-height: inherit; margin: 0px; padding: 0px;\"><img src=\"https://user-gold-cdn.xitu.io/2019/12/11/16ef388ad16144f1?w=255&amp;h=255&amp;f=jpeg&amp;s=10422\" alt=\"\" title=\"\" style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; display: block; margin: 0px auto; max-width: 100%;\"><figcaption style=\"line-height: inherit; margin: 0px; padding: 0px; margin-top: 10px; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;\"></figcaption></figure>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">这篇文章中我主要想大家介绍了</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">消息队列出现的原因</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">消息队列的作用(异步，解耦，削峰)</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">消息队列带来的一系列问题(消息堆积、重复消费、顺序消费、分布式事务等等)</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">消息队列的两种消息模型——队列和主题模式</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">分析了 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 的技术架构(<code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">NameServer</code> 、<code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Broker</code> 、<code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Producer</code> 、<code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">Comsumer</code>)</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">结合着 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 回答了消息队列副作用的解决方案</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">介绍了 <code style=\"font-size: inherit; line-height: inherit; overflow-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0px 2px; color: rgb(55, 71, 79); background: rgb(236, 239, 241);\">RocketMQ</code> 的存储机制和刷盘策略。</p>\n<p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 1.5em 0px;\">等等。。。</p>\n<blockquote style=\"line-height: inherit; display: block; padding: 15px 15px 15px 1rem; font-size: 1em; margin: 1em 0px; color: rgb(129, 145, 152); border-left: 8px solid rgb(255, 138, 101); background: rgb(224, 242, 241); overflow: auto; overflow-wrap: normal; word-break: normal; letter-spacing: 1.5px; font-family: YouYuan;\">\n  <p style=\"font-size: inherit; color: inherit; line-height: inherit; padding: 0px; margin: 0px;\">如果喜欢可以点赞哟👍👍👍。</p>\n</blockquote></div>","blogCover":"http://img.francisqiang.top/1577679634","blogId":3,"blogTitle":"👉冒着挂科的风险也要给你看的消息队列和RocketMQ入门总结"}
2019-12-30 12:21:11.183 [http-nio-8080-exec-8] INFO  com.lgq.controller.BlogController - FrancisBlog: getBlogList:1
2019-12-30 12:23:56.030 [http-nio-8080-exec-6] INFO  com.lgq.controller.MenuController - FrancisBlog: getAllParentMenu
2019-12-30 12:23:56.031 [http-nio-8080-exec-7] INFO  com.lgq.controller.BlogController - FrancisBlog: getBlogList:1
2019-12-30 12:23:56.036 [http-nio-8080-exec-5] INFO  com.lgq.controller.SiteIconController - FrancisBlog: getAllSiteIcon
2019-12-30 12:23:56.037 [http-nio-8080-exec-6] INFO  com.lgq.controller.SiteTagController - FrancisBlog: getAllSiteTag
2019-12-30 12:23:56.040 [http-nio-8080-exec-3] INFO  com.lgq.controller.SiteController - FrancisBlog: getSiteInfo
2019-12-30 12:23:56.042 [http-nio-8080-exec-6] INFO  com.lgq.controller.SiteFriendLinkController - FrancisBlog: getAllSiteFriendLink
2019-12-30 12:23:56.046 [http-nio-8080-exec-3] INFO  com.lgq.service.impl.SiteServiceImpl - DAY_PAGE_VIEW_PREFIX2019-12-30
2019-12-30 12:23:56.047 [http-nio-8080-exec-10] INFO  com.lgq.controller.AdvertisementController - FrancisBlog: getAllAdvertisement
2019-12-30 12:23:56.059 [http-nio-8080-exec-9] INFO  com.lgq.controller.SiteController - FrancisBlog: getSiteInfo
2019-12-30 12:23:56.063 [http-nio-8080-exec-9] INFO  com.lgq.service.impl.SiteServiceImpl - DAY_PAGE_VIEW_PREFIX2019-12-30
2019-12-30 12:23:56.076 [http-nio-8080-exec-1] INFO  com.lgq.controller.SiteController - FrancisBlog: getSiteInfo
2019-12-30 12:23:56.080 [http-nio-8080-exec-1] INFO  com.lgq.service.impl.SiteServiceImpl - DAY_PAGE_VIEW_PREFIX2019-12-30
2019-12-30 12:25:15.886 [http-nio-8080-exec-10] INFO  com.lgq.controller.BlogController - FrancisBlog: getBlogList:1
2019-12-30 12:25:15.886 [http-nio-8080-exec-5] INFO  com.lgq.controller.SiteController - FrancisBlog: getSiteInfo
2019-12-30 12:25:15.888 [http-nio-8080-exec-9] INFO  com.lgq.controller.MenuController - FrancisBlog: getAllParentMenu
2019-12-30 12:25:15.893 [http-nio-8080-exec-5] INFO  com.lgq.service.impl.SiteServiceImpl - DAY_PAGE_VIEW_PREFIX2019-12-30
2019-12-30 12:25:15.894 [http-nio-8080-exec-9] INFO  com.lgq.controller.SiteFriendLinkController - FrancisBlog: getAllSiteFriendLink
2019-12-30 12:25:15.897 [http-nio-8080-exec-2] INFO  com.lgq.controller.SiteIconController - FrancisBlog: getAllSiteIcon
2019-12-30 12:25:15.898 [http-nio-8080-exec-1] INFO  com.lgq.controller.SiteTagController - FrancisBlog: getAllSiteTag
2019-12-30 12:25:15.904 [http-nio-8080-exec-1] INFO  com.lgq.controller.AdvertisementController - FrancisBlog: getAllAdvertisement
2019-12-30 12:25:15.910 [http-nio-8080-exec-8] INFO  com.lgq.controller.SiteController - FrancisBlog: getSiteInfo
2019-12-30 12:25:15.913 [http-nio-8080-exec-8] INFO  com.lgq.service.impl.SiteServiceImpl - DAY_PAGE_VIEW_PREFIX2019-12-30
2019-12-30 12:25:15.928 [http-nio-8080-exec-7] INFO  com.lgq.controller.SiteController - FrancisBlog: getSiteInfo
2019-12-30 12:25:15.932 [http-nio-8080-exec-7] INFO  com.lgq.service.impl.SiteServiceImpl - DAY_PAGE_VIEW_PREFIX2019-12-30
2019-12-30 12:33:10.456 [http-nio-8080-exec-1] INFO  com.lgq.controller.SiteController - FrancisBlog: getSiteInfo
2019-12-30 12:33:10.461 [http-nio-8080-exec-8] INFO  com.lgq.controller.MenuController - FrancisBlog: getAllParentMenu
2019-12-30 12:33:10.469 [http-nio-8080-exec-8] INFO  com.lgq.controller.SiteTagController - FrancisBlog: getAllSiteTag
2019-12-30 12:33:10.460 [http-nio-8080-exec-2] INFO  com.lgq.controller.BlogController - FrancisBlog: getBlogList:1
2019-12-30 12:33:10.479 [http-nio-8080-exec-8] INFO  com.lgq.controller.SiteFriendLinkController - FrancisBlog: getAllSiteFriendLink
2019-12-30 12:33:10.480 [http-nio-8080-exec-7] INFO  com.lgq.controller.SiteIconController - FrancisBlog: getAllSiteIcon
2019-12-30 12:33:10.477 [http-nio-8080-exec-1] INFO  com.lgq.service.impl.SiteServiceImpl - DAY_PAGE_VIEW_PREFIX2019-12-30
2019-12-30 12:33:10.484 [http-nio-8080-exec-3] INFO  com.lgq.controller.AdvertisementController - FrancisBlog: getAllAdvertisement
2019-12-30 12:33:10.500 [http-nio-8080-exec-10] INFO  com.lgq.controller.SiteController - FrancisBlog: getSiteInfo
2019-12-30 12:33:10.508 [http-nio-8080-exec-10] INFO  com.lgq.service.impl.SiteServiceImpl - DAY_PAGE_VIEW_PREFIX2019-12-30
2019-12-30 12:33:10.520 [http-nio-8080-exec-6] INFO  com.lgq.controller.SiteController - FrancisBlog: getSiteInfo
2019-12-30 12:33:10.523 [http-nio-8080-exec-6] INFO  com.lgq.service.impl.SiteServiceImpl - DAY_PAGE_VIEW_PREFIX2019-12-30
